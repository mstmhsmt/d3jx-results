// generated by Diff/AST Java Unparser
package com.baomidou.mybatisplus.toolkit;

public class StringEscape {
  private static boolean isEscapeNeededForString(String x, int stringLength) {
    boolean needsHexEscape = false;
    for (int i = 0; i < stringLength; ++i) {
      char c = x.charAt(i);
      switch (c) {
      case 0:
        needsHexEscape = true;
        break;
      case '\n':
        needsHexEscape = true;
        break;
      case '\r':
        needsHexEscape = true;
        break;
      case '\\':
        needsHexEscape = true;
        break;
      case '\'':
        needsHexEscape = true;
        break;
      case '"':
        needsHexEscape = true;
        break;
      case '\032':
        needsHexEscape = true;
        break;
      }
<<<<<<< /root/work/baomidou/mybatis-plus/d3j/patched-027-0.java
      if (needsHexEscape) {
        break;
      }
    }
    return needsHexEscape;
  }
  private static boolean isEscapeNeededForString(String x, int stringLength) {
    boolean needsHexEscape = false;
    for (int i = 0; i < stringLength; ++i) {
      char c = x.charAt(i);
      switch (c) {
      case '\\':
        needsHexEscape = true;
        break;
      case '\'':
        needsHexEscape = true;
        break;
      case '"':
        needsHexEscape = true;
        break;
      }
      if (needsHexEscape) {
        break;
||||||| /root/work/baomidou/mybatis-plus/d3j/base-027.java
    }
    Type[] parameters = target.getActualTypeArguments();
    Class<?> modelClass = (Class<?>)parameters[0];
    return modelClass;
  }
  protected void injectInsertOneSql(boolean selective, Class<?> mapperClass,
                                    Class<?> modelClass, TableInfo table) {
    KeyGenerator keyGenerator = new NoKeyGenerator();
    StringBuilder fieldBuilder = new StringBuilder();
    StringBuilder placeholderBuilder = new StringBuilder();
    SqlMethod sqlMethod = SqlMethod.INSERT_ONE;
    if (selective) {
      sqlMethod = SqlMethod.INSERT_ONE_SELECTIVE;
    }
    fieldBuilder.append(
        "\n<trim prefix=\"(\" suffix=\")\" suffixOverrides=\",\">\n");
    placeholderBuilder.append(
        "\n<trim prefix=\"(\" suffix=\")\" suffixOverrides=\",\">\n");
    String keyProperty = null;
    String keyColumn = null;
    if (table.getIdType() == IdType.AUTO) {
      keyGenerator = new Jdbc3KeyGenerator();
      keyProperty = table.getKeyProperty();
      keyColumn = table.getKeyColumn();
    } else {
      fieldBuilder.append(table.getKeyColumn()).append(",");
      placeholderBuilder.append("#{")
          .append(table.getKeyProperty())
          .append("},");
    }
    List<TableFieldInfo> fieldList = table.getFieldList();
    for (TableFieldInfo fieldInfo : fieldList) {
      if (selective) {
        fieldBuilder.append(convertIfTagInsert(fieldInfo, false));
        placeholderBuilder.append(convertIfTagInsert(fieldInfo, false));
      }
      fieldBuilder.append(fieldInfo.getColumn()).append(",");
      placeholderBuilder.append("#{").append(fieldInfo.getEl()).append("},");
      if (selective) {
        fieldBuilder.append(convertIfTagInsert(fieldInfo, true));
        placeholderBuilder.append(convertIfTagInsert(fieldInfo, true));
      }
    }
    fieldBuilder.append("\n</trim>");
    placeholderBuilder.append("\n</trim>");
    String sql =
        String.format(sqlMethod.getSql(), table.getTableName(),
                      fieldBuilder.toString(), placeholderBuilder.toString());
    SqlSource sqlSource =
        languageDriver.createSqlSource(configuration, sql, modelClass);
    this.addInsertMappedStatement(mapperClass, modelClass,
                                  sqlMethod.getMethod(), sqlSource,
                                  keyGenerator, keyProperty, keyColumn);
  }
  protected void injectInsertBatchSql(Class<?> mapperClass, Class<?> modelClass,
                                      TableInfo table) {
    KeyGenerator keyGenerator = new NoKeyGenerator();
    StringBuilder fieldBuilder = new StringBuilder();
    StringBuilder placeholderBuilder = new StringBuilder();
    SqlMethod sqlMethod = SqlMethod.INSERT_BATCH_MYSQL;
    if (DBType.ORACLE == dbType) {
      sqlMethod = SqlMethod.INSERT_BATCH_ORACLE;
      placeholderBuilder.append("\n<trim prefix=\"(SELECT \" suffix=\" FROM " +
                                "DUAL)\" suffixOverrides=\",\">\n");
    } else {
      placeholderBuilder.append(
          "\n<trim prefix=\"(\" suffix=\")\" suffixOverrides=\",\">\n");
    }
    fieldBuilder.append(
        "\n<trim prefix=\"(\" suffix=\")\" suffixOverrides=\",\">\n");
    String keyProperty = null;
    String keyColumn = null;
    if (table.getIdType() == IdType.AUTO) {
      keyGenerator = new Jdbc3KeyGenerator();
      keyProperty = table.getKeyProperty();
      keyColumn = table.getKeyColumn();
    } else {
      fieldBuilder.append(table.getKeyColumn()).append(",");
      placeholderBuilder.append("#{item.")
          .append(table.getKeyProperty())
          .append("},");
    }
    List<TableFieldInfo> fieldList = table.getFieldList();
    for (TableFieldInfo fieldInfo : fieldList) {
      fieldBuilder.append(fieldInfo.getColumn()).append(",");
      placeholderBuilder.append("#{item.")
          .append(fieldInfo.getEl())
          .append("},");
    }
    fieldBuilder.append("\n</trim>");
    placeholderBuilder.append("\n</trim>");
    String sql =
        String.format(sqlMethod.getSql(), table.getTableName(),
                      fieldBuilder.toString(), placeholderBuilder.toString());
    SqlSource sqlSource =
        languageDriver.createSqlSource(configuration, sql, modelClass);
    this.addInsertMappedStatement(mapperClass, modelClass,
                                  sqlMethod.getMethod(), sqlSource,
                                  keyGenerator, keyProperty, keyColumn);
  }
  protected void injectDeleteSelectiveSql(Class<?> mapperClass,
                                          Class<?> modelClass,
                                          TableInfo table) {
    SqlMethod sqlMethod = SqlMethod.DELETE_SELECTIVE;
    String sql = String.format(sqlMethod.getSql(), table.getTableName(),
                               sqlWhere(table, false));
    SqlSource sqlSource =
        languageDriver.createSqlSource(configuration, sql, modelClass);
    this.addDeleteMappedStatement(mapperClass, sqlMethod.getMethod(),
                                  sqlSource);
  }
  protected void injectDeleteByMapSql(Class<?> mapperClass, TableInfo table) {
    SqlMethod sqlMethod = SqlMethod.DELETE_BY_MAP;
    String sql = String.format(sqlMethod.getSql(), table.getTableName(),
                               sqlWhereByMap());
    SqlSource sqlSource =
        languageDriver.createSqlSource(configuration, sql, Map.class);
    this.addDeleteMappedStatement(mapperClass, sqlMethod.getMethod(),
                                  sqlSource);
  }
  protected void injectDeleteSql(boolean batch, Class<?> mapperClass,
                                 Class<?> modelClass, TableInfo table) {
    SqlMethod sqlMethod = SqlMethod.DELETE_BY_ID;
    SqlSource sqlSource = null;
    if (batch) {
      sqlMethod = SqlMethod.DELETE_BATCH;
      StringBuilder ids = new StringBuilder();
      ids.append("\n<foreach item=\"item\" index=\"index\" " +
                 "collection=\"list\" separator=\",\">");
      ids.append("#{item}");
      ids.append("\n</foreach>");
      String sql = String.format(sqlMethod.getSql(), table.getTableName(),
                                 table.getKeyColumn(), ids.toString());
      sqlSource =
          languageDriver.createSqlSource(configuration, sql, modelClass);
    } else {
      String sql = String.format(sqlMethod.getSql(), table.getTableName(),
                                 table.getKeyColumn(), table.getKeyColumn());
      sqlSource = new RawSqlSource(configuration, sql, Object.class);
    }
    this.addDeleteMappedStatement(mapperClass, sqlMethod.getMethod(),
                                  sqlSource);
  }
  protected void injectUpdateByIdSql(boolean selective, Class<?> mapperClass,
                                     Class<?> modelClass, TableInfo table) {
    SqlMethod sqlMethod = SqlMethod.UPDATE_BY_ID;
    if (selective) {
      sqlMethod = SqlMethod.UPDATE_SELECTIVE_BY_ID;
    }
    String sql = String.format(sqlMethod.getSql(), table.getTableName(),
                               sqlSet(selective, table), table.getKeyColumn(),
                               table.getKeyProperty());
    SqlSource sqlSource =
        languageDriver.createSqlSource(configuration, sql, modelClass);
    this.addUpdateMappedStatement(mapperClass, modelClass,
                                  sqlMethod.getMethod(), sqlSource);
  }
  protected void injectUpdateBatchById(Class<?> mapperClass,
                                       Class<?> modelClass, TableInfo table) {
    StringBuilder set = new StringBuilder();
    set.append("<trim prefix=\"SET\" suffixOverrides=\",\">\n");
    SqlMethod sqlMethod = SqlMethod.UPDATE_BATCH_BY_ID_MYSQL;
    if (DBType.ORACLE == dbType) {
      sqlMethod = SqlMethod.UPDATE_BATCH_BY_ID_ORACLE;
      List<TableFieldInfo> fieldList = table.getFieldList();
      for (TableFieldInfo fieldInfo : fieldList) {
        set.append(fieldInfo.getColumn())
            .append("=#{item.")
            .append(fieldInfo.getEl())
            .append("},");
      }
    } else if (DBType.MYSQL == dbType) {
      List<TableFieldInfo> fieldList = table.getFieldList();
      for (TableFieldInfo fieldInfo : fieldList) {
        set.append("\n<trim prefix=\"")
            .append(fieldInfo.getColumn())
            .append("=CASE ");
        set.append(table.getKeyColumn()).append("\" suffix=\"END,\">");
        set.append(
            "\n<foreach collection=\"list\" item=\"i\" index=\"index\">");
        set.append(convertIfTag(fieldInfo, "i.", false));
        set.append("\nWHEN ").append("#{i.").append(table.getKeyProperty());
        set.append("} THEN #{i.").append(fieldInfo.getEl()).append("}");
        set.append(convertIfTag(fieldInfo, true));
        set.append("\n</foreach>");
        set.append("\n</trim>");
      }
    }
    set.append("\n</trim>");
    String sql =
        String.format(sqlMethod.getSql(), table.getTableName(), set.toString(),
                      table.getKeyColumn(), table.getKeyProperty());
    SqlSource sqlSource =
        languageDriver.createSqlSource(configuration, sql, modelClass);
    this.addUpdateMappedStatement(mapperClass, modelClass,
                                  sqlMethod.getMethod(), sqlSource);
  }
  protected void injectUpdateSql(boolean selective, Class<?> mapperClass,
                                 Class<?> modelClass, TableInfo table) {
    SqlMethod sqlMethod = SqlMethod.UPDATE;
    if (selective) {
      sqlMethod = SqlMethod.UPDATE_SELECTIVE;
    }
    String sql = String.format(sqlMethod.getSql(), table.getTableName(),
                               sqlSet(selective, table), sqlWhere(table, true));
    SqlSource sqlSource =
        languageDriver.createSqlSource(configuration, sql, modelClass);
    this.addUpdateMappedStatement(mapperClass, modelClass,
                                  sqlMethod.getMethod(), sqlSource);
  }
  protected void injectSelectSql(boolean batch, Class<?> mapperClass,
                                 Class<?> modelClass, TableInfo table) {
    SqlMethod sqlMethod = SqlMethod.SELECT_BY_ID;
    SqlSource sqlSource = null;
    if (batch) {
      sqlMethod = SqlMethod.SELECT_BATCH;
      StringBuilder ids = new StringBuilder();
      ids.append("\n<foreach item=\"item\" index=\"index\" " +
                 "collection=\"list\" separator=\",\">");
      ids.append("#{item}");
      ids.append("\n</foreach>");
      sqlSource = languageDriver.createSqlSource(
          configuration,
          String.format(sqlMethod.getSql(), sqlSelectColumns(table, false),
                        table.getTableName(), table.getKeyColumn(),
                        ids.toString()),
          modelClass);
    } else {
      sqlSource = new RawSqlSource(
          configuration,
          String.format(sqlMethod.getSql(), sqlSelectColumns(table, false),
                        table.getTableName(), table.getKeyColumn(),
                        table.getKeyProperty()),
          Object.class);
    }
    this.addSelectMappedStatement(mapperClass, sqlMethod.getMethod(), sqlSource,
                                  modelClass, table);
  }
  protected void injectSelectByMapSql(Class<?> mapperClass, Class<?> modelClass,
                                      TableInfo table) {
    SqlMethod sqlMethod = SqlMethod.SELECT_BY_MAP;
    String sql =
        String.format(sqlMethod.getSql(), sqlSelectColumns(table, false),
                      table.getTableName(), sqlWhereByMap());
    SqlSource sqlSource =
        languageDriver.createSqlSource(configuration, sql, Map.class);
    this.addSelectMappedStatement(mapperClass, sqlMethod.getMethod(), sqlSource,
                                  modelClass, table);
  }
  protected void injectSelectOneSql(Class<?> mapperClass, Class<?> modelClass,
                                    TableInfo table) {
    SqlMethod sqlMethod = SqlMethod.SELECT_ONE;
    String sql =
        String.format(sqlMethod.getSql(), sqlSelectColumns(table, false),
                      table.getTableName(), sqlWhere(table, false));
    SqlSource sqlSource =
        languageDriver.createSqlSource(configuration, sql, modelClass);
    this.addSelectMappedStatement(mapperClass, sqlMethod.getMethod(), sqlSource,
                                  modelClass, table);
  }
  protected void injectSelectCountSql(Class<?> mapperClass, Class<?> modelClass,
                                      TableInfo table) {
    SqlMethod sqlMethod = SqlMethod.SELECT_COUNT;
    String sql = String.format(sqlMethod.getSql(), table.getTableName(),
                               sqlWhere(table, true));
    SqlSource sqlSource =
        languageDriver.createSqlSource(configuration, sql, modelClass);
    this.addSelectMappedStatement(mapperClass, sqlMethod.getMethod(), sqlSource,
                                  Integer.class, null);
  }
  protected void injectSelectListSql(SqlMethod sqlMethod, Class<?> mapperClass,
                                     Class<?> modelClass, TableInfo table) {
    String sql =
        String.format(sqlMethod.getSql(), sqlSelectColumns(table, true),
                      table.getTableName(), sqlWhereEntityWrapper(table));
    SqlSource sqlSource =
        languageDriver.createSqlSource(configuration, sql, modelClass);
    this.addSelectMappedStatement(mapperClass, sqlMethod.getMethod(), sqlSource,
                                  modelClass, table);
  }
  protected void injectSelectCountByEWSql(SqlMethod sqlMethod,
                                          Class<?> mapperClass,
                                          Class<?> modelClass,
                                          TableInfo table) {
    String sql = String.format(sqlMethod.getSql(), table.getTableName(),
                               sqlWhereEntityWrapper(table));
    SqlSource sqlSource =
        languageDriver.createSqlSource(configuration, sql, modelClass);
    this.addSelectMappedStatement(mapperClass, sqlMethod.getMethod(), sqlSource,
                                  Integer.class, null);
  }
  protected String sqlWhereEntityWrapper(TableInfo table) {
    StringBuilder where = new StringBuilder("\n<if test=\"ew!=null\">");
    where.append("\n<if test=\"ew.entity!=null\">\n<where>");
    where.append("\n<if test=\"ew.entity.")
        .append(table.getKeyProperty())
        .append("!=null\">\n");
    where.append(table.getKeyColumn())
        .append("=#{ew.entity.")
        .append(table.getKeyProperty())
        .append("}");
    where.append("\n</if>");
    List<TableFieldInfo> fieldList = table.getFieldList();
    for (TableFieldInfo fieldInfo : fieldList) {
      where.append(convertIfTag(fieldInfo, "ew.entity.", false));
      where.append(" AND ")
          .append(fieldInfo.getColumn())
          .append("=#{ew.entity.")
          .append(fieldInfo.getEl())
          .append("}");
      where.append(convertIfTag(fieldInfo, true));
    }
    where.append("\n</where>\n</if>");
    where.append(
        "\n<if test=\"ew.sqlSegment!=null\">\n${ew.sqlSegment}\n</if>");
    where.append("\n</if>");
    return where.toString();
  }
  protected String sqlSet(boolean selective, TableInfo table) {
    StringBuilder set = new StringBuilder();
    set.append("<trim prefix=\"SET\" suffixOverrides=\",\">");
    List<TableFieldInfo> fieldList = table.getFieldList();
    for (TableFieldInfo fieldInfo : fieldList) {
      if (selective) {
        set.append(convertIfTag(fieldInfo, "et.", false));
      }
      set.append(fieldInfo.getColumn())
          .append("=#{et.")
          .append(fieldInfo.getEl())
          .append("},");
      if (selective) {
        set.append(convertIfTag(fieldInfo, true));
=======
      if (needsHexEscape) {
        break;
>>>>>>> /root/work/baomidou/mybatis-plus/d3j/patched-027-1.java
      }
    }
<<<<<<< /root/work/baomidou/mybatis-plus/d3j/patched-027-0.java
    return needsHexEscape;
  }
  public static String escapeString(String x) {
    if (x.matches("\'(.+)\'")) {
      x = x.substring(1, x.length() - 1);
    }
    String parameterAsString = x;
    int stringLength = x.length();
    if (isEscapeNeededForString(x, stringLength)) {
      StringBuilder buf = new StringBuilder((int)(x.length() * 1.1));
      for (int i = 0; i < stringLength; ++i) {
        char c = x.charAt(i);
        switch (c) {
        case '\\':
          buf.append('\\');
          buf.append('\\');
          break;
        case '\'':
          buf.append('\\');
          buf.append('\'');
          break;
        case '"':
          buf.append('\\');
          buf.append('"');
          break;
        default:
          buf.append(c);
||||||| /root/work/baomidou/mybatis-plus/d3j/base-027.java
    set.append("\n</trim>");
    return set.toString();
  }
  protected String sqlSelectColumns(TableInfo table, boolean entityWrapper) {
    StringBuilder columns = new StringBuilder();
    if (null != table.getResultMap()) {
      if (entityWrapper) {
        columns.append("<choose><when test=\"ew != null and ew.sqlSelect != " +
                       "null\">${ew.sqlSelect}</when><otherwise>");
      }
      columns.append("*");
      if (entityWrapper) {
        columns.append("</otherwise></choose>");
      }
    } else {
      if (entityWrapper) {
        columns.append("<choose><when test=\"ew != null and ew.sqlSelect != " +
                       "null\">${ew.sqlSelect}</when><otherwise>");
      }
      if (table.isKeyRelated()) {
        columns.append(table.getKeyColumn())
            .append(" AS ")
            .append(table.getKeyProperty());
      } else {
        columns.append(table.getKeyProperty());
      }
      List<TableFieldInfo> fieldList = table.getFieldList();
      for (TableFieldInfo fieldInfo : fieldList) {
        columns.append(",").append(fieldInfo.getColumn());
        if (fieldInfo.isRelated()) {
          columns.append(" AS ").append(fieldInfo.getProperty());
=======
    return needsHexEscape;
  }
  public static String escapeString(String x) {
    if (x.matches("\'(.+)\'")) {
      x = x.substring(1, x.length() - 1);
    }
    String parameterAsString = x;
    int stringLength = x.length();
    if (isEscapeNeededForString(x, stringLength)) {
      StringBuilder buf = new StringBuilder((int)(x.length() * 1.1));
      for (int i = 0; i < stringLength; ++i) {
        char c = x.charAt(i);
        switch (c) {
        case 0:
          buf.append('\\');
          buf.append('0');
          break;
        case '\n':
          buf.append('\\');
          buf.append('n');
          break;
        case '\r':
          buf.append('\\');
          buf.append('r');
          break;
        case '\\':
          buf.append('\\');
          buf.append('\\');
          break;
        case '\'':
          buf.append('\\');
          buf.append('\'');
          break;
        case '"':
          buf.append('\\');
          buf.append('"');
          break;
        case '\032':
          buf.append('\\');
          buf.append('Z');
          break;
        default:
          buf.append(c);
>>>>>>> /root/work/baomidou/mybatis-plus/d3j/patched-027-1.java
        }
      }
      parameterAsString = buf.toString();
    }
    return "\'" + parameterAsString + "\'";
  }
}