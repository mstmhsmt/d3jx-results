// generated by Diff/AST Java Unparser
package org.apereo.cas.authentication.principal.resolvers;
import lombok.extern.slf4j.Slf4j;
import org.apereo.cas.authentication.AuthenticationHandler;
import org.apereo.cas.authentication.Credential;
import org.apereo.cas.authentication.PrincipalException;
import org.apereo.cas.authentication.principal.DefaultPrincipalFactory;
import org.apereo.cas.authentication.principal.NullPrincipal;
import org.apereo.cas.authentication.principal.Principal;
import org.apereo.cas.authentication.principal.PrincipalFactory;
import org.apereo.cas.authentication.principal.PrincipalResolver;
import org.apereo.services.persondir.IPersonAttributeDao;
import org.apereo.services.persondir.support.MergingPersonAttributeDaoImpl;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;
import lombok.ToString;
import lombok.Setter;
@Slf4j
@ToString
@Setter
public
class ChainingPrincipalResolver implements PrincipalResolver
{
   private final PrincipalFactory principalFactory =
     new DefaultPrincipalFactory();
   private List<PrincipalResolver> chain;
   @Override
   public
   Principal resolve(final Credential credential, 
                     final Optional<Principal> principal, 
                     final Optional<AuthenticationHandler> handler) {
     final List<Principal> principals = new ArrayList<>();
     chain.stream().filter(resolver -> resolver.supports(credential)).forEach(resolver -> {
         LOGGER.debug("Invoking principal resolver [{}]", resolver);
         final var p = resolver.resolve(credential, principal, handler);
         if (p != null) {
           principals.add(p);
         }
       });
     if (principals.isEmpty()) {
       LOGGER.warn("None of the principal resolvers in the chain were able to produce a principal");
       return NullPrincipal.getInstance();
     }
     final Map<String,Object> attributes = new HashMap<>();
     principals.forEach(p -> {
         if (p != null) {
           LOGGER.debug("Resolved principal [{}]", p);
           final var principalAttributes = p.getAttributes();
           if (principalAttributes != null && !principalAttributes.isEmpty()) {
             LOGGER.debug("Adding attributes [{}] for the final principal",
               principalAttributes);
             attributes.putAll(principalAttributes);
           }
         }
       });
     final int count =
       principals.stream().map(p -> p.getId().trim().toLowerCase()).collect(
         Collectors.toSet()).size();
     if (count > 1) {
       throw new PrincipalException("Resolved principals by the chain are not unique because principal resolvers have produced CAS principals " + "with different identifiers which typically is the result of a configuration issue.",
               new HashMap<>(0), new HashMap<>(0));
     }
     final var principalId =
       principal.isPresent() ? principal.get().getId() : principals.get(count - 1).getId();
     final var finalPrincipal =
       this.principalFactory.createPrincipal(principalId, attributes);
     LOGGER.debug("Final principal constructed by the chain of resolvers is [{}]",
       finalPrincipal);
     return finalPrincipal;
   }
   @Override
   public
   boolean supports(final Credential credential) {
     return this.chain.get(0).supports(credential);
   }
   @Override
   public
   IPersonAttributeDao getAttributeRepository() {
     final var dao = new MergingPersonAttributeDaoImpl();
     dao.setPersonAttributeDaos(this.chain.stream().map(PrincipalResolver::getAttributeRepository).collect(
                                  Collectors.toList()));
     return dao;
   }
}