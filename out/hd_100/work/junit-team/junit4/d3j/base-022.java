// generated by Diff/AST Java Unparser
package org.junit.runners;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.internal.AssumptionViolatedException;
import org.junit.internal.runners.model.EachTestNotifier;
import org.junit.internal.runners.model.MultipleFailureException;
import org.junit.internal.runners.statements.RunAfters;
import org.junit.internal.runners.statements.RunBefores;
import org.junit.runner.Description;
import org.junit.runner.Runner;
import org.junit.runner.manipulation.Filter;
import org.junit.runner.manipulation.Filterable;
import org.junit.runner.manipulation.NoTestsRemainException;
import org.junit.runner.manipulation.Sortable;
import org.junit.runner.manipulation.Sorter;
import org.junit.runner.notification.RunNotifier;
import org.junit.runner.notification.StoppedByUserException;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.Statement;
import org.junit.runners.model.TestClass;
public abstract class ParentRunner<T>
    extends Runner implements Filterable, Sortable {
  private final TestClass fTestClass;
  private Filter fFilter = null;
  private Sorter fSorter = Sorter.NULL;
  protected ParentRunner(Class<?> testClass) throws InitializationError {
    fTestClass = new TestClass(testClass);
    validate();
  }
  protected abstract List<T> getChildren();
  protected abstract Description describeChild(T child);
  protected abstract void runChild(T child, RunNotifier notifier);
  public List<T> internalGetChildren() { return getChildren(); }
  public Description internalDescribeChild(T child) {
    return describeChild(child);
  }
  public void internalRunChild(T child, RunNotifier notifier) {
    runChild(child, notifier);
  }
  protected void collectInitializationErrors(List<Throwable> errors) {
    validatePublicVoidNoArgMethods(BeforeClass.class, true, errors);
    validatePublicVoidNoArgMethods(AfterClass.class, true, errors);
  }
  protected void
  validatePublicVoidNoArgMethods(Class<? extends Annotation> annotation,
                                 boolean isStatic, List<Throwable> errors) {
    List<FrameworkMethod> methods =
        getTestClass().getAnnotatedMethods(annotation);
    for (FrameworkMethod eachTestMethod : methods)
      eachTestMethod.validatePublicVoidNoArg(isStatic, errors);
  }
  protected Statement classBlock(final RunNotifier notifier) {
    Statement statement = childrenInvoker(notifier);
    statement = withBeforeClasses(statement);
    statement = withAfterClasses(statement);
    return statement;
  }
  protected Statement withBeforeClasses(Statement statement) {
    List<FrameworkMethod> befores =
        fTestClass.getAnnotatedMethods(BeforeClass.class);
    statement = new RunBefores(statement, befores, null);
    return statement;
  }
  protected Statement withAfterClasses(Statement statement) {
    List<FrameworkMethod> afters =
        fTestClass.getAnnotatedMethods(AfterClass.class);
    statement = new RunAfters(statement, afters, null);
    return statement;
  }
  protected Statement childrenInvoker(final RunNotifier notifier) {
    return new Statement() {
      @Override
      public void evaluate() {
        runChildren(notifier);
      }
    };
  }
  private void runChildren(final RunNotifier notifier) {
    for (T each : getFilteredChildren())
      runChild(each, notifier);
  }
  protected String getName() { return fTestClass.getName(); }
  public final TestClass getTestClass() { return fTestClass; }
  @Override
  public Description getDescription() {
    Description description = Description.createSuiteDescription(
        getName(), fTestClass.getAnnotations());
    for (T child : getFilteredChildren())
      description.addChild(describeChild(child));
    return description;
  }
  @Override
  public void run(final RunNotifier notifier) {
    EachTestNotifier testNotifier =
        new EachTestNotifier(notifier, getDescription());
    try {
      Statement statement = classBlock(notifier);
      statement.evaluate();
    } catch (AssumptionViolatedException e) {
      testNotifier.fireTestIgnored();
    } catch (StoppedByUserException e) {
      throw e;
    } catch (Throwable e) {
      testNotifier.addFailure(e);
    }
  }
  public void filter(Filter filter) throws NoTestsRemainException {
    fFilter = filter;
    for (T each : getChildren())
      if (shouldRun(each))
        return;
    throw new NoTestsRemainException();
  }
  public void sort(Sorter sorter) { fSorter = sorter; }
  private void validate() throws InitializationError {
    List<Throwable> errors = new ArrayList<Throwable>();
    collectInitializationErrors(errors);
    if (!errors.isEmpty())
      throw new InitializationError(errors);
  }
  protected List<T> getFilteredChildren() {
    ArrayList<T> filtered = new ArrayList<T>();
    for (T each : getChildren())
      if (shouldRun(each))
        try {
          filterChild(each);
          sortChild(each);
          filtered.add(each);
        } catch (NoTestsRemainException e) {
        }
    Collections.sort(filtered, comparator());
    return filtered;
  }
  private void sortChild(T child) { fSorter.apply(child); }
  private void filterChild(T child) throws NoTestsRemainException {
    if (fFilter != null)
      fFilter.apply(child);
  }
  private boolean shouldRun(T each) {
    return fFilter == null || fFilter.shouldRun(describeChild(each));
  }
  private Comparator<? super T> comparator() {
    return new Comparator<T>() {
      public int compare(T o1, T o2) {
        return fSorter.compare(describeChild(o1), describeChild(o2));
      }
    };
  }
}