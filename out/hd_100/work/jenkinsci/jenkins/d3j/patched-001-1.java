// generated by Diff/AST Java Unparser
package jenkins.install;
import static java.util.logging.Level.SEVERE;
import static java.util.logging.Level.WARNING;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.logging.Logger;
import javax.annotation.CheckForNull;
import javax.annotation.Nonnull;
import javax.inject.Provider;
import org.apache.commons.io.FileUtils;
import org.apache.commons.lang.StringUtils;
import org.kohsuke.accmod.Restricted;
import org.kohsuke.accmod.restrictions.NoExternalUse;
import com.google.common.base.Function;
import com.thoughtworks.xstream.XStream;
import hudson.Functions;
import hudson.Main;
import hudson.model.UpdateCenter.DownloadJob.InstallationStatus;
import hudson.model.UpdateCenter.DownloadJob.Installing;
import hudson.model.UpdateCenter.InstallationJob;
import hudson.model.UpdateCenter.UpdateCenterJob;
import hudson.util.VersionNumber;
import jenkins.model.Jenkins;
import jenkins.util.SystemProperties;
import jenkins.util.xml.XMLUtils;
@Restricted(NoExternalUse.class)
public class InstallUtil {
  private static final Logger LOGGER =
      Logger.getLogger(InstallUtil.class.getName());
  private static final VersionNumber NEW_INSTALL_VERSION =
      new VersionNumber("1.0");
  private static final VersionNumber FORCE_NEW_INSTALL_VERSION =
      new VersionNumber("0.0");
  private static class ProviderChain<T> implements Provider<T> {
    private final Iterator<Function<Provider<T>, T>> functions;
    public ProviderChain(Iterator<Function<Provider<T>, T>> functions) {
      this.functions = functions;
    }
    @Override
    public T get() {
      return functions.next().apply(this);
    }
  }
  public static void proceedToNextStateFrom(InstallState prior) {
    InstallState next = getNextInstallState(prior);
    if (Main.isDevelopmentMode)
      LOGGER.info("Install state tranisitioning from: " + prior +
                  " to: " + next);
    if (next != null) {
      Jenkins.getInstance().setInstallState(next);
    }
  }
  static InstallState getNextInstallState(final InstallState current) {
    List<Function<Provider<InstallState>, InstallState>>
        installStateFilterChain = new ArrayList<>();
    for (final InstallStateFilter setupExtension : InstallStateFilter.all()) {
      installStateFilterChain.add(
          new Function<Provider<InstallState>, InstallState>() {
            @Override
            public InstallState apply(Provider<InstallState> next) {
              return setupExtension.getNextInstallState(current, next);
            }
          });
    }
    installStateFilterChain.add(
        new Function<Provider<InstallState>, InstallState>() {
          @Override
          public InstallState apply(Provider<InstallState> input) {
            if (current == null || InstallState.UNKNOWN.equals(current)) {
              return getDefaultInstallState();
            }
            final Map<InstallState, InstallState> states =
                new HashMap<InstallState, InstallState>();
            {
              states.put(InstallState.CREATE_ADMIN_USER,
                         InstallState.INITIAL_SETUP_COMPLETED);
              states.put(InstallState.INITIAL_PLUGINS_INSTALLING,
                         InstallState.CREATE_ADMIN_USER);
              states.put(InstallState.INITIAL_SECURITY_SETUP, InstallState.NEW);
              states.put(InstallState.RESTART, InstallState.RUNNING);
              states.put(InstallState.UPGRADE,
                         InstallState.INITIAL_SETUP_COMPLETED);
              states.put(InstallState.DOWNGRADE,
                         InstallState.INITIAL_SETUP_COMPLETED);
              states.put(InstallState.INITIAL_SETUP_COMPLETED,
                         InstallState.RUNNING);
            }
            return states.get(current);
          }
        });
    ProviderChain<InstallState> chain =
        new ProviderChain<>(installStateFilterChain.iterator());
    return chain.get();
  }
  private static InstallState getDefaultInstallState() {
    String stateOverride = System.getProperty(
        "jenkins.install.state", System.getenv("jenkins.install.state"));
    if (stateOverride != null) {
      try {
        return InstallState.valueOf(stateOverride.toUpperCase());
      } catch (RuntimeException e) {
        throw new IllegalStateException(
            "Unknown install state override specified on the commandline: '" +
            stateOverride + "'.");
      }
    }
    String shouldRunFlag =
        SystemProperties.getString("jenkins.install.runSetupWizard");
    boolean shouldRun = "true".equalsIgnoreCase(shouldRunFlag);
    boolean shouldNotRun = "false".equalsIgnoreCase(shouldRunFlag);
    if (!shouldRun) {
      if (Functions.getIsUnitTest()) {
        return InstallState.TEST;
      }
      if (SystemProperties.getBoolean("hudson.Main.development")) {
        return InstallState.DEVELOPMENT;
      }
    }
    VersionNumber lastRunVersion = new VersionNumber(getLastExecVersion());
    if (lastRunVersion.compareTo(NEW_INSTALL_VERSION) == 0) {
      Jenkins j = Jenkins.getInstance();
      if (shouldNotRun) {
        try {
          InstallState.INITIAL_SETUP_COMPLETED.initializeState();
          return j.getInstallState();
        } catch (RuntimeException e) {
          throw e;
        } catch (Exception e) {
          throw new RuntimeException(e);
        }
      }
      if (!j.getItemMap().isEmpty() || !j.getNodes().isEmpty()) {
        return InstallState.UPGRADE;
      }
      return InstallState.INITIAL_SECURITY_SETUP;
    }
    VersionNumber currentRunVersion =
        new VersionNumber(getCurrentExecVersion());
    if (lastRunVersion.isOlderThan(currentRunVersion)) {
      return InstallState.UPGRADE;
    } else if (lastRunVersion.isNewerThan(currentRunVersion)) {
      return InstallState.DOWNGRADE;
    } else {
      return InstallState.RESTART;
    }
  }
  public static void saveLastExecVersion() {
    if (Jenkins.VERSION.equals(Jenkins.UNCOMPUTED_VERSION)) {
      throw new IllegalStateException(
          "Unexpected call to InstallUtil.saveLastExecVersion(). " +
          "Jenkins.VERSION has not been initialized. Call computeVersion() " +
          "first.");
    }
    saveLastExecVersion(Jenkins.VERSION);
  }
  public static @Nonnull String getLastExecVersion() {
    File lastExecVersionFile = getLastExecVersionFile();
    if (lastExecVersionFile.exists()) {
      try {
        String version = FileUtils.readFileToString(lastExecVersionFile);
        if (StringUtils.isBlank(version)) {
          return FORCE_NEW_INSTALL_VERSION.toString();
        }
        return version;
      } catch (IOException e) {
        LOGGER.log(SEVERE,
                   "Unexpected Error. Unable to read " +
                       lastExecVersionFile.getAbsolutePath(),
                   e);
        LOGGER.log(
            WARNING,
            "Unable to determine the last running version (see error above). " +
            "Treating this as a restart. No plugins will be updated.");
        return getCurrentExecVersion();
      }
    } else {
      File configFile = getConfigFile();
      if (configFile.exists()) {
        try {
          String lastVersion = XMLUtils.getValue("/hudson/version", configFile);
          if (lastVersion.length() > 0) {
            return lastVersion;
          }
        } catch (Exception e) {
          LOGGER.log(SEVERE, "Unexpected error reading global config.xml", e);
        }
      }
      return NEW_INSTALL_VERSION.toString();
    }
  }
  static void saveLastExecVersion(@Nonnull String version) {
    File lastExecVersionFile = getLastExecVersionFile();
    try {
      FileUtils.write(lastExecVersionFile, version);
    } catch (IOException e) {
      LOGGER.log(SEVERE,
                 "Failed to save " + lastExecVersionFile.getAbsolutePath(), e);
    }
  }
  static File getConfigFile() {
    return new File(Jenkins.getInstance().getRootDir(), "config.xml");
  }
  static File getLastExecVersionFile() {
    return new File(Jenkins.getInstance().getRootDir(),
                    "jenkins.install.InstallUtil.lastExecVersion");
  }
  static File getInstallingPluginsFile() {
    return new File(Jenkins.getInstance().getRootDir(),
                    "jenkins.install.InstallUtil.installingPlugins");
  }
  private static String getCurrentExecVersion() {
    if (Jenkins.VERSION.equals(Jenkins.UNCOMPUTED_VERSION)) {
      throw new IllegalStateException(
          "Unexpected call to InstallUtil.getCurrentExecVersion(). " +
          "Jenkins.VERSION has not been initialized. Call computeVersion() " +
          "first.");
    }
    return Jenkins.VERSION;
  }
  @SuppressWarnings("unchecked")
  public static synchronized @CheckForNull Map<String, String>
  getPersistedInstallStatus() {
    File installingPluginsFile = getInstallingPluginsFile();
    if (installingPluginsFile == null || !installingPluginsFile.exists()) {
      return null;
    }
    return (Map<String, String>)new XStream().fromXML(installingPluginsFile);
  }
  public static synchronized void
  persistInstallStatus(List<UpdateCenterJob> installingPlugins) {
    File installingPluginsFile = getInstallingPluginsFile();
    if (installingPlugins == null || installingPlugins.isEmpty()) {
      installingPluginsFile.delete();
      return;
    }
    LOGGER.fine("Writing install state to: " +
                installingPluginsFile.getAbsolutePath());
    Map<String, String> statuses = new HashMap<String, String>();
    for (UpdateCenterJob j : installingPlugins) {
      if (j instanceof InstallationJob && j.getCorrelationId() != null) {
        InstallationJob ij = (InstallationJob)j;
        InstallationStatus status = ij.status;
        String statusText = status.getType();
        if (status instanceof Installing) {
          statusText = "Pending";
        }
        statuses.put(ij.plugin.name, statusText);
      }
    }
    try {
      String installingPluginXml = new XStream().toXML(statuses);
      FileUtils.write(installingPluginsFile, installingPluginXml);
    } catch (IOException e) {
      LOGGER.log(SEVERE,
                 "Failed to save " + installingPluginsFile.getAbsolutePath(),
                 e);
    }
  }
  public static void clearInstallStatus() { persistInstallStatus(null); }
}