// generated by Diff/AST Java Unparser
package org.elasticsearch.search.sort;
import org.apache.lucene.search.SortField;
import org.elasticsearch.common.ParseField;
import org.elasticsearch.common.ParseFieldMatcher;
import org.elasticsearch.common.ParsingException;
import org.elasticsearch.common.io.stream.StreamInput;
import org.elasticsearch.common.io.stream.StreamOutput;
import org.elasticsearch.common.xcontent.XContentBuilder;
import org.elasticsearch.common.xcontent.XContentParser;
import org.elasticsearch.index.query.QueryParseContext;
import org.elasticsearch.index.query.QueryShardContext;
import java.io.IOException;
import java.util.Objects;
public
class ScoreSortBuilder extends SortBuilder<ScoreSortBuilder>
{
   public static final String NAME = "_score";
   public static final ScoreSortBuilder PROTOTYPE = new ScoreSortBuilder();
   public static final ParseField ORDER_FIELD = new ParseField("order");
   private static final SortField SORT_SCORE =
     new SortField(null, SortField.Type.SCORE);
   private static final SortField SORT_SCORE_REVERSE =
     new SortField(null, SortField.Type.SCORE, true);
   public
   ScoreSortBuilder() {
     order(SortOrder.DESC);
   }
   @Override
   public
   XContentBuilder toXContent(XContentBuilder builder, Params params)
     throws IOException {
     builder.startObject();
     builder.startObject(NAME);
     builder.field(ORDER_FIELD.getPreferredName(), order);
     builder.endObject();
     builder.endObject();
     return builder;
   }
   @Override
   public
   ScoreSortBuilder fromXContent(QueryParseContext context, 
                                 String elementName)
     throws IOException {
     XContentParser parser = context.parser();
     ParseFieldMatcher matcher = context.parseFieldMatcher();
     XContentParser.Token token;
     String currentName = parser.currentName();
     ScoreSortBuilder result = new ScoreSortBuilder();
     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
       if (token == XContentParser.Token.FIELD_NAME) {
         currentName = parser.currentName();
       } else if (token.isValue()) {
         if (matcher.match(currentName, ORDER_FIELD)) {
           result.order(SortOrder.fromString(parser.text()));
         } else {
           throw new ParsingException(parser.getTokenLocation(),
                   "[" + NAME + "] failed to parse field [" + currentName + "]");
         }
       } else {
         throw new ParsingException(parser.getTokenLocation(),
                 "[" + NAME + "] unexpected token [" + token + "]");
       }
     }
     return result;
   }
   @Override
   public
   SortField build(QueryShardContext context) {
     if (order == SortOrder.DESC) {
       return SORT_SCORE;
     } else {
       return SORT_SCORE_REVERSE;
     }
   }
   @Override
   public
   boolean equals(Object object) {
     if (this == object) {
       return true;
     }
     if (object == null || getClass() != object.getClass()) {
       return false;
     }
     ScoreSortBuilder other = (ScoreSortBuilder)object;
     return Objects.equals(order, other.order);
   }
   @Override
   public
   int hashCode() {
     return Objects.hash(this.order);
   }
   @Override
   public
   void writeTo(StreamOutput out) throws IOException {
     order.writeTo(out);
   }
   @Override
   public
   ScoreSortBuilder readFrom(StreamInput in) throws IOException {
     ScoreSortBuilder builder =
       new ScoreSortBuilder().order(SortOrder.readOrderFrom(in));
     return builder;
   }
   @Override
   public
   String getWriteableName() {
     return NAME;
   }
}