// generated by Diff/AST Java Unparser
package org.antlr.v4.runtime.atn;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.NoViableAltException;
import org.antlr.v4.runtime.Parser;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.RuleContext;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.TokenStream;
import org.antlr.v4.runtime.dfa.DFA;
import org.antlr.v4.runtime.dfa.DFAState;
import org.antlr.v4.runtime.misc.DoubleKeyMap;
import org.antlr.v4.runtime.misc.Interval;
import org.antlr.v4.runtime.misc.IntervalSet;
import org.antlr.v4.runtime.misc.NotNull;
import org.antlr.v4.runtime.misc.Nullable;
import org.stringtemplate.v4.misc.MultiMap;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
public class ParserATNSimulator<Symbol extends Token> extends ATNSimulator {
  public static boolean debug = false;
  public static boolean debug_list_atn_decisions = false;
  public static boolean dfa_debug = false;
  public static boolean retry_debug = false;
  public static final boolean SLL_loopsSimulateTailRecursion = false;
  public static int ATN_failover = 0;
  public static int predict_calls = 0;
  public static int retry_with_context = 0;
  public static int retry_with_context_indicates_no_conflict = 0;
  public static int retry_with_context_predicts_same_as_alt = 0;
  public static int retry_with_context_from_dfa = 0;
  @Nullable protected final Parser parser;
  @NotNull public final DFA[] decisionToDFA;
  protected boolean SLL = false;
  protected DoubleKeyMap<PredictionContext, PredictionContext,
                         PredictionContext> mergeCache;
  protected TokenStream _input;
  protected int _startIndex;
  protected ParserRuleContext<?> _outerContext;
  public ParserATNSimulator(@NotNull ATN atn, @NotNull DFA[] decisionToDFA,
                            @NotNull PredictionContextCache
                                sharedContextCache) {
    this(null, atn, decisionToDFA, sharedContextCache);
  }
  public ParserATNSimulator(
      @Nullable Parser parser, @NotNull ATN atn, @NotNull DFA[] decisionToDFA,
      @NotNull PredictionContextCache sharedContextCache) {
    super(atn, sharedContextCache);
    this.parser = parser;
    this.decisionToDFA = decisionToDFA;
  }
  @Override
  public void reset() {}
  public int adaptivePredict(@NotNull TokenStream input, int decision,
                             @Nullable ParserRuleContext<?> outerContext) {
    if (debug || debug_list_atn_decisions) {
      System.out.println("adaptivePredict decision " + decision +
                         " exec LA(1)==" + getLookaheadName(input) +
                         " line " + input.LT(1).getLine() + ":" +
                         input.LT(1).getCharPositionInLine());
    }
    mergeCache = new DoubleKeyMap<PredictionContext, PredictionContext,
                                  PredictionContext>();
    _input = input;
    _startIndex = input.index();
    _outerContext = outerContext;
    predict_calls++;
    DFA dfa = decisionToDFA[decision];
<<<<<<< /root/work/antlr/antlr4/d3j/patched-021-0.java
    if (dfa == null) {
      synchronized (decisionToDFA) {
        dfa = decisionToDFA[decision];
        if (dfa == null) {
          DecisionState startState = atn.decisionToState.get(decision);
          decisionToDFA[decision] = new DFA(startState, decision);
          dfa = decisionToDFA[decision];
        }
||||||| /root/work/antlr/antlr4/d3j/base-021.java
    if (dfa == null || dfa.s0 == null) {
      DecisionState startState = atn.decisionToState.get(decision);
      decisionToDFA[decision] = dfa = new DFA(startState, decision);
      return predictATN(dfa, input, outerContext);
    } else {
      int m = input.mark();
      int index = input.index();
      try {
        int alt = execDFA(dfa, dfa.s0, input, index, outerContext);
        return alt;
      } finally {
        input.seek(index);
        input.release(m);
=======
    if (dfa == null) {
      synchronized (decisionToDFA) {
        dfa = decisionToDFA[decision];
        if (dfa == null) {
          DecisionState startState = atn.decisionToState.get(decision);
          decisionToDFA[decision] = new DFA(startState, decision);
          dfa = decisionToDFA[decision];
        }
      }
    }
    if (dfa.s0 == null) {
      if (dfa.s0 == null) {
        try {
          return predictATN(dfa, input, outerContext);
        } finally {
          mergeCache = null;
        }
>>>>>>> /root/work/antlr/antlr4/d3j/patched-021-1.java
      }
    }
<<<<<<< /root/work/antlr/antlr4/d3j/patched-021-0.java
    if (dfa.s0 == null) {
      if (dfa.s0 == null) {
        try {
          return predictATN(dfa, input, outerContext);
        } finally {
          mergeCache = null;
        }
      }
    }
    int m = input.mark();
    int index = input.index();
    try {
      return execDFA(dfa, dfa.s0, input, index, outerContext);
    } finally {
      mergeCache = null;
      input.seek(index);
      input.release(m);
    }
||||||| /root/work/antlr/antlr4/d3j/base-021.java
=======
    int m = input.mark();
    int index = input.index();
    try {
      return execDFA(dfa, dfa.s0, input, index, outerContext);
    } finally {
      mergeCache = null;
      input.seek(index);
      input.release(m);
    }
>>>>>>> /root/work/antlr/antlr4/d3j/patched-021-1.java
  }
  public int predictATN(@NotNull DFA dfa, @NotNull TokenStream input,
                        @Nullable ParserRuleContext<?> outerContext) {
    if (outerContext == null)
      outerContext = ParserRuleContext.EMPTY;
    if (debug || debug_list_atn_decisions) {
      System.out.println("predictATN decision " + dfa.decision +
                         " exec LA(1)==" + getLookaheadName(input) +
                         ", outerContext=" + outerContext.toString(parser));
    }
    DecisionState decState = atn.getDecisionState(dfa.decision);
    boolean greedy = decState.isGreedy;
    boolean loopsSimulateTailRecursion = SLL_loopsSimulateTailRecursion;
    boolean fullCtx = false;
    ATNConfigSet s0_closure =
        computeStartState(dfa.atnStartState, ParserRuleContext.EMPTY, greedy,
                          loopsSimulateTailRecursion, fullCtx);
    dfa.s0 = addDFAState(dfa, new DFAState(s0_closure));
    int alt = 0;
    int m = input.mark();
    int index = input.index();
    try {
      alt = execATN(dfa, dfa.s0, input, index, outerContext);
    } catch (NoViableAltException nvae) {
      if (debug)
        dumpDeadEndConfigs(nvae);
      throw nvae;
    } finally {
      input.seek(index);
      input.release(m);
    }
    if (debug)
      System.out.println("DFA after predictATN: " +
                         dfa.toString(parser.getTokenNames()));
    return alt;
  }
  public int execDFA(@NotNull DFA dfa, @NotNull DFAState s0,
                     @NotNull TokenStream input, int startIndex,
                     @Nullable ParserRuleContext<?> outerContext) {
    if (outerContext == null)
      outerContext = ParserRuleContext.EMPTY;
    if (dfa_debug) {
      System.out.println("execDFA decision " + dfa.decision +
                         " exec LA(1)==" + getLookaheadName(input) +
                         ", outerContext=" + outerContext.toString(parser));
    }
    if (dfa_debug)
      System.out.print(dfa.toString(parser.getTokenNames()));
    DFAState acceptState = null;
    DFAState s = s0;
    DecisionState decState = atn.getDecisionState(dfa.decision);
    boolean greedy = decState.isGreedy;
    int t = input.LA(1);
  loop:
    while (true) {
      if (dfa_debug)
        System.out.println("DFA state " + s.stateNumber +
                           " LA(1)==" + getLookaheadName(input));
      if (s.isCtxSensitive && !SLL) {
        if (dfa_debug)
          System.out.println("ctx sensitive state " + outerContext + " in " +
                             s);
        boolean loopsSimulateTailRecursion = true;
        boolean fullCtx = true;
        ATNConfigSet s0_closure =
            computeStartState(dfa.atnStartState, outerContext, greedy,
                              loopsSimulateTailRecursion, fullCtx);
        retry_with_context_from_dfa++;
        int alt = execATNWithFullContext(dfa, s, s0_closure, input, startIndex,
                                         outerContext, ATN.INVALID_ALT_NUMBER,
                                         greedy);
        return alt;
      }
      if (s.isAcceptState) {
        if (s.predicates != null) {
          if (dfa_debug)
            System.out.println("accept " + s);
        } else {
          if (dfa_debug)
            System.out.println("accept; predict " + s.prediction +
                               " in state " + s.stateNumber);
        }
        acceptState = s;
        break;
      }
      assert !s.isCtxSensitive && !s.isAcceptState;
      if (s.edges == null || t >= s.edges.length || t < -1 ||
          s.edges[t + 1] == null) {
        if (dfa_debug && t >= 0)
          System.out.println("no edge for " + parser.getTokenNames()[t]);
        int alt;
        if (dfa_debug) {
          Interval interval =
              Interval.of(startIndex, parser.getTokenStream().index());
          System.out.println("ATN exec upon " +
                             parser.getTokenStream().getText(interval) +
                             " at DFA state " + s.stateNumber);
        }
        if (s.edges == null || t >= s.edges.length || t < -1 ||
            s.edges[t + 1] == null) {
          alt = execATN(dfa, s, input, startIndex, outerContext);
          if (s.isAcceptState && alt != -1) {
            DFAState d = s.edges[input.LA(1) + 1];
            if (d.isAcceptState && d.prediction == s.prediction) {
              s.edges[input.LA(1) + 1] = ERROR;
            }
          }
          if (dfa_debug) {
            System.out.println("back from DFA update, alt=" + alt + ", dfa=\n" +
                               dfa.toString(parser.getTokenNames()));
          }
          if (dfa_debug)
            System.out.println("DFA decision " + dfa.decision + " predicts " +
                               alt);
          return alt;
        }
      }
      DFAState target = s.edges[t + 1];
      if (target == ERROR) {
        throw noViableAlt(input, outerContext, s.configs, startIndex);
      }
      s = target;
      if (!s.isCtxSensitive && !s.isAcceptState) {
        input.consume();
        t = input.LA(1);
      }
    }
    if (s.predicates != null) {
      input.seek(startIndex);
      IntervalSet alts = evalSemanticContext(s.predicates, outerContext, false);
      if (alts.isNil()) {
        throw noViableAlt(input, outerContext, s.configs, startIndex);
      }
      return alts.getMinElement();
    }
    if (dfa_debug)
      System.out.println("DFA decision " + dfa.decision + " predicts " +
                         acceptState.prediction);
    return acceptState.prediction;
  }
  public int execATN(@NotNull DFA dfa, @NotNull DFAState s0,
                     @NotNull TokenStream input, int startIndex,
                     ParserRuleContext<?> outerContext) {
    if (debug || debug_list_atn_decisions) {
      System.out.println("execATN decision " + dfa.decision +
                         " exec LA(1)==" + getLookaheadName(input) +
                         " line " + input.LT(1).getLine() + ":" +
                         input.LT(1).getCharPositionInLine());
    }
    ATN_failover++;
    ATNConfigSet previous = s0.configs;
    DFAState previousD = s0;
    ATNConfigSet fullCtxSet;
    if (debug)
      System.out.println("s0 = " + s0);
    int t = input.LA(1);
    DecisionState decState = atn.getDecisionState(dfa.decision);
    boolean greedy = decState.isGreedy;
    while (true) {
      boolean loopsSimulateTailRecursion = SLL_loopsSimulateTailRecursion;
      ATNConfigSet reach = computeReachSet(previous, t, greedy,
                                           loopsSimulateTailRecursion, false);
      if (reach == null) {
        int alt = getAltThatFinishedDecisionEntryRule(previousD.configs);
        if (alt != ATN.INVALID_ALT_NUMBER) {
          return alt;
        }
        throw noViableAlt(input, outerContext, previous, startIndex);
      }
      DFAState D = new DFAState(reach);
      int predictedAlt = getUniqueAlt(reach);
      if (predictedAlt != ATN.INVALID_ALT_NUMBER) {
        D.isAcceptState = true;
        D.configs.uniqueAlt = predictedAlt;
        D.prediction = predictedAlt;
      } else {
        D.configs.conflictingAlts = getConflictingAlts(reach);
        if (D.configs.conflictingAlts != null) {
          if (greedy) {
            if (outerContext == ParserRuleContext.EMPTY ||
                !D.configs.dipsIntoOuterContext || SLL) {
              if (!D.configs.hasSemanticContext) {
                reportAmbiguity(dfa, D, startIndex, input.index(),
                                D.configs.conflictingAlts, D.configs);
              }
              D.isAcceptState = true;
              D.prediction = D.configs.conflictingAlts.getMinElement();
              if (debug)
                System.out.println("RESOLVED TO " + D.prediction + " for " + D);
              predictedAlt = D.prediction;
            } else {
              if (debug)
                System.out.println("RETRY with outerContext=" + outerContext);
              loopsSimulateTailRecursion = true;
              ATNConfigSet s0_closure =
                  computeStartState(dfa.atnStartState, outerContext, greedy,
                                    loopsSimulateTailRecursion, true);
              predictedAlt = execATNWithFullContext(
                  dfa, D, s0_closure, input, startIndex, outerContext,
                  D.configs.conflictingAlts.getMinElement(), greedy);
              D.isCtxSensitive = true;
              D.prediction = ATN.INVALID_ALT_NUMBER;
              addDFAEdge(dfa, previousD, t, D);
              return predictedAlt;
            }
          } else {
            int exitAlt = 2;
            D.isAcceptState = true;
            D.prediction = predictedAlt = exitAlt;
          }
        }
      }
      if (!greedy) {
        int exitAlt = 2;
        if (predictedAlt != ATN.INVALID_ALT_NUMBER &&
            configWithAltAtStopState(reach, 1)) {
          if (debug)
            System.out.println("nongreedy loop but unique alt " +
                               D.configs.uniqueAlt + " at " + reach);
          D.isAcceptState = true;
          D.prediction = predictedAlt = exitAlt;
        } else {
          if (configWithAltAtStopState(reach, exitAlt)) {
            if (debug)
              System.out.println("nongreedy at stop state for exit branch");
            D.isAcceptState = true;
            D.prediction = predictedAlt = exitAlt;
          }
        }
      }
      if (D.isAcceptState && D.configs.hasSemanticContext) {
        int nalts = decState.getNumberOfTransitions();
        IntervalSet altsToCollectPredsFrom =
            getConflictingAltsOrUniqueAlt(D.configs);
        SemanticContext[] altToPred =
            getPredsForAmbigAlts(altsToCollectPredsFrom, D.configs, nalts);
        if (altToPred != null) {
          D.predicates =
              getPredicatePredictions(altsToCollectPredsFrom, altToPred);
          D.prediction = ATN.INVALID_ALT_NUMBER;
        } else {
          D.prediction = altsToCollectPredsFrom.getMinElement();
        }
        if (D.predicates != null) {
          int stopIndex = input.index();
          input.seek(startIndex);
          IntervalSet alts =
              evalSemanticContext(D.predicates, outerContext, true);
          D.prediction = ATN.INVALID_ALT_NUMBER;
          addDFAEdge(dfa, previousD, t, D);
          switch (alts.size()) {
          case 0:
            throw noViableAlt(input, outerContext, D.configs, startIndex);
          case 1:
            return alts.getMinElement();
          default:
            reportAmbiguity(dfa, D, startIndex, stopIndex, alts, D.configs);
            return alts.getMinElement();
          }
        }
      }
      addDFAEdge(dfa, previousD, t, D);
      if (D.isAcceptState)
        return predictedAlt;
      previous = reach;
      previousD = D;
      input.consume();
      t = input.LA(1);
    }
  }
  public int execATNWithFullContext(DFA dfa, DFAState D,
                                    @NotNull ATNConfigSet s0,
                                    @NotNull TokenStream input, int startIndex,
                                    ParserRuleContext<?> outerContext,
                                    int SLL_min_alt, boolean greedy) {
    retry_with_context++;
    reportAttemptingFullContext(dfa, s0, startIndex, input.index());
    if (debug || debug_list_atn_decisions) {
      System.out.println("execATNWithFullContext " + s0 + ", greedy=" + greedy);
    }
    boolean fullCtx = true;
    ATNConfigSet reach = null;
    ATNConfigSet previous = s0;
    input.seek(startIndex);
    int t = input.LA(1);
    while (true) {
      reach = computeReachSet(previous, t, greedy, true, fullCtx);
      if (reach == null) {
        int alt = getAltThatFinishedDecisionEntryRule(previous);
        if (alt != ATN.INVALID_ALT_NUMBER) {
          return alt;
        }
        throw noViableAlt(input, outerContext, previous, startIndex);
      }
      reach.uniqueAlt = getUniqueAlt(reach);
      if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER)
        break;
      reach.conflictingAlts = getConflictingAlts(reach);
      if (reach.conflictingAlts != null)
        break;
      previous = reach;
      input.consume();
      t = input.LA(1);
    }
    if (reach.uniqueAlt != ATN.INVALID_ALT_NUMBER) {
      retry_with_context_indicates_no_conflict++;
      reportContextSensitivity(dfa, reach, startIndex, input.index());
      if (reach.uniqueAlt == SLL_min_alt) {
        retry_with_context_predicts_same_as_alt++;
      }
      return reach.uniqueAlt;
    }
    reportAmbiguity(dfa, D, startIndex, input.index(), reach.conflictingAlts,
                    reach);
    return reach.conflictingAlts.getMinElement();
  }
  protected ATNConfigSet computeReachSet(ATNConfigSet closure, int t,
                                         boolean greedy,
                                         boolean loopsSimulateTailRecursion,
                                         boolean fullCtx) {
    if (debug)
      System.out.println("in computeReachSet, starting closure: " + closure);
    ATNConfigSet reach = new ATNConfigSet(fullCtx);
    Set<ATNConfig> closureBusy = new HashSet<ATNConfig>();
    ATNConfigSet intermediate = new ATNConfigSet(fullCtx);
    for (ATNConfig c : closure) {
      if (debug)
        System.out.println("testing " + getTokenName(t) + " at " +
                           c.toString());
      int n = c.state.getNumberOfTransitions();
      for (int ti = 0; ti < n; ti++) {
        Transition trans = c.state.transition(ti);
        ATNState target = getReachableTarget(trans, t);
        if (target != null) {
          intermediate.add(new ATNConfig(c, target), mergeCache);
        }
      }
    }
    if (intermediate.size() == 1) {
      reach = new ATNConfigSet(intermediate);
    } else if (ParserATNSimulator.getUniqueAlt(intermediate) == 1) {
      reach = new ATNConfigSet(intermediate);
    } else {
      for (ATNConfig c : intermediate) {
        closure(c, reach, closureBusy, false, greedy,
                loopsSimulateTailRecursion, fullCtx);
      }
    }
    if (reach.size() == 0)
      return null;
    return reach;
  }
  @NotNull
  public ATNConfigSet
  computeStartState(@NotNull ATNState p, @Nullable RuleContext ctx,
                    boolean greedy, boolean loopsSimulateTailRecursion,
                    boolean fullCtx) {
    PredictionContext initialContext = PredictionContext.fromRuleContext(ctx);
    ATNConfigSet configs = new ATNConfigSet(fullCtx);
    for (int i = 0; i < p.getNumberOfTransitions(); i++) {
      ATNState target = p.transition(i).target;
      ATNConfig c = new ATNConfig(target, i + 1, initialContext);
      Set<ATNConfig> closureBusy = new HashSet<ATNConfig>();
      closure(c, configs, closureBusy, true, greedy, loopsSimulateTailRecursion,
              fullCtx);
    }
    return configs;
  }
  @Nullable
  public ATNState getReachableTarget(@NotNull Transition trans, int ttype) {
    switch (trans.getSerializationType()) {
    case Transition.ATOM:
      AtomTransition at = (AtomTransition)trans;
      if (at.label == ttype) {
        return at.target;
      }
      return null;
    case Transition.SET:
      SetTransition st = (SetTransition)trans;
      if (st.set.contains(ttype)) {
        return st.target;
      }
      return null;
    case Transition.NOT_SET:
      NotSetTransition nst = (NotSetTransition)trans;
      if (!nst.set.contains(ttype)) {
        return nst.target;
      }
      return null;
    case Transition.RANGE:
      RangeTransition rt = (RangeTransition)trans;
      if (ttype >= rt.from && ttype <= rt.to) {
        return rt.target;
      }
      return null;
    case Transition.WILDCARD:
      if (ttype != Token.EOF) {
        return trans.target;
      }
      return null;
    default:
      return null;
    }
  }
  public SemanticContext[] getPredsForAmbigAlts(@NotNull IntervalSet ambigAlts,
                                                @NotNull ATNConfigSet configs,
                                                int nalts) {
    SemanticContext[] altToPred = new SemanticContext[nalts + 1];
    for (ATNConfig c : configs) {
      if (ambigAlts.contains(c.alt)) {
        altToPred[c.alt] =
            SemanticContext.or(altToPred[c.alt], c.semanticContext);
      }
    }
    int nPredAlts = 0;
    for (int i = 1; i <= nalts; i++) {
      if (altToPred[i] == null) {
        altToPred[i] = SemanticContext.NONE;
      } else if (altToPred[i] != SemanticContext.NONE) {
        nPredAlts++;
      }
    }
    if (nPredAlts == 0)
      altToPred = null;
    if (debug)
      System.out.println("getPredsForAmbigAlts result " +
                         Arrays.toString(altToPred));
    return altToPred;
  }
  public List<DFAState.PredPrediction>
  getPredicatePredictions(IntervalSet ambigAlts,

                          SemanticContext[] altToPred) {
    List<DFAState.PredPrediction> pairs =
        new ArrayList<DFAState.PredPrediction>();
    boolean containsPredicate = false;
    for (int i = 1; i < altToPred.length; i++) {
      SemanticContext pred = altToPred[i];
      assert pred != null;
      if (ambigAlts != null && ambigAlts.contains(i)) {
        pairs.add(new DFAState.PredPrediction(pred, i));
      }
      if (pred != SemanticContext.NONE)
        containsPredicate = true;
    }
    if (!containsPredicate) {
      pairs = null;
    }
    return pairs;
  }
  public int getAltThatFinishedDecisionEntryRule(ATNConfigSet configs) {
    IntervalSet alts = new IntervalSet();
    for (ATNConfig c : configs) {
      if (c.reachesIntoOuterContext > 0)
        alts.add(c.alt);
    }
    if (alts.size() == 0)
      return ATN.INVALID_ALT_NUMBER;
    return alts.getMinElement();
  }
  public IntervalSet
  evalSemanticContext(List<DFAState.PredPrediction> predPredictions,
                      ParserRuleContext<?> outerContext, boolean complete) {
    IntervalSet predictions = new IntervalSet();
    for (DFAState.PredPrediction pair : predPredictions) {
      if (pair.pred == SemanticContext.NONE) {
        predictions.add(pair.alt);
        if (!complete) {
          break;
        }
        continue;
      }
      boolean predicateEvaluationResult = pair.pred.eval(parser, outerContext);
      if (debug || dfa_debug) {
        System.out.println("eval pred " + pair + "=" +
                           predicateEvaluationResult);
      }
      if (predicateEvaluationResult) {
        if (debug || dfa_debug)
          System.out.println("PREDICT " + pair.alt);
        predictions.add(pair.alt);
        if (!complete) {
          break;
        }
      }
    }
    return predictions;
  }
  protected void closure(@NotNull ATNConfig config,
                         @NotNull ATNConfigSet configs,
                         @NotNull Set<ATNConfig> closureBusy,
                         boolean collectPredicates, boolean greedy,
                         boolean loopsSimulateTailRecursion, boolean fullCtx) {
    final int initialDepth = 0;
    closureCheckingStopStateAndLoopRecursion(
        config, configs, closureBusy, collectPredicates, greedy,
        loopsSimulateTailRecursion, fullCtx, initialDepth);
  }
  protected void closureCheckingStopStateAndLoopRecursion(
      @NotNull ATNConfig config, @NotNull ATNConfigSet configs,

      @NotNull Set<ATNConfig> closureBusy, boolean collectPredicates,
      boolean greedy, boolean loopsSimulateTailRecursion, boolean fullCtx,
      int depth) {
    if (debug)
      System.out.println("closure(" + config.toString(parser, true) + ")");
    if (!closureBusy.add(config))
      return;
    if (config.state instanceof RuleStopState) {
      if (!greedy) {
        if (debug)
          System.out.println("NONGREEDY at stop state of " +
                             getRuleName(config.state.ruleIndex));
        configs.add(config, mergeCache);
        return;
      }
      if (config.context != null && !config.context.isEmpty()) {
<<<<<<< /root/work/antlr/antlr4/d3j/patched-021-0.java
        for (SingletonPredictionContext ctx : config.context) {
          if (ctx.invokingState ==
              PredictionContext.EMPTY_FULL_CTX_INVOKING_STATE) {
            if (debug)
              System.out.println("FALLING off rule " +
                                 getRuleName(config.state.ruleIndex));
            closure_(config, configs, closureBusy, collectPredicates, greedy,
                     loopsSimulateTailRecursion, fullCtx, depth);
            continue;
          }
          ATNState invokingState = atn.states.get(ctx.invokingState);
          RuleTransition rt = (RuleTransition)invokingState.transition(0);
          ATNState retState = rt.followState;
          PredictionContext newContext = ctx.parent;
          ATNConfig c = new ATNConfig(retState, config.alt, newContext,
                                      config.semanticContext);
          c.reachesIntoOuterContext = config.reachesIntoOuterContext;
          assert depth > Integer.MIN_VALUE;
          closureCheckingStopStateAndLoopRecursion(
              c, configs, closureBusy, collectPredicates, greedy,
              loopsSimulateTailRecursion, fullCtx, depth - 1);
        }
||||||| /root/work/antlr/antlr4/d3j/base-021.java
        RuleContext newContext = config.context.parent;
        ATNState invokingState = atn.states.get(config.context.invokingState);
        RuleTransition rt = (RuleTransition)invokingState.transition(0);
        ATNState retState = rt.followState;
        ATNConfig c = new ATNConfig(retState, config.alt, newContext,
                                    config.semanticContext);
        c.reachesIntoOuterContext = config.reachesIntoOuterContext;
        assert depth > Integer.MIN_VALUE;
        closure(c, configs, closureBusy, collectPredicates, greedy,
                loopsSimulateTailRecursion, depth - 1);
=======
        RuleContext newContext = config.context.parent;
        ATNState invokingState = atn.states.get(ctx.invokingState);
        RuleTransition rt = (RuleTransition)invokingState.transition(0);
        ATNState retState = rt.followState;
        ATNConfig c = new ATNConfig(retState, config.alt, newContext,
                                    config.semanticContext);
        c.reachesIntoOuterContext = config.reachesIntoOuterContext;
        assert depth > Integer.MIN_VALUE;
        closureCheckingStopStateAndLoopRecursion(
            c, configs, closureBusy, collectPredicates, greedy,
            loopsSimulateTailRecursion, fullCtx, depth - 1);
>>>>>>> /root/work/antlr/antlr4/d3j/patched-021-1.java
        return;
      } else {
        if (debug)
          System.out.println("FALLING off rule " +
                             getRuleName(config.state.ruleIndex));
      }
    } else if (loopsSimulateTailRecursion) {
      if (config.state.getClass() == StarLoopbackState.class ||
          config.state.getClass() == PlusLoopbackState.class) {
        config.context = new SingletonPredictionContext(
            config.context, config.state.stateNumber);
        if (debug)
          System.out.println("Loop back; push " + config.state.stateNumber +
                             ", stack=" + config.context);
      } else if (config.state.getClass() == LoopEndState.class) {
        if (debug)
<<<<<<< /root/work/antlr/antlr4/d3j/patched-021-0.java
          System.out.print("Loop end; pop, stack=" + config.context);
||||||| /root/work/antlr/antlr4/d3j/base-021.java
          System.out.println("Loop end; pop, stack=" + config.context);
        RuleContext p = config.context;
=======
          System.out.print("Loop end; pop, stack=" + config.context);
        RuleContext p = config.context;
>>>>>>> /root/work/antlr/antlr4/d3j/patched-021-1.java
        LoopEndState end = (LoopEndState)config.state;
<<<<<<< /root/work/antlr/antlr4/d3j/patched-021-0.java
        config.context = config.context.popAll(end.loopBackStateNumber,
                                               configs.fullCtx, mergeCache);
        if (debug)
          System.out.println(" becomes " + config.context);
||||||| /root/work/antlr/antlr4/d3j/base-021.java
        while (!p.isEmpty() && p.invokingState == end.loopBackStateNumber) {
          p = config.context = config.context.parent;
        }
=======
        int loopBackStateNumber = end.loopBackState.stateNumber;
        while (!p.isEmpty() && p.invokingState == loopBackStateNumber) {
          p = config.context = config.context.parent;
        }
>>>>>>> /root/work/antlr/antlr4/d3j/patched-021-1.java
      }
    }
    closure_(config, configs, closureBusy, collectPredicates, greedy,
             loopsSimulateTailRecursion, fullCtx, depth);
  }
  protected void closure_(@NotNull ATNConfig config,
                          @NotNull ATNConfigSet configs,
                          @NotNull Set<ATNConfig> closureBusy,
                          boolean collectPredicates, boolean greedy,
                          boolean loopsSimulateTailRecursion, boolean fullCtx,
                          int depth) {
    ATNState p = config.state;
    if (!p.onlyHasEpsilonTransitions()) {
      configs.add(config, mergeCache);
      if (config.semanticContext != null &&
          config.semanticContext != SemanticContext.NONE) {
        configs.hasSemanticContext = true;
      }
      if (config.reachesIntoOuterContext > 0) {
        configs.dipsIntoOuterContext = true;
      }
    }
    for (int i = 0; i < p.getNumberOfTransitions(); i++) {
      Transition t = p.transition(i);
      boolean continueCollecting =
          !(t instanceof ActionTransition) && collectPredicates;
      ATNConfig c =
          getEpsilonTarget(config, t, continueCollecting, depth == 0, fullCtx);
      if (c != null) {
        int newDepth = depth;
        if (config.state instanceof RuleStopState) {
          c.reachesIntoOuterContext++;
          configs.dipsIntoOuterContext = true;
          assert newDepth > Integer.MIN_VALUE;
          newDepth--;
          if (debug)
            System.out.println("dips into outer ctx: " + c);
        } else if (t instanceof RuleTransition) {
          if (newDepth >= 0) {
            newDepth++;
          }
        }
        closureCheckingStopStateAndLoopRecursion(
            c, configs, closureBusy, continueCollecting, greedy,
            loopsSimulateTailRecursion, fullCtx, newDepth);
      }
    }
  }
  @NotNull
  public String getRuleName(int index) {
    if (parser != null && index >= 0)
      return parser.getRuleNames()[index];
    return "<rule " + index + ">";
  }
  @Nullable
  public ATNConfig getEpsilonTarget(@NotNull ATNConfig config,
                                    @NotNull Transition t,
                                    boolean collectPredicates,
                                    boolean inContext, boolean fullCtx) {
    switch (t.getSerializationType()) {
    case Transition.RULE:
      return ruleTransition(config, t);
    case Transition.PREDICATE:
      return predTransition(config, (PredicateTransition)t, collectPredicates,
                            inContext, fullCtx);
    case Transition.ACTION:
      return actionTransition(config, (ActionTransition)t);
    case Transition.EPSILON:
      return new ATNConfig(config, t.target);
    default:
      return null;
    }
  }
  @NotNull
  public ATNConfig actionTransition(@NotNull ATNConfig config,
                                    @NotNull ActionTransition t) {
    if (debug)
      System.out.println("ACTION edge " + t.ruleIndex + ":" + t.actionIndex);
    return new ATNConfig(config, t.target);
  }
  @Nullable
  public ATNConfig predTransition(@NotNull ATNConfig config,
                                  @NotNull PredicateTransition pt,
                                  boolean collectPredicates, boolean inContext,
                                  boolean fullCtx) {
    if (debug) {
      System.out.println("PRED (collectPredicates=" + collectPredicates + ") " +
                         pt.ruleIndex + ":" + pt.predIndex +
                         ", ctx dependent=" + pt.isCtxDependent);
      if (parser != null) {
        System.out.println("context surrounding pred is " +
                           parser.getRuleInvocationStack());
      }
    }
    ATNConfig c = null;
    if (collectPredicates &&
        (!pt.isCtxDependent || (pt.isCtxDependent && inContext))) {
      if (fullCtx) {
        int currentPosition = _input.index();
        _input.seek(_startIndex);
        boolean predSucceeds = pt.getPredicate().eval(parser, _outerContext);
        _input.seek(currentPosition);
        if (predSucceeds) {
          c = new ATNConfig(config, pt.target);
        }
      } else {
        SemanticContext newSemCtx =
            SemanticContext.and(config.semanticContext, pt.getPredicate());
        c = new ATNConfig(config, pt.target, newSemCtx);
      }
    } else {
      c = new ATNConfig(config, pt.target);
    }
    if (debug)
      System.out.println("config from pred transition=" + c);
    return c;
  }
  @NotNull
  public ATNConfig ruleTransition(@NotNull ATNConfig config,
                                  @NotNull Transition t) {
    if (debug) {
      System.out.println("CALL rule " + getRuleName(t.target.ruleIndex) +
                         ", ctx=" + config.context);
    }
    PredictionContext newContext = new SingletonPredictionContext(
        config.context, config.state.stateNumber);
    return new ATNConfig(config, t.target, newContext);
  }
  @Nullable
  public IntervalSet getConflictingAlts(@NotNull ATNConfigSet configs) {
    if (debug)
      System.out.println("### check ambiguous  " + configs);
    MultiMap<Integer, ATNConfig> stateToConfigListMap =
        new MultiMap<Integer, ATNConfig>();
    Map<Integer, IntervalSet> stateToAltListMap =
        new HashMap<Integer, IntervalSet>();
    for (ATNConfig c : configs) {
      stateToConfigListMap.map(c.state.stateNumber, c);
      IntervalSet alts = stateToAltListMap.get(c.state.stateNumber);
      if (alts == null) {
        alts = new IntervalSet();
        stateToAltListMap.put(c.state.stateNumber, alts);
      }
      alts.add(c.alt);
    }
    int numPotentialConflicts = 0;
    IntervalSet altsToIgnore = new IntervalSet();
    for (int state : stateToConfigListMap.keySet()) {
      IntervalSet alts = stateToAltListMap.get(state);
      if (alts.size() == 1) {
        if (!atn.states.get(state).onlyHasEpsilonTransitions()) {
          List<ATNConfig> configsPerState = stateToConfigListMap.get(state);
          ATNConfig anyConfig = configsPerState.get(0);
          altsToIgnore.add(anyConfig.alt);
          if (debug)
            System.out.println("### one alt and all non-ep: " +
                               configsPerState);
        }
        stateToConfigListMap.put(state, null);
      } else {
        numPotentialConflicts++;
      }
    }
    if (debug)
      System.out.println("### altsToIgnore: " + altsToIgnore);
    if (debug)
      System.out.println("### stateToConfigListMap=" + stateToConfigListMap);
    if (numPotentialConflicts == 0) {
      return null;
    }
    IntervalSet ambigAlts = new IntervalSet();
    for (int state : stateToConfigListMap.keySet()) {
      List<ATNConfig> configsPerState = stateToConfigListMap.get(state);
      if (configsPerState == null)
        continue;
      IntervalSet alts = stateToAltListMap.get(state);
      if (!altsToIgnore.isNil() && alts.and(altsToIgnore).size() <= 1) {
        continue;
      }
      int size = configsPerState.size();
      for (int i = 0; i < size; i++) {
        ATNConfig c = configsPerState.get(i);
        for (int j = i + 1; j < size; j++) {
          ATNConfig d = configsPerState.get(j);
          if (c.alt != d.alt) {
            boolean conflicting = c.context.equals(d.context);
            if (conflicting) {
              if (debug) {
                System.out.println(
                    "we reach state " + c.state.stateNumber + " in rule " +
                    (parser != null ? getRuleName(c.state.ruleIndex) : "n/a") +
                    " alts " + c.alt + "," + d.alt + " from ctx " +
                    c.context.toString(parser) + " and " +
                    d.context.toString(parser));
              }
              ambigAlts.add(c.alt);
              ambigAlts.add(d.alt);
            }
          }
        }
      }
    }
    if (debug)
      System.out.println("### ambigAlts=" + ambigAlts);
    if (ambigAlts.isNil())
      return null;
    return ambigAlts;
  }
  protected IntervalSet getConflictingAltsOrUniqueAlt(ATNConfigSet configs) {
    IntervalSet conflictingAlts;
    if (configs.uniqueAlt != ATN.INVALID_ALT_NUMBER) {
      conflictingAlts = IntervalSet.of(configs.uniqueAlt);
    } else {
      conflictingAlts = configs.conflictingAlts;
    }
    return conflictingAlts;
  }
  protected int
  resolveNongreedyToExitBranch(@NotNull ATNConfigSet reach,
                               @NotNull IntervalSet conflictingAlts) {
    int exitAlt = 2;
    conflictingAlts.remove(exitAlt);
    if (debug)
      System.out.println("RESOLVED TO " + reach);
    return exitAlt;
  }
  @NotNull
  public String getTokenName(int t) {
    if (t == Token.EOF)
      return "EOF";
    if (parser != null && parser.getTokenNames() != null) {
      String[] tokensNames = parser.getTokenNames();
      if (t >= tokensNames.length) {
        System.err.println(
            t + " ttype out of range: " + Arrays.toString(tokensNames));
        System.err.println(
            ((CommonTokenStream)parser.getInputStream()).getTokens());
      } else {
        return tokensNames[t] + "<" + t + ">";
      }
    }
    return String.valueOf(t);
  }
  public String getLookaheadName(TokenStream input) {
    return getTokenName(input.LA(1));
  }
  public void dumpDeadEndConfigs(@NotNull NoViableAltException nvae) {
    System.err.println("dead end configs: ");
    for (ATNConfig c : nvae.deadEndConfigs) {
      String trans = "no edges";
      if (c.state.getNumberOfTransitions() > 0) {
        Transition t = c.state.transition(0);
        if (t instanceof AtomTransition) {
          AtomTransition at = (AtomTransition)t;
          trans = "Atom " + getTokenName(at.label);
        } else if (t instanceof SetTransition) {
          SetTransition st = (SetTransition)t;
          boolean not = st instanceof NotSetTransition;
          trans = (not ? "~" : "") + "Set " + st.set.toString();
        }
      }
      System.err.println(c.toString(parser, true) + ":" + trans);
    }
  }
  @NotNull
  public NoViableAltException
  noViableAlt(@NotNull TokenStream input,
              @NotNull ParserRuleContext<?> outerContext,
              @NotNull ATNConfigSet configs, int startIndex) {
    return new NoViableAltException(parser, input, input.get(startIndex),
                                    input.LT(1), configs, outerContext);
  }
  public static int getUniqueAlt(@NotNull Collection<ATNConfig> configs) {
    int alt = ATN.INVALID_ALT_NUMBER;
    for (ATNConfig c : configs) {
      if (alt == ATN.INVALID_ALT_NUMBER) {
        alt = c.alt;
      } else if (c.alt != alt) {
        return ATN.INVALID_ALT_NUMBER;
      }
    }
    return alt;
  }
  @Nullable
  public boolean
  configWithAltAtStopState(@NotNull Collection<ATNConfig> configs, int alt) {
    for (ATNConfig c : configs) {
      if (c.alt == alt) {
        if (c.state.getClass() == RuleStopState.class) {
          return true;
        }
      }
    }
    return false;
  }
  protected void addDFAEdge(@NotNull DFA dfa, @Nullable DFAState from, int t,
                            @Nullable DFAState to) {
    if (debug)
      System.out.println("EDGE " + from + " -> " + to + " upon " +
                         getTokenName(t));
    if (from == null || t < -1 || to == null)
      return;
    to = addDFAState(dfa, to);
    synchronized (dfa) {
      if (from.edges == null) {
        from.edges = new DFAState[atn.maxTokenType + 1 + 1];
      }
      from.edges[t + 1] = to;
    }
    if (debug)
      System.out.println("DFA=\n" + dfa.toString(parser != null
                                                     ? parser.getTokenNames()
                                                     : null));
  }
  protected DFAState addDFAState(@NotNull DFA dfa, @NotNull DFAState D) {
    synchronized (dfa) {
      DFAState existing = dfa.states.get(D);
      if (existing != null)
        return existing;
      D.stateNumber = dfa.states.size();
      synchronized (sharedContextCache) { D.configs.optimizeConfigs(this); }
      D.configs.setReadonly(true);
      dfa.states.put(D, D);
      if (debug)
        System.out.println("adding new DFA state: " + D);
      return D;
    }
  }
  public void reportAttemptingFullContext(DFA dfa, ATNConfigSet configs,
                                          int startIndex, int stopIndex) {
    if (debug || retry_debug) {
      Interval interval = Interval.of(startIndex, stopIndex);
      System.out.println(
          "reportAttemptingFullContext decision=" + dfa.decision + ":" +
          configs + ", input=" + parser.getTokenStream().getText(interval));
    }
    if (parser != null)
      parser.getErrorListenerDispatch().reportAttemptingFullContext(
          parser, dfa, startIndex, stopIndex, configs);
  }
  public void reportContextSensitivity(DFA dfa, ATNConfigSet configs,
                                       int startIndex, int stopIndex) {
    if (debug || retry_debug) {
      Interval interval = Interval.of(startIndex, stopIndex);
      System.out.println(
          "reportContextSensitivity decision=" + dfa.decision + ":" + configs +
          ", input=" + parser.getTokenStream().getText(interval));
    }
    if (parser != null)
      parser.getErrorListenerDispatch().reportContextSensitivity(
          parser, dfa, startIndex, stopIndex, configs);
  }
  public void reportAmbiguity(@NotNull DFA dfa, DFAState D, int startIndex,
                              int stopIndex, @NotNull IntervalSet ambigAlts,
                              @NotNull ATNConfigSet configs) {
    if (debug || retry_debug) {
      Interval interval = Interval.of(startIndex, stopIndex);
      System.out.println(
          "reportAmbiguity " + ambigAlts + ":" + configs +
          ", input=" + parser.getTokenStream().getText(interval));
    }
    if (parser != null)
      parser.getErrorListenerDispatch().reportAmbiguity(
          parser, dfa, startIndex, stopIndex, ambigAlts, configs);
  }
  public void setSLL(boolean SLL) { this.SLL = SLL; }
}