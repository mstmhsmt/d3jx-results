// generated by Diff/AST Java Unparser
package org.checkerframework.framework.type;
import com.sun.source.tree.AssignmentTree;
import com.sun.source.tree.LambdaExpressionTree;
import com.sun.source.tree.MemberReferenceTree;
import com.sun.source.tree.TypeCastTree;
import com.sun.tools.javac.code.Type;
import com.sun.tools.javac.processing.JavacProcessingEnvironment;
import com.sun.tools.javac.util.Context;
import org.checkerframework.common.basetype.BaseTypeChecker;
import org.checkerframework.dataflow.qual.SideEffectFree;
import org.checkerframework.framework.qual.FromByteCode;
import org.checkerframework.framework.qual.FromStubFile;
import org.checkerframework.framework.qual.InheritedAnnotation;
import org.checkerframework.framework.qual.PolymorphicQualifier;
import org.checkerframework.framework.qual.StubFiles;
import org.checkerframework.framework.qual.SubtypeOf;
import org.checkerframework.framework.qual.TypeQualifiers;
import org.checkerframework.framework.source.SourceChecker;
import org.checkerframework.framework.stub.StubParser;
import org.checkerframework.framework.stub.StubResource;
import org.checkerframework.framework.stub.StubUtil;
import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedArrayType;
import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedDeclaredType;
import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;
import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedPrimitiveType;
import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedTypeVariable;
import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedWildcardType;
import org.checkerframework.framework.type.visitor.AnnotatedTypeScanner;
import org.checkerframework.framework.util.AnnotatedTypes;
import org.checkerframework.framework.util.AnnotationFormatter;
import org.checkerframework.framework.util.CFContext;
import org.checkerframework.framework.util.DefaultAnnotationFormatter;
import org.checkerframework.framework.util.GraphQualifierHierarchy;
import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;
import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;
import org.checkerframework.framework.util.TreePathCacher;
import org.checkerframework.javacutil.AnnotationProvider;
import org.checkerframework.javacutil.AnnotationUtils;
import org.checkerframework.javacutil.ElementUtils;
import org.checkerframework.javacutil.ErrorReporter;
import org.checkerframework.javacutil.InternalUtils;
import org.checkerframework.javacutil.Pair;
import org.checkerframework.javacutil.TreeUtils;
import org.checkerframework.javacutil.trees.DetachedVarSymbol;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.lang.annotation.Annotation;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.element.AnnotationMirror;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Name;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.TypeParameterElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.PrimitiveType;
import javax.lang.model.type.TypeKind;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.type.TypeVariable;
import javax.lang.model.type.WildcardType;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import javax.tools.Diagnostic.Kind;
import com.sun.source.tree.AnnotationTree;
import com.sun.source.tree.ClassTree;
import com.sun.source.tree.CompilationUnitTree;
import com.sun.source.tree.ExpressionTree;
import com.sun.source.tree.IdentifierTree;
import com.sun.source.tree.MemberSelectTree;
import com.sun.source.tree.MethodInvocationTree;
import com.sun.source.tree.MethodTree;
import com.sun.source.tree.NewArrayTree;
import com.sun.source.tree.NewClassTree;
import com.sun.source.tree.ReturnTree;
import com.sun.source.tree.Tree;
import com.sun.source.tree.VariableTree;
import com.sun.source.util.TreePath;
import com.sun.source.util.Trees;
public
class AnnotatedTypeFactory implements AnnotationProvider
{
   protected final Trees trees;
   protected CompilationUnitTree root;
   protected final ProcessingEnvironment processingEnv;
   protected final Elements elements;
   protected final Types types;
   protected final VisitorState visitorState;
   protected QualifierHierarchy qualHierarchy;
   protected TypeHierarchy typeHierarchy;
   protected final AnnotatedTypeFormatter typeFormatter;
   private final AnnotationFormatter annotationFormatter;
   protected TypeVariableSubstitutor typeVarSubstitutor;
   private final Set<Class<? extends Annotation>> supportedQuals;
   private Map<Element,AnnotatedTypeMirror> indexTypes;
   private Map<String,Set<AnnotationMirror>> indexDeclAnnos;
   private final Map<Element,Set<AnnotationMirror>> cacheDeclAnnos;
   private final Set<AnnotationMirror> inheritedAnnotations =
     AnnotationUtils.createAnnotationSet();
   protected final BaseTypeChecker checker;
   private final Map<String,AnnotationMirror> aliases =
     new HashMap<String,AnnotationMirror>();
   private final Map<String,Pair<AnnotationMirror,Set<String>>> declAliases =
     new HashMap<>();
   private static int uidCounter = 0;
   public final int uid;
   private final AnnotationMirror fromByteCode;
   public
   AnnotatedTypeFactory(BaseTypeChecker checker) {
     uid = ++uidCounter;
     this.processingEnv = checker.getProcessingEnvironment();
     this.checker = checker;
     this.trees = Trees.instance(processingEnv);
     this.elements = processingEnv.getElementUtils();
     this.types = processingEnv.getTypeUtils();
     this.visitorState = new VisitorState();
     this.supportedQuals = createSupportedTypeQualifiers();
     this.fromByteCode =
     AnnotationUtils.fromClass(elements, FromByteCode.class);
     this.cacheDeclAnnos = new HashMap<Element,Set<AnnotationMirror>>();
     this.typeFormatter = createAnnotatedTypeFormatter();
     this.annotationFormatter = createAnnotationFormatter();
   }
   protected
   void postInit() {
     this.qualHierarchy = createQualifierHierarchy();
     if (qualHierarchy == null) {
       ErrorReporter.errorAbort("AnnotatedTypeFactory with null qualifier hierarchy not supported.");
     }
     this.typeHierarchy = createTypeHierarchy();
     this.typeVarSubstitutor = createTypeVariableSubstitutor();
     addAliasedDeclAnnotation(org.jmlspecs.annotation.Pure.class,
       org.checkerframework.dataflow.qual.Pure.class,
       AnnotationUtils.fromClass(elements,
         org.checkerframework.dataflow.qual.Pure.class));
     addInheritedAnnotation(AnnotationUtils.fromClass(elements,
                              org.checkerframework.dataflow.qual.Pure.class));
     addInheritedAnnotation(AnnotationUtils.fromClass(elements,
                              org.checkerframework.dataflow.qual.SideEffectFree.class));
     addInheritedAnnotation(AnnotationUtils.fromClass(elements,
                              org.checkerframework.dataflow.qual.Deterministic.class));
     addInheritedAnnotation(AnnotationUtils.fromClass(elements,
                              org.checkerframework.dataflow.qual.TerminatesExecution.class));
     addInheritedAnnotation(AnnotationUtils.fromClass(elements,
                              org.checkerframework.dataflow.qual.LockingFree.class));
     if (this.getClass().equals(AnnotatedTypeFactory.class)) {
       this.buildIndexTypes();
     }
   }
   public
   void setRoot(CompilationUnitTree root) {
     this.root = root;
     treePathCache.clear();
   }
   @SideEffectFree
   @Override
   public
   String toString() {
     return getClass().getSimpleName() + "#" + uid;
   }
   protected
   MultiGraphQualifierHierarchy.MultiGraphFactory createQualifierHierarchyFactory() {
     return new MultiGraphQualifierHierarchy.MultiGraphFactory(this);
   }
   public
   QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {
     return new GraphQualifierHierarchy(factory, null);
   }
   protected
   QualifierHierarchy createQualifierHierarchy() {
     Set<Class<? extends Annotation>> supportedTypeQualifiers =
       getSupportedTypeQualifiers();
     MultiGraphQualifierHierarchy.MultiGraphFactory factory =
       this.createQualifierHierarchyFactory();
     return createQualifierHierarchy(elements, supportedTypeQualifiers,
              factory);
   }
   protected
   static
   QualifierHierarchy createQualifierHierarchy(Elements elements, 
                                               Set<Class<? extends Annotation>> supportedTypeQualifiers,
                                               MultiGraphFactory factory) {
     for (Class<? extends Annotation> typeQualifier : supportedTypeQualifiers) {
       AnnotationMirror typeQualifierAnno =
         AnnotationUtils.fromClass(elements, typeQualifier);
       assert typeQualifierAnno != null:"Loading annotation \"" + typeQualifier + "\" failed!";
       factory.addQualifier(typeQualifierAnno);
       if (typeQualifier.getAnnotation(PolymorphicQualifier.class) != null) {
         if (typeQualifier.getAnnotation(SubtypeOf.class) != null) {
           ErrorReporter.errorAbort("AnnotatedTypeFactory: " + typeQualifier + " is polymorphic and specifies super qualifiers. " + "Remove the @org.checkerframework.framework.qual.SubtypeOf or @org.checkerframework.framework.qual.PolymorphicQualifier annotation from it.");
         }
         continue;
       }
       if (typeQualifier.getAnnotation(SubtypeOf.class) == null) {
         ErrorReporter.errorAbort("AnnotatedTypeFactory: " + typeQualifier + " does not specify its super qualifiers. " + "Add an @org.checkerframework.framework.qual.SubtypeOf annotation to it.");
       }
       Class<? extends Annotation>[] superQualifiers =
         typeQualifier.getAnnotation(SubtypeOf.class).value();
       for (Class<? extends Annotation> superQualifier : superQualifiers) {
         if (!supportedTypeQualifiers.contains(superQualifier)) {
           continue;
         }
         AnnotationMirror superAnno = null;
         superAnno = AnnotationUtils.fromClass(elements, superQualifier);
         factory.addSubtype(typeQualifierAnno, superAnno);
       }
     }
     QualifierHierarchy hierarchy = factory.build();
     if (!hierarchy.isValid()) {
       ErrorReporter.errorAbort("AnnotatedTypeFactory: invalid qualifier hierarchy: " + 
         hierarchy.getClass() + " " + hierarchy);
     }
     return hierarchy;
   }
   public
   final
   QualifierHierarchy getQualifierHierarchy() {
     return qualHierarchy;
   }
   protected
   TypeHierarchy createTypeHierarchy() {
     return new DefaultTypeHierarchy(checker, getQualifierHierarchy(),
              checker.hasOption("ignoreRawTypeArguments"),
              checker.hasOption("invariantArrays"));
   }
   public
   final
   TypeHierarchy getTypeHierarchy() {
     return typeHierarchy;
   }
   protected
   TypeVariableSubstitutor createTypeVariableSubstitutor() {
     return new TypeVariableSubstitutor();
   }
   public
   TypeVariableSubstitutor getTypeVarSubstitutor() {
     return typeVarSubstitutor;
   }
   protected
   Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {
     Class<?> classType;
     TypeQualifiers typeQualifiersAnnotation;
     classType = this.getClass();
     typeQualifiersAnnotation = classType.getAnnotation(TypeQualifiers.class);
     if (typeQualifiersAnnotation == null) {
       classType = checker.getClass();
       typeQualifiersAnnotation =
       classType.getAnnotation(TypeQualifiers.class);
     }
     if (typeQualifiersAnnotation != null) {
       Set<Class<? extends Annotation>> typeQualifiers =
         new HashSet<Class<? extends Annotation>>();
       for (Class<? extends Annotation> qualifier : typeQualifiersAnnotation.value()) {
         typeQualifiers.add(qualifier);
       }
       return Collections.unmodifiableSet(typeQualifiers);
     }
     return Collections.emptySet();
   }
   protected
   AnnotatedTypeFormatter createAnnotatedTypeFormatter() {
     return new DefaultAnnotatedTypeFormatter(checker.hasOption("printAllQualifiers"));
   }
   protected
   AnnotationFormatter createAnnotationFormatter() {
     return new DefaultAnnotationFormatter();
   }
   public
   AnnotationFormatter getAnnotationFormatter() {
     return annotationFormatter;
   }
   public
   final
   Set<Class<? extends Annotation>> getSupportedTypeQualifiers() {
     return supportedQuals;
   }
   protected static boolean SHOULD_CACHE = true;
   public boolean shouldCache = SHOULD_CACHE;
   protected static boolean SHOULD_READ_CACHE = true;
   public boolean shouldReadCache = SHOULD_READ_CACHE;
   private final static int CACHE_SIZE = 300;
   private final Map<Tree,AnnotatedTypeMirror> treeCache =
     createLRUCache(CACHE_SIZE);
   protected final Map<Tree,AnnotatedTypeMirror> fromTreeCache =
     createLRUCache(CACHE_SIZE);
   private final Map<Element,AnnotatedTypeMirror> elementCache =
     createLRUCache(CACHE_SIZE);
   private final Map<Element,Tree> elementToTreeCache =
     createLRUCache(CACHE_SIZE);
   private final TreePathCacher treePathCache = new TreePathCacher();
   public
   AnnotatedTypeMirror getAnnotatedType(Element elt) {
     if (elt == null) {
       ErrorReporter.errorAbort("AnnotatedTypeFactory.getAnnotatedType: null element");
       return null;
     }
     AnnotatedTypeMirror type = fromElement(elt);
     annotateInheritedFromClass(type);
     annotateImplicit(elt, type);
     return type;
   }
   @Override
   public
   AnnotationMirror getAnnotationMirror(Tree tree, 
                                        Class<? extends Annotation> target) {
     AnnotationMirror mirror = AnnotationUtils.fromClass(elements, target);
     if (isSupportedQualifier(mirror)) {
       AnnotatedTypeMirror atm = getAnnotatedType(tree);
       return atm.getAnnotation(target);
     }
     return null;
   }
   public
   AnnotatedTypeMirror getAnnotatedType(Tree tree) {
     if (tree == null) {
       ErrorReporter.errorAbort("AnnotatedTypeFactory.getAnnotatedType: null tree");
       return null;
     }
     if (treeCache.containsKey(tree) && shouldReadCache) {
       return treeCache.get(tree).deepCopy();
     }
     AnnotatedTypeMirror type;
     if (TreeUtils.isClassTree(tree)) {
       type = fromClass((ClassTree)tree);
     } else if (tree.getKind() == Tree.Kind.METHOD || tree.getKind() == Tree.Kind.VARIABLE) {
       type = fromMember(tree);
     } else if (TreeUtils.isExpressionTree(tree)) {
       tree = TreeUtils.skipParens((ExpressionTree)tree);
       type = fromExpression((ExpressionTree)tree);
     } else {
       ErrorReporter.errorAbort("AnnotatedTypeFactory.getAnnotatedType: query of annotated type for tree " + 
         tree.getKind());
       type = null;
     }
     annotateImplicit(tree, type);
     if (TreeUtils.isClassTree(tree) || tree.getKind() == Tree.Kind.METHOD) {
       if (shouldCache) {
         treeCache.put(tree, type.deepCopy());
       }
     } else {}
     if (tree.getKind() == Tree.Kind.CLASS) {
       postProcessClassTree((ClassTree)tree);
     }
     return type;
   }
   protected
   void postProcessClassTree(ClassTree tree) {
     TypesIntoElements.store(processingEnv, this, tree);
     DeclarationsIntoElements.store(processingEnv, this, tree);
   }
   public
   AnnotatedTypeMirror getAnnotatedTypeFromTypeTree(Tree tree) {
     if (tree == null) {
       ErrorReporter.errorAbort("AnnotatedTypeFactory.getAnnotatedTypeFromTypeTree: null tree");
       return null;
     }
     AnnotatedTypeMirror type = fromTypeTree(tree);
     annotateImplicit(tree, type);
     return type;
   }
   public
   AnnotatedTypeMirror fromElement(Element elt) {
     if (elementCache.containsKey(elt) && shouldReadCache) {
       return elementCache.get(elt).deepCopy();
     }
     if (elt.getKind() == ElementKind.PACKAGE)
       return toAnnotatedType(elt.asType(), false);
     AnnotatedTypeMirror type;
     Tree decl = declarationFromElement(elt);
     if (decl == null && indexTypes != null && indexTypes.containsKey(elt)) {
       type = indexTypes.get(elt).deepCopy();
     } else if (decl == null && (indexTypes == null || !indexTypes.containsKey(elt))) {
       type =
       toAnnotatedType(elt.asType(), ElementUtils.isTypeDeclaration(elt));
       ElementAnnotationApplier.apply(type, elt, this);
       if (elt instanceof ExecutableElement || elt instanceof VariableElement) {
         annotateInheritedFromClass(type);
       }
     } else if (decl instanceof ClassTree) {
       type = fromClass((ClassTree)decl);
     } else if (decl instanceof VariableTree) {
       type = fromMember(decl);
     } else if (decl instanceof MethodTree) {
       type = fromMember(decl);
     } else if (decl.getKind() == Tree.Kind.TYPE_PARAMETER) {
       type = fromTypeTree(decl);
     } else {
       ErrorReporter.errorAbort("AnnotatedTypeFactory.fromElement: cannot be here! decl: " + 
         decl.getKind() + " elt: " + elt, null);
       type = null;
     }
     if (shouldCache && indexTypes != null)
       elementCache.put(elt, type.deepCopy());
     return type;
   }
   private
   void addFromByteCode(Element elt) {
     if (indexDeclAnnos == null) {
       return;
     }
     if (elt.getKind() == ElementKind.CONSTRUCTOR || elt.getKind() == ElementKind.METHOD || 
     elt.getKind() == ElementKind.FIELD) {
       if (ElementUtils.isElementFromByteCode(elt)) {
         Set<AnnotationMirror> annos =
           indexDeclAnnos.get(ElementUtils.getVerboseName(elt));
         if (annos == null) {
           annos = AnnotationUtils.createAnnotationSet();
           indexDeclAnnos.put(ElementUtils.getVerboseName(elt), annos);
         }
         if (!annos.contains(AnnotationUtils.fromClass(elements,
                               FromStubFile.class))) {
           annos.add(fromByteCode);
         }
       }
     }
   }
   public
   AnnotatedDeclaredType fromClass(ClassTree tree) {
     return TypeFromTree.fromClassTree(this, tree);
   }
   public
   AnnotatedTypeMirror fromMember(Tree tree) {
     if (!(tree instanceof MethodTree || tree instanceof VariableTree)) {
       ErrorReporter.errorAbort("AnnotatedTypeFactory.fromMember: not a method or variable declaration: " + tree);
       return null;
     }
     if (fromTreeCache.containsKey(tree) && shouldReadCache) {
       return fromTreeCache.get(tree).deepCopy();
     }
     AnnotatedTypeMirror result = TypeFromTree.fromMember(this, tree);
     annotateInheritedFromClass(result);
     if (shouldCache)
       fromTreeCache.put(tree, result.deepCopy());
     return result;
   }
   public
   AnnotatedTypeMirror fromExpression(ExpressionTree tree) {
     if (fromTreeCache.containsKey(tree) && shouldReadCache)
       return fromTreeCache.get(tree).deepCopy();
     AnnotatedTypeMirror result = TypeFromTree.fromExpression(this, tree);
     annotateInheritedFromClass(result);
     if (shouldCache)
       fromTreeCache.put(tree, result.deepCopy());
     return result;
   }
   public
   AnnotatedTypeMirror fromTypeTree(Tree tree) {
     if (fromTreeCache.containsKey(tree) && shouldReadCache) {
       return fromTreeCache.get(tree).deepCopy();
     }
     AnnotatedTypeMirror result = TypeFromTree.fromTypeTree(this, tree);
     if (result.getKind() == TypeKind.DECLARED) {
       AnnotatedDeclaredType dt = (AnnotatedDeclaredType)result;
       if (dt.wasRaw()) {
         List<AnnotatedTypeMirror> typeArgs;
         Pair<Tree,AnnotatedTypeMirror> ctx =
           this.visitorState.getAssignmentContext();
         if (ctx != null) {
           if (ctx.second.getKind() == TypeKind.DECLARED && types.isSameType(
                                                              types.erasure(ctx.second.actualType),
                                                              types.erasure(dt.actualType))) {
             typeArgs =
             ((AnnotatedDeclaredType)ctx.second).getTypeArguments();
           } else {
             typeArgs = null;
           }
         } else {
           typeArgs = new ArrayList<AnnotatedTypeMirror>();
           AnnotatedDeclaredType declaration =
             fromElement((TypeElement)dt.getUnderlyingType().asElement());
           for (AnnotatedTypeMirror typeParam : declaration.getTypeArguments()) {
             AnnotatedWildcardType wct =
               getUninferredWildcardType((AnnotatedTypeVariable)typeParam);
             typeArgs.add(wct);
           }
         }
         dt.setTypeArguments(typeArgs);
       }
     }
     annotateInheritedFromClass(result);
     if (shouldCache)
       fromTreeCache.put(tree, result.deepCopy());
     return result;
   }
   public
   void annotateImplicit(Tree tree, AnnotatedTypeMirror type) {}
   protected
   void annotateImplicit(Element elt, AnnotatedTypeMirror type) {}
   protected
   void postDirectSuperTypes(AnnotatedTypeMirror type, 
                             List<? extends AnnotatedTypeMirror> supertypes) {
     Set<AnnotationMirror> annotations = type.getEffectiveAnnotations();
     for (AnnotatedTypeMirror supertype : supertypes) {
       if (!annotations.equals(supertype.getEffectiveAnnotations())) {
         supertype.clearAnnotations();
         supertype.addAnnotations(annotations);
       }
     }
   }
   public
   void postAsMemberOf(AnnotatedTypeMirror type, AnnotatedTypeMirror owner, 
                       Element element) {
     annotateImplicit(element, type);
   }
   public
   void postTypeVarSubstitution(AnnotatedTypeVariable varDecl, 
                                AnnotatedTypeVariable varUse, 
                                AnnotatedTypeMirror value) {
     if (!varUse.annotations.isEmpty() && !AnnotationUtils.areSame(varUse.annotations,
                                             varDecl.annotations)) {
       value.replaceAnnotations(varUse.annotations);
     }
   }
   public
   List<AnnotatedTypeParameterBounds> typeVariablesFromUse(AnnotatedDeclaredType type,
                                                           
                                                           TypeElement element) {
     AnnotatedDeclaredType generic = getAnnotatedType(element);
     List<AnnotatedTypeMirror> targs = type.getTypeArguments();
     List<AnnotatedTypeMirror> tvars = generic.getTypeArguments();
     assert targs.size() == tvars.size():"Mismatch in type argument size between " + type + " and " + generic;
     Map<TypeVariable,AnnotatedTypeMirror> mapping = new HashMap<>();
     for (int i = 0; i < targs.size(); ++i) {
       mapping.put(((AnnotatedTypeVariable)tvars.get(i)).getUnderlyingType(),
         targs.get(i));
     }
     List<AnnotatedTypeParameterBounds> res = new LinkedList<>();
     for (AnnotatedTypeMirror atm : tvars) {
       AnnotatedTypeVariable atv = (AnnotatedTypeVariable)atm;
       AnnotatedTypeMirror upper =
         typeVarSubstitutor.substitute(mapping, atv.getUpperBound());
       AnnotatedTypeMirror lower =
         typeVarSubstitutor.substitute(mapping, atv.getLowerBound());
       res.add(new AnnotatedTypeParameterBounds(upper, lower));
     }
     return res;
   }
   protected
   void annotateInheritedFromClass(AnnotatedTypeMirror type) {
     InheritedFromClassAnnotator.INSTANCE.visit(type, this);
   }
   protected
   void annotateInheritedFromClass(AnnotatedTypeMirror type, 
                                   Set<AnnotationMirror> fromClass) {
     type.addMissingAnnotations(fromClass);
   }
   protected
   static
   class InheritedFromClassAnnotator
     extends AnnotatedTypeScanner<Void,AnnotatedTypeFactory>
   {
      public static final InheritedFromClassAnnotator INSTANCE =
        new InheritedFromClassAnnotator();
      private
      InheritedFromClassAnnotator() {
        
      }
      @Override
      public
      Void visitExecutable(AnnotatedExecutableType type, 
                           AnnotatedTypeFactory p) {
        scan(type.getReturnType(), p);
        scanAndReduce(type.getParameterTypes(), p, null);
        scanAndReduce(type.getThrownTypes(), p, null);
        scanAndReduce(type.getTypeVariables(), p, null);
        return null;
      }
      @Override
      public
      Void visitDeclared(AnnotatedDeclaredType type, AnnotatedTypeFactory p) {
        Element classElt = type.getUnderlyingType().asElement();
        if (classElt != null) {
          AnnotatedTypeMirror classType = p.fromElement(classElt);
          assert classType != null:"Unexpected null type for class element: " + classElt;
          p.annotateInheritedFromClass(type, classType.getAnnotations());
        }
        return super.visitDeclared(type, p);
      }
      private final Map<TypeParameterElement,AnnotatedTypeVariable> visited =
        new HashMap<TypeParameterElement,AnnotatedTypeVariable>();
      @Override
      public
      Void visitTypeVariable(AnnotatedTypeVariable type, 
                             AnnotatedTypeFactory p) {
        TypeParameterElement tpelt =
          (TypeParameterElement)type.getUnderlyingType().asElement();
        if (!visited.containsKey(tpelt)) {
          visited.put(tpelt, type);
          if (type.getAnnotations().isEmpty() && type.getUpperBound().getAnnotations().isEmpty() && 
          tpelt.getEnclosingElement().getKind() != ElementKind.TYPE_PARAMETER) {
            ElementAnnotationApplier.apply(type, tpelt, p);
          }
          super.visitTypeVariable(type, p);
          visited.remove(tpelt);
        }
        return null;
      }
      @Override
      public
      void reset() {
        visited.clear();
        super.reset();
      }
   }
   protected
   AnnotatedDeclaredType getImplicitReceiverType(ExpressionTree tree) {
     assert (tree.getKind() == Tree.Kind.IDENTIFIER || tree.getKind() == Tree.Kind.MEMBER_SELECT || 
     tree.getKind() == Tree.Kind.METHOD_INVOCATION || tree.getKind() == Tree.Kind.NEW_CLASS):"Unexpected tree kind: " + 
     tree.getKind();
     Element element = InternalUtils.symbol(tree);
     assert element != null:"Unexpected null element for tree: " + tree;
     if (!ElementUtils.hasReceiver(element)) {
       return null;
     }
     ExpressionTree receiver = TreeUtils.getReceiverTree(tree);
     if (receiver == null) {
       if (isMostEnclosingThisDeref(tree)) {
         return getSelfType(tree);
       } else {
         TreePath path = getPath(tree);
         if (path == null) {
           return null;
         }
         TypeElement typeElt = ElementUtils.enclosingClass(element);
         if (typeElt == null) {
           ErrorReporter.errorAbort("AnnotatedTypeFactory.getImplicitReceiver: enclosingClass()==null for element: " + element);
         }
         return getEnclosingType(typeElt, tree);
       }
     }
     Element rcvelem = InternalUtils.symbol(receiver);
     assert rcvelem != null:"Unexpected null element for receiver: " + receiver;
     if (!ElementUtils.hasReceiver(rcvelem)) {
       return null;
     }
     if (receiver.getKind() == Tree.Kind.IDENTIFIER && ((IdentifierTree)receiver).getName().contentEquals("this")) {
       return this.getSelfType(tree);
     }
     TypeElement typeElt = ElementUtils.enclosingClass(rcvelem);
     if (typeElt == null) {
       ErrorReporter.errorAbort("AnnotatedTypeFactory.getImplicitReceiver: enclosingClass()==null for element: " + rcvelem);
     }
     AnnotatedDeclaredType type = getAnnotatedType(typeElt);
     AnnotatedDeclaredType methodReceiver = getCurrentMethodReceiver(tree);
     if (shouldTakeFromReceiver(methodReceiver)) {
       type.clearAnnotations();
       type.addAnnotations(methodReceiver.getAnnotations());
     }
     return type;
   }
   private
   boolean shouldTakeFromReceiver(AnnotatedDeclaredType methodReceiver) {
     return methodReceiver != null;
   }
   public
   final
   boolean isMostEnclosingThisDeref(ExpressionTree tree) {
     if (!isAnyEnclosingThisDeref(tree)) {
       return false;
     }
     Element element = TreeUtils.elementFromUse(tree);
     TypeElement typeElt = ElementUtils.enclosingClass(element);
     ClassTree enclosingClass = getCurrentClassTree(tree);
     if (enclosingClass != null && isSubtype(TreeUtils.elementFromDeclaration(enclosingClass),
                                     typeElt)) {
       return true;
     }
     return false;
   }
   public
   final
   boolean isAnyEnclosingThisDeref(ExpressionTree tree) {
     if (!TreeUtils.isUseOfElement(tree)) {
       return false;
     }
     ExpressionTree recv = TreeUtils.getReceiverTree(tree);
     if (recv == null) {
       Element element = TreeUtils.elementFromUse(tree);
       if (!ElementUtils.hasReceiver(element)) {
         return false;
       }
       tree = TreeUtils.skipParens(tree);
       if (tree.getKind() == Tree.Kind.IDENTIFIER) {
         Name n = ((IdentifierTree)tree).getName();
         if ("this".contentEquals(n) || "super".contentEquals(n)) {
           return false;
         }
       }
       return true;
     } else if (!TreeUtils.isUseOfElement(recv)) {
       return false;
     }
     Element element = TreeUtils.elementFromUse(recv);
     if (!ElementUtils.hasReceiver(element)) {
       return false;
     }
     return TreeUtils.isExplicitThisDereference(recv);
   }
   public
   AnnotatedDeclaredType getSelfType(Tree tree) {
     TreePath path = getPath(tree);
     ClassTree enclosingClass = TreeUtils.enclosingClass(path);
     if (enclosingClass == null) {
       enclosingClass = getCurrentClassTree(tree);
     }
     AnnotatedDeclaredType type = getAnnotatedType(enclosingClass);
     MethodTree enclosingMethod = TreeUtils.enclosingMethod(path);
     if (enclosingClass.getSimpleName().length() != 0 && enclosingMethod != null) {
       AnnotatedDeclaredType methodReceiver;
       if (TreeUtils.isConstructor(enclosingMethod)) {
         methodReceiver =
         (AnnotatedDeclaredType)getAnnotatedType(enclosingMethod).getReturnType();
       } else {
         methodReceiver = getAnnotatedType(enclosingMethod).getReceiverType();
       }
       if (shouldTakeFromReceiver(methodReceiver)) {
         type.clearAnnotations();
         type.addAnnotations(methodReceiver.getAnnotations());
       }
     }
     return type;
   }
   public
   AnnotatedDeclaredType getEnclosingType(TypeElement element, Tree tree) {
     Element enclosingElt = getMostInnerClassOrMethod(tree);
     while (enclosingElt != null) {
       if (enclosingElt instanceof ExecutableElement) {
         ExecutableElement method = (ExecutableElement)enclosingElt;
         if (method.asType() != null && isSubtype((TypeElement)method.getEnclosingElement(),
                                          element)) {
           if (ElementUtils.isStatic(method)) {} else if (method.getKind() == ElementKind.CONSTRUCTOR) {
             return (AnnotatedDeclaredType)getAnnotatedType(method).getReturnType();
           } else {
             return getAnnotatedType(method).getReceiverType();
           }
         }
       } else if (enclosingElt instanceof TypeElement) {
         if (isSubtype((TypeElement)enclosingElt, element)) {
           return (AnnotatedDeclaredType)getAnnotatedType(enclosingElt);
         }
       }
       enclosingElt = enclosingElt.getEnclosingElement();
     }
     return null;
   }
   private
   boolean isSubtype(TypeElement a1, TypeElement a2) {
     return (a1.equals(a2) || types.isSubtype(types.erasure(a1.asType()),
                                types.erasure(a2.asType())));
   }
   public
   final
   AnnotatedTypeMirror getReceiverType(ExpressionTree expression) {
     if (this.isAnyEnclosingThisDeref(expression)) {
       return getImplicitReceiverType(expression);
     }
     ExpressionTree receiver = TreeUtils.getReceiverTree(expression);
     if (receiver != null) {
       return getAnnotatedType(receiver);
     } else {
       return null;
     }
   }
   public
   Pair<AnnotatedExecutableType,List<AnnotatedTypeMirror>> methodFromUse(
   MethodInvocationTree tree) {
     ExecutableElement methodElt = TreeUtils.elementFromUse(tree);
     AnnotatedTypeMirror receiverType = getReceiverType(tree);
     return methodFromUse(tree, methodElt, receiverType);
   }
   public
   Pair<AnnotatedExecutableType,List<AnnotatedTypeMirror>> methodFromUse(
   ExpressionTree tree, ExecutableElement methodElt, 
   AnnotatedTypeMirror receiverType) {
     AnnotatedExecutableType methodType =
       AnnotatedTypes.asMemberOf(types, this, receiverType, methodElt);
     List<AnnotatedTypeMirror> typeargs =
       new LinkedList<AnnotatedTypeMirror>();
     Map<TypeVariable,AnnotatedTypeMirror> typeVarMapping =
       AnnotatedTypes.findTypeArguments(processingEnv, this, tree, methodElt,
         methodType);
     if (!typeVarMapping.isEmpty()) {
       for (AnnotatedTypeVariable tv : methodType.getTypeVariables()) {
         if (typeVarMapping.get(tv.getUnderlyingType()) == null) {
           ErrorReporter.errorAbort("AnnotatedTypeFactory.methodFromUse:" + "mismatch between declared method type variables and the inferred method type arguments! " + "Method type variables: " + 
             methodType.getTypeVariables() + "; " + "Inferred method type arguments: " + typeVarMapping);
         }
         typeargs.add(typeVarMapping.get(tv.getUnderlyingType()));
       }
       methodType =
       (AnnotatedExecutableType)typeVarSubstitutor.substitute(typeVarMapping,
                                  methodType);
     }
     return Pair.of(methodType, typeargs);
   }
   public
   Pair<AnnotatedExecutableType,List<AnnotatedTypeMirror>> constructorFromUse(
   NewClassTree tree) {
     ExecutableElement ctor = InternalUtils.constructor(tree);
     AnnotatedTypeMirror type = fromNewClass(tree);
     annotateImplicit(tree.getIdentifier(), type);
     AnnotatedExecutableType con =
       AnnotatedTypes.asMemberOf(types, this, type, ctor);
     if (tree.getArguments().size() == con.getParameterTypes().size() + 1 && 
     isSyntheticArgument(tree.getArguments().get(0))) {
       List<AnnotatedTypeMirror> actualParams =
         new ArrayList<AnnotatedTypeMirror>();
       actualParams.add(getAnnotatedType(tree.getArguments().get(0)));
       actualParams.addAll(con.getParameterTypes());
       con.setParameterTypes(actualParams);
     }
     List<AnnotatedTypeMirror> typeargs =
       new LinkedList<AnnotatedTypeMirror>();
     Map<TypeVariable,AnnotatedTypeMirror> typeVarMapping =
       AnnotatedTypes.findTypeArguments(processingEnv, this, tree, ctor, con);
     if (!typeVarMapping.isEmpty()) {
       for (AnnotatedTypeVariable tv : con.getTypeVariables()) {
         typeargs.add(typeVarMapping.get(tv.getUnderlyingType()));
       }
       con =
       (AnnotatedExecutableType)typeVarSubstitutor.substitute(typeVarMapping,
                                  con);
     }
     return Pair.of(con, typeargs);
   }
   public
   AnnotatedTypeMirror getMethodReturnType(MethodTree m) {
     AnnotatedExecutableType methodType = getAnnotatedType(m);
     AnnotatedTypeMirror ret = methodType.getReturnType();
     return ret;
   }
   public
   AnnotatedTypeMirror getMethodReturnType(MethodTree m, ReturnTree r) {
     AnnotatedExecutableType methodType = getAnnotatedType(m);
     AnnotatedTypeMirror ret = methodType.getReturnType();
     return ret;
   }
   private
   boolean isSyntheticArgument(Tree tree) {
     return tree.toString().contains("<*nullchk*>");
   }
   public
   AnnotatedDeclaredType fromNewClass(NewClassTree tree) {
     AnnotatedDeclaredType type;
     if (!TreeUtils.isDiamondTree(tree)) {
       type = (AnnotatedDeclaredType)fromTypeTree(tree.getIdentifier());
     } else {
       type =
       (AnnotatedDeclaredType)toAnnotatedType(InternalUtils.typeOf(tree),
                                false);
     }
     if (tree.getClassBody() != null) {
       List<? extends AnnotationTree> annos =
         tree.getClassBody().getModifiers().getAnnotations();
       type.replaceAnnotations(InternalUtils.annotationsFromTypeAnnotationTrees(annos));
     }
     if (TreeUtils.isDiamondTree(tree)) {
       if (((com.sun.tools.javac.code.Type)type.actualType).tsym.getTypeParameters().nonEmpty()) {
         Pair<Tree,AnnotatedTypeMirror> ctx =
           this.visitorState.getAssignmentContext();
         if (ctx != null) {
           AnnotatedTypeMirror ctxtype = ctx.second;
           fromNewClassContextHelper(type, ctxtype);
         }
       }
     }
     return type;
   }
   private
   void fromNewClassContextHelper(AnnotatedDeclaredType type, 
                                  AnnotatedTypeMirror ctxtype) {
     switch (ctxtype.getKind()) {
       case DECLARED:
         AnnotatedDeclaredType adctx = (AnnotatedDeclaredType)ctxtype;
         if (type.getTypeArguments().size() == adctx.getTypeArguments().size()) {
           List<AnnotatedTypeMirror> oldArgs = type.getTypeArguments();
           List<AnnotatedTypeMirror> newArgs = adctx.getTypeArguments();
           for (int i = 0; i < type.getTypeArguments().size(); ++i) {
             if (!types.isSameType(oldArgs.get(i).actualType,
                    newArgs.get(i).actualType)) {
               return;
             }
           }
           type.setTypeArguments(newArgs);
         } else {}
         break;
       case ARRAY:
         break;
       case TYPEVAR:
         break;
       default:
         ErrorReporter.errorAbort("AnnotatedTypeFactory.fromNewClassContextHelper: unexpected context: " + ctxtype + " (" + 
           ctxtype.getKind() + ")");
     }
   }
   public
   AnnotatedDeclaredType getBoxedType(AnnotatedPrimitiveType type) {
     TypeElement typeElt = types.boxedClass(type.getUnderlyingType());
     AnnotatedDeclaredType dt = fromElement(typeElt);
     dt.addAnnotations(type.getAnnotations());
     return dt;
   }
   public
   AnnotatedPrimitiveType getUnboxedType(AnnotatedDeclaredType type)
     throws IllegalArgumentException {
     PrimitiveType primitiveType =
       types.unboxedType(type.getUnderlyingType());
     AnnotatedPrimitiveType pt =
       (AnnotatedPrimitiveType)AnnotatedTypeMirror.createType(primitiveType,
                                 this, false);
     pt.addAnnotations(type.getAnnotations());
     return pt;
   }
   public
   VisitorState getVisitorState() {
     return this.visitorState;
   }
   public
   final
   AnnotatedDeclaredType getAnnotatedType(ClassTree tree) {
     return (AnnotatedDeclaredType)getAnnotatedType((Tree)tree);
   }
   public
   final
   AnnotatedDeclaredType getAnnotatedType(NewClassTree tree) {
     return (AnnotatedDeclaredType)getAnnotatedType((Tree)tree);
   }
   public
   final
   AnnotatedArrayType getAnnotatedType(NewArrayTree tree) {
     return (AnnotatedArrayType)getAnnotatedType((Tree)tree);
   }
   public
   final
   AnnotatedExecutableType getAnnotatedType(MethodTree tree) {
     return (AnnotatedExecutableType)getAnnotatedType((Tree)tree);
   }
   public
   final
   AnnotatedDeclaredType getAnnotatedType(TypeElement elt) {
     return (AnnotatedDeclaredType)getAnnotatedType((Element)elt);
   }
   public
   final
   AnnotatedExecutableType getAnnotatedType(ExecutableElement elt) {
     return (AnnotatedExecutableType)getAnnotatedType((Element)elt);
   }
   public
   final
   AnnotatedDeclaredType fromElement(TypeElement elt) {
     return (AnnotatedDeclaredType)fromElement((Element)elt);
   }
   public
   final
   AnnotatedExecutableType fromElement(ExecutableElement elt) {
     return (AnnotatedExecutableType)fromElement((Element)elt);
   }
   public
   boolean isSupportedQualifier(AnnotationMirror a) {
     if (a == null)
       return false;
     return AnnotationUtils.containsSameIgnoringValues(this.getQualifierHierarchy().getTypeQualifiers(),
              a);
   }
   protected
   void addAliasedAnnotation(Class<?> alias, AnnotationMirror type) {
     aliases.put(alias.getCanonicalName(), type);
   }
   public
   AnnotationMirror aliasedAnnotation(AnnotationMirror a) {
     TypeElement elem = (TypeElement)a.getAnnotationType().asElement();
     String qualName = elem.getQualifiedName().toString();
     return aliases.get(qualName);
   }
   protected
   void addAliasedDeclAnnotation(Class<? extends Annotation> alias, 
                                 Class<? extends Annotation> annotation, 
                                 AnnotationMirror annotationToUse) {
     String aliasName = alias.getCanonicalName();
     String annotationName = annotation.getCanonicalName();
     Set<String> set = new HashSet<>();
     if (declAliases.containsKey(annotationName)) {
       set.addAll(declAliases.get(annotationName).second);
     }
     set.add(aliasName.intern());
     declAliases.put(annotationName, Pair.of(annotationToUse, set));
   }
   protected
   void addInheritedAnnotation(AnnotationMirror annotation) {
     inheritedAnnotations.add(annotation);
   }
   public
   final
   AnnotatedTypeMirror toAnnotatedType(TypeMirror t, boolean declaration) {
     return AnnotatedTypeMirror.createType(t, this, declaration);
   }
   public
   AnnotatedTypeMirror type(Tree node) {
     boolean isDeclaration = TreeUtils.isTypeDeclaration(node);
     if (InternalUtils.typeOf(node) != null) {
       AnnotatedTypeMirror result =
         toAnnotatedType(InternalUtils.typeOf(node), isDeclaration);
       return result;
     }
     TreePath path = this.getPath(node);
     assert path != null:"No path or type in tree: " + node;
     TypeMirror t = trees.getTypeMirror(path);
     assert validType(t):"Invalid type " + t + " for node " + t;
     return toAnnotatedType(t, isDeclaration);
   }
   protected
   final
   Tree declarationFromElement(Element elt) {
     if (root == null)
       return null;
     if (elementToTreeCache.containsKey(elt) && shouldReadCache) {
       return elementToTreeCache.get(elt);
     }
     if (elt instanceof DetachedVarSymbol) {
       return ((DetachedVarSymbol)elt).getDeclaration();
     }
     Tree fromElt;
     switch (elt.getKind()) {
       case CLASS:
       case ENUM:
       case INTERFACE:
       case ANNOTATION_TYPE:
       case FIELD:
       case ENUM_CONSTANT:
       case METHOD:
       case CONSTRUCTOR:
         fromElt = trees.getTree(elt);
         break;
       default:
         fromElt =
         com.sun.tools.javac.tree.TreeInfo.declarationFor((com.sun.tools.javac.code.Symbol)elt,
           (com.sun.tools.javac.tree.JCTree)root);
         break;
     }
     if (shouldCache)
       elementToTreeCache.put(elt, fromElt);
     return fromElt;
   }
   protected
   final
   ClassTree getCurrentClassTree(Tree tree) {
     if (visitorState.getClassTree() != null) {
       return visitorState.getClassTree();
     }
     return TreeUtils.enclosingClass(getPath(tree));
   }
   protected
   final
   AnnotatedDeclaredType getCurrentClassType(Tree tree) {
     return getAnnotatedType(getCurrentClassTree(tree));
   }
   protected
   final
   AnnotatedDeclaredType getCurrentMethodReceiver(Tree tree) {
     AnnotatedDeclaredType res = visitorState.getMethodReceiver();
     if (res == null) {
       TreePath path = getPath(tree);
       if (path != null) {
         MethodTree enclosingMethod = TreeUtils.enclosingMethod(path);
         ClassTree enclosingClass = TreeUtils.enclosingClass(path);
         boolean found = false;
         for (Tree member : enclosingClass.getMembers()) {
           if (member.getKind() == Tree.Kind.METHOD) {
             if (member == enclosingMethod) {
               found = true;
             }
           }
         }
         if (found && enclosingMethod != null) {
           AnnotatedExecutableType method =
             getAnnotatedType(enclosingMethod);
           res = method.getReceiverType();
         } else {
           res = this.getAnnotatedType(enclosingClass);
         }
       }
     }
     return res;
   }
   protected
   final
   boolean isWithinConstructor(Tree tree) {
     if (visitorState.getClassType() != null)
       return visitorState.getMethodTree() != null && TreeUtils.isConstructor(
                                                        visitorState.getMethodTree());
     MethodTree enclosingMethod = TreeUtils.enclosingMethod(getPath(tree));
     return enclosingMethod != null && TreeUtils.isConstructor(enclosingMethod);
   }
   private
   final
   Element getMostInnerClassOrMethod(Tree tree) {
     if (visitorState.getMethodTree() != null)
       return TreeUtils.elementFromDeclaration(visitorState.getMethodTree());
     if (visitorState.getClassTree() != null)
       return TreeUtils.elementFromDeclaration(visitorState.getClassTree());
     TreePath path = getPath(tree);
     if (path == null) {
       ErrorReporter.errorAbort(String.format("AnnotatedTypeFactory.getMostInnerClassOrMethod: getPath(tree)=>null%n  TreePath.getPath(root, tree)=>%s\n  for tree (%s) = %s%n  root=%s",
                                  TreePath.getPath(root, tree),
                                  tree.getClass(), tree, root));
       return null;
     }
     for (Tree pathTree : path) {
       if (pathTree instanceof MethodTree)
         return TreeUtils.elementFromDeclaration((MethodTree)pathTree); else if (pathTree instanceof ClassTree)
         return TreeUtils.elementFromDeclaration((ClassTree)pathTree);
     }
     ErrorReporter.errorAbort("AnnotatedTypeFactory.getMostInnerClassOrMethod: cannot be here!");
     return null;
   }
   private final Map<Tree,Element> pathHack = new HashMap<>();
   public
   final
   void setPathHack(Tree node, Element enclosing) {
     pathHack.put(node, enclosing);
   }
   public
   final
   TreePath getPath(Tree node) {
     assert root != null:"AnnotatedTypeFactory.getPath: root needs to be set when used on trees; factory: " + 
     this.getClass();
     if (node == null)
       return null;
     if (treePathCache.isCached(node)) {
       return treePathCache.getPath(root, node);
     }
     ;
     TreePath currentPath = visitorState.getPath();
     if (currentPath == null)
       return TreePath.getPath(root, node);
     if (currentPath.getLeaf() == node) {
       return currentPath;
     }
     if (currentPath.getParentPath() != null)
       currentPath = currentPath.getParentPath();
     if (currentPath.getLeaf() == node) {
       return currentPath;
     }
     if (currentPath.getParentPath() != null)
       currentPath = currentPath.getParentPath();
     if (currentPath.getLeaf() == node) {
       return currentPath;
     }
     final TreePath pathWithinSubtree = TreePath.getPath(currentPath, node);
     if (pathWithinSubtree != null) {
       return pathWithinSubtree;
     }
     TreePath current = currentPath;
     while (current != null) {
       if (current.getLeaf() == node)
         return current;
       current = current.getParentPath();
     }
     return treePathCache.getPath(root, node);
   }
   public
   final
   Element getEnclosingMethod(Tree node) {
     return pathHack.get(node);
   }
   static
   final
   boolean validAnnotatedType(AnnotatedTypeMirror type) {
     if (type == null)
       return false;
     if (type.getUnderlyingType() == null)
       return true;
     return validType(type.getUnderlyingType());
   }
   private
   static
   final
   boolean validType(TypeMirror type) {
     if (type == null)
       return false;
     switch (type.getKind()) {
       case ERROR:
       case OTHER:
       case PACKAGE:
         return false;
       default:
         return true;
     }
   }
   public
   static
   <K,V> Map<K,V> createLRUCache(final int size) {
     return new LinkedHashMap<K,V>()
            {
               private static final long serialVersionUID =
                 5261489276168775084L;
               @Override
               protected
               boolean removeEldestEntry(Map.Entry<K,V> entry) {
                 return size() > size;
               }
            };
   }
   protected
   void buildIndexTypes() {
     if (this.indexTypes != null || this.indexDeclAnnos != null) {
       ErrorReporter.errorAbort("AnnotatedTypeFactory.buildIndexTypes called more than once");
     }
     Map<Element,AnnotatedTypeMirror> indexTypes =
       new HashMap<Element,AnnotatedTypeMirror>();
     Map<String,Set<AnnotationMirror>> indexDeclAnnos =
       new HashMap<String,Set<AnnotationMirror>>();
     if (!checker.hasOption("ignorejdkastub")) {
       InputStream in = null;
       if (checker != null)
         in = checker.getClass().getResourceAsStream("jdk.astub");
       if (in != null) {
         StubParser stubParser =
           new StubParser("jdk.astub", in, this, processingEnv);
         stubParser.parse(indexTypes, indexDeclAnnos);
       }
     }
     InputStream input =
       BaseTypeChecker.class.getResourceAsStream("flow.astub");
     if (input != null) {
       StubParser stubParser =
         new StubParser("flow.astub", input, this, processingEnv);
       stubParser.parse(indexTypes, indexDeclAnnos);
     }
     String allstubFiles = "";
     String stubFiles;
     stubFiles = checker.getOption("stubs");
     if (stubFiles != null)
       allstubFiles += File.pathSeparator + stubFiles;
     stubFiles = System.getProperty("stubs");
     if (stubFiles != null)
       allstubFiles += File.pathSeparator + stubFiles;
     stubFiles = System.getenv("stubs");
     if (stubFiles != null)
       allstubFiles += File.pathSeparator + stubFiles;
     {
       StubFiles sfanno = checker.getClass().getAnnotation(StubFiles.class);
       if (sfanno != null) {
         String[] sfarr = sfanno.value();
         stubFiles = "";
         for (String sf : sfarr) {
           stubFiles += File.pathSeparator + sf;
         }
         allstubFiles += stubFiles;
       }
     }
     if (allstubFiles.isEmpty()) {
       this.indexTypes = indexTypes;
       this.indexDeclAnnos = indexDeclAnnos;
       return;
     }
     String[] stubArray = allstubFiles.split(File.pathSeparator);
     for (String stubPath : stubArray) {
       if (stubPath == null || stubPath.isEmpty())
         continue;
       String base = System.getProperty("test.src");
       String stubPathFull = stubPath;
       if (base != null)
         stubPathFull = base + "/" + stubPath;
       List<StubResource> stubs = StubUtil.allStubFiles(stubPathFull);
       if (stubs.size() == 0) {
         InputStream in = null;
         if (checker != null)
           in = checker.getClass().getResourceAsStream(stubPath);
         if (in != null) {
           StubParser stubParser =
             new StubParser(stubPath, in, this, processingEnv);
           stubParser.parse(indexTypes, indexDeclAnnos);
           continue;
         }
         checker.message(Kind.NOTE,
           "Did not find stub file or files within directory: " + stubPath);
       }
       for (StubResource resource : stubs) {
         InputStream stubStream;
         try {
           stubStream = resource.getInputStream();
         } catch (IOException e) {
           checker.message(Kind.NOTE,
             "Could not read stub resource: " + resource.getDescription());
           continue;
         } 
         StubParser stubParser =
           new StubParser(resource.getDescription(), stubStream, this,
             processingEnv);
         stubParser.parse(indexTypes, indexDeclAnnos);
       }
     }
     this.indexTypes = indexTypes;
     this.indexDeclAnnos = indexDeclAnnos;
     return;
   }
   @Override
   public
   AnnotationMirror getDeclAnnotation(Element elt, 
                                      Class<? extends Annotation> anno) {
     String annoName = anno.getCanonicalName().intern();
     return getDeclAnnotation(elt, annoName, true);
   }
   public
   boolean isFromStubFile(Element element) {
     return this.getDeclAnnotation(element, FromStubFile.class) != null;
   }
   public
   boolean isFromByteCode(Element element) {
     if (isFromStubFile(element))
       return false;
     return this.getDeclAnnotation(element, FromByteCode.class) != null;
   }
   private
   AnnotationMirror getDeclAnnotation(Element elt, String annoName, 
                                      boolean checkAliases) {
     Set<AnnotationMirror> declAnnos = getDeclAnnotations(elt);
     for (AnnotationMirror am : declAnnos) {
       if (AnnotationUtils.areSameByName(am, annoName)) {
         return am;
       }
     }
     if (checkAliases) {
       Pair<AnnotationMirror,Set<String>> aliases =
         declAliases.get(annoName);
       if (aliases != null) {
         for (String alias : aliases.second) {
           AnnotationMirror declAnnotation =
             getDeclAnnotation(elt, alias, false);
           if (declAnnotation != null) {
             return aliases.first;
           }
         }
       }
     }
     return null;
   }
   public
   Set<AnnotationMirror> getDeclAnnotations(Element elt) {
     if (cacheDeclAnnos.containsKey(elt)) {
       return cacheDeclAnnos.get(elt);
     }
     Set<AnnotationMirror> results = AnnotationUtils.createAnnotationSet();
     results.addAll(elt.getAnnotationMirrors());
     if (indexDeclAnnos != null) {
       addFromByteCode(elt);
       String eltName = ElementUtils.getVerboseName(elt);
       Set<AnnotationMirror> stubAnnos = indexDeclAnnos.get(eltName);
       if (stubAnnos != null) {
         results.addAll(stubAnnos);
       }
       inheritOverriddenDeclAnnos(elt, results);
       cacheDeclAnnos.put(elt, results);
     }
     return results;
   }
   private
   void inheritOverriddenDeclAnnos(Element elt, Set<AnnotationMirror> results) {
     Map<AnnotatedDeclaredType,ExecutableElement> overriddenMethods = null;
     if (elt instanceof ExecutableElement) {
       overriddenMethods =
       AnnotatedTypes.overriddenMethods(elements, this,
         (ExecutableElement)elt);
     }
     if (overriddenMethods != null) {
       for (Map.Entry<AnnotatedDeclaredType,ExecutableElement> pair : 
       overriddenMethods.entrySet()) {
         AnnotatedDeclaredType overriddenType = pair.getKey();
         AnnotatedExecutableType overriddenMethod =
           AnnotatedTypes.asMemberOf(types, this, overriddenType,
             pair.getValue());
         ExecutableElement superElt = overriddenMethod.getElement();
         Set<AnnotationMirror> superAnnos = getDeclAnnotations(superElt);
         for (AnnotationMirror annotation : superAnnos) {
           List<? extends AnnotationMirror> annotationsOnAnnotation;
           try {
             annotationsOnAnnotation =
             annotation.getAnnotationType().asElement().getAnnotationMirrors();
           } catch (com.sun.tools.javac.code.Symbol.CompletionFailure cf) {
             checker.message(Kind.WARNING,
               annotation.getAnnotationType().asElement(),
               "annotation.not.completed", ElementUtils.getVerboseName(elt),
               annotation);
             continue;
           } 
           if (AnnotationUtils.containsSameByClass(annotationsOnAnnotation,
                 InheritedAnnotation.class) || AnnotationUtils.containsSameIgnoringValues(inheritedAnnotations,
                                                 annotation)) {
             results.add(annotation);
           }
         }
       }
     }
   }
   public
   List<Pair<AnnotationMirror,AnnotationMirror>> getDeclAnnotationWithMetaAnnotation(
   Element element, Class<? extends Annotation> metaAnnotation) {
     List<Pair<AnnotationMirror,AnnotationMirror>> result =
       new ArrayList<>();
     Set<AnnotationMirror> annotationMirrors = getDeclAnnotations(element);
     for (AnnotationMirror annotation : annotationMirrors) {
       List<? extends AnnotationMirror> annotationsOnAnnotation;
       try {
         annotationsOnAnnotation =
         annotation.getAnnotationType().asElement().getAnnotationMirrors();
       } catch (com.sun.tools.javac.code.Symbol.CompletionFailure cf) {
         checker.message(Kind.WARNING,
           annotation.getAnnotationType().asElement(),
           "annotation.not.completed", ElementUtils.getVerboseName(element),
           annotation);
         continue;
       } 
       for (AnnotationMirror a : annotationsOnAnnotation) {
         if (AnnotationUtils.areSameByClass(a, metaAnnotation)) {
           result.add(Pair.of(annotation, a));
         }
       }
     }
     return result;
   }
   public
   List<Pair<AnnotationMirror,AnnotationMirror>> getAnnotationWithMetaAnnotation(
   Element element, Class<? extends Annotation> metaAnnotation) {
     List<Pair<AnnotationMirror,AnnotationMirror>> result =
       new ArrayList<>();
     Set<AnnotationMirror> annotationMirrors =
       AnnotationUtils.createAnnotationSet();
     annotationMirrors.addAll(getAnnotatedType(element).getAnnotations());
     annotationMirrors.addAll(getDeclAnnotations(element));
     for (AnnotationMirror annotation : annotationMirrors) {
       List<? extends AnnotationMirror> annotationsOnAnnotation =
         annotation.getAnnotationType().asElement().getAnnotationMirrors();
       for (AnnotationMirror a : annotationsOnAnnotation) {
         if (AnnotationUtils.areSameByClass(a, metaAnnotation)) {
           result.add(Pair.of(annotation, a));
         }
       }
     }
     return result;
   }
   public
   AnnotatedWildcardType getUninferredWildcardType(AnnotatedTypeVariable typeVar) {
     final boolean intersectionType;
     final TypeMirror boundType;
     if (typeVar.getUpperBound().getKind() == TypeKind.INTERSECTION) {
       boundType =
       typeVar.getUpperBound().directSuperTypes().get(0).getUnderlyingType();
       intersectionType = true;
     } else {
       boundType = typeVar.getUnderlyingType().getUpperBound();
       intersectionType = false;
     }
     WildcardType wc = types.getWildcardType(boundType, null);
     AnnotatedWildcardType wctype =
       (AnnotatedWildcardType)AnnotatedTypeMirror.createType(wc, this, false);
     if (!intersectionType) {
       wctype.setExtendsBound(typeVar.getUpperBound().deepCopy());
     } else {
       wctype.getExtendsBound().addAnnotations(typeVar.getUpperBound().getAnnotations());
     }
     wctype.setSuperBound(typeVar.getLowerBound().deepCopy());
     wctype.addAnnotations(typeVar.getAnnotations());
     wctype.setTypeArgHack();
     return wctype;
   }
   public
   Pair<AnnotatedDeclaredType,AnnotatedExecutableType> getFnInterfaceFromTree(
   MemberReferenceTree tree) {
     return getFnInterfaceFromTree((Tree)tree);
   }
   public
   Pair<AnnotatedDeclaredType,AnnotatedExecutableType> getFnInterfaceFromTree(
   LambdaExpressionTree tree) {
     return getFnInterfaceFromTree((Tree)tree);
   }
   private
   Pair<AnnotatedDeclaredType,AnnotatedExecutableType> getFnInterfaceFromTree(
   Tree tree) {
     Context ctx =
       ((JavacProcessingEnvironment)getProcessingEnv()).getContext();
     com.sun.tools.javac.code.Types javacTypes =
       com.sun.tools.javac.code.Types.instance(ctx);
     AnnotatedDeclaredType functionalInterfaceType =
       getFunctionalInterfaceType(tree, javacTypes);
     makeGroundTargetType(functionalInterfaceType);
     Element fnElement =
       javacTypes.findDescriptorSymbol(((Type)functionalInterfaceType.getUnderlyingType()).asElement());
     AnnotatedExecutableType methodExe =
       (AnnotatedExecutableType)AnnotatedTypes.asMemberOf(types, this,
                                  functionalInterfaceType, fnElement);
     return Pair.of(functionalInterfaceType, methodExe);
   }
   private
   AnnotatedDeclaredType getFunctionalInterfaceType(Tree lambdaTree, 
                                                    com.sun.tools.javac.code.Types javacTypes) {
     Tree parentTree =
       TreePath.getPath(this.root, lambdaTree).getParentPath().getLeaf();
     switch (parentTree.getKind()) {
       case TYPE_CAST:
         TypeCastTree cast = (TypeCastTree)parentTree;
         assertFunctionalInterface(javacTypes,
           (Type)trees.getTypeMirror(getPath(cast.getType())), parentTree,
           lambdaTree);
         return (AnnotatedDeclaredType)getAnnotatedType(cast.getType());
       case METHOD_INVOCATION:
         MethodInvocationTree method = (MethodInvocationTree)parentTree;
         int index = method.getArguments().indexOf(lambdaTree);
         Pair<AnnotatedExecutableType,List<AnnotatedTypeMirror>> exe =
           this.methodFromUse(method);
         AnnotatedTypeMirror param =
           exe.first.getParameterTypes().get(index);
         assertFunctionalInterface(javacTypes,
           (Type)param.getUnderlyingType(), parentTree, lambdaTree);
         return (AnnotatedDeclaredType)param;
       case VARIABLE:
         VariableTree varTree = (VariableTree)parentTree;
         assertFunctionalInterface(javacTypes,
           (Type)InternalUtils.typeOf(varTree), parentTree, lambdaTree);
         return (AnnotatedDeclaredType)getAnnotatedType(varTree.getType());
       case ASSIGNMENT:
         AssignmentTree assignmentTree = (AssignmentTree)parentTree;
         assertFunctionalInterface(javacTypes,
           (Type)InternalUtils.typeOf(assignmentTree), parentTree,
           lambdaTree);
         return (AnnotatedDeclaredType)getAnnotatedType(assignmentTree.getVariable());
       case RETURN:
         Tree enclosing =
           TreeUtils.enclosingOfKind(TreePath.getPath(this.root, parentTree),
             new HashSet<>(Arrays.asList(Tree.Kind.METHOD,
                             Tree.Kind.LAMBDA_EXPRESSION)));
         if (enclosing.getKind() == Tree.Kind.METHOD) {
           MethodTree enclosingMethod = (MethodTree)enclosing;
           return (AnnotatedDeclaredType)getAnnotatedType(enclosingMethod.getReturnType());
         } else {
           LambdaExpressionTree enclosingLambda =
             (LambdaExpressionTree)enclosing;
           Pair<AnnotatedDeclaredType,AnnotatedExecutableType> result =
             getFnInterfaceFromTree(enclosingLambda);
           AnnotatedExecutableType methodExe = result.second;
           return (AnnotatedDeclaredType)methodExe.getReturnType();
         }
       case LAMBDA_EXPRESSION:
         LambdaExpressionTree enclosingLambda =
           (LambdaExpressionTree)parentTree;
         Pair<AnnotatedDeclaredType,AnnotatedExecutableType> result =
           getFnInterfaceFromTree(enclosingLambda);
         AnnotatedExecutableType methodExe = result.second;
         return (AnnotatedDeclaredType)methodExe.getReturnType();
       default:
         ErrorReporter.errorAbort("Could not find functional interface from assignment context. " + "Unexpected tree type: " + 
           parentTree.getKind() + " For lambda tree: " + lambdaTree);
         return null;
     }
   }
   private
   void assertFunctionalInterface(com.sun.tools.javac.code.Types javacTypes, 
                                  Type type, Tree contextTree, 
                                  Tree lambdaTree) {
     if (!javacTypes.isFunctionalInterface(type)) {
       ErrorReporter.errorAbort(String.format("Expected the type of %s tree in assignment context to be a functional interface. " + "Found type: %s for tree: %s in lambda tree: %s",
                                  contextTree.getKind(), type, contextTree,
                                  lambdaTree));
     }
   }
   private
   void makeGroundTargetType(AnnotatedDeclaredType overriddenType) {
     if (overriddenType.getTypeArguments().size() > 0) {
       List<AnnotatedTypeParameterBounds> bounds =
         this.typeVariablesFromUse(overriddenType,
           (TypeElement)overriddenType.getUnderlyingType().asElement());
       List<AnnotatedTypeMirror> newTypeArguments =
         new ArrayList<>(overriddenType.getTypeArguments());
       for (int i = 0; i < overriddenType.getTypeArguments().size(); i++) {
         AnnotatedTypeMirror argType =
           overriddenType.getTypeArguments().get(i);
         if (argType.getKind() == TypeKind.WILDCARD) {
           AnnotatedWildcardType wildcardType =
             (AnnotatedWildcardType)argType;
           final TypeMirror wilcardUbType =
             wildcardType.getExtendsBound().getUnderlyingType();
           final TypeMirror typeParamUbType =
             bounds.get(i).getUpperBound().getUnderlyingType();
           if (isExtendsWildcard(wildcardType)) {
             TypeMirror glbType =
               InternalUtils.greatestLowerBound(this.checker.getProcessingEnvironment(),
                 typeParamUbType, wilcardUbType);
             final AnnotatedTypeMirror newArg;
             if (types.isSameType(wilcardUbType, glbType)) {
               newArg = wildcardType.getExtendsBound().deepCopy();
             } else {
               newArg = this.toAnnotatedType(glbType, false);
               newArg.replaceAnnotations(wildcardType.getExtendsBound().getAnnotations());
             }
             newTypeArguments.set(i, newArg);
           } else {
             newTypeArguments.set(i, wildcardType.getSuperBound());
           }
         }
       }
       overriddenType.setTypeArguments(newTypeArguments);
     }
   }
   private
   boolean isExtendsWildcard(AnnotatedWildcardType awt) {
     return awt.getUnderlyingType().getSuperBound() == null;
   }
   public
   Elements getElementUtils() {
     return this.elements;
   }
   public
   Trees getTreeUtils() {
     return this.trees;
   }
   public
   ProcessingEnvironment getProcessingEnv() {
     return this.processingEnv;
   }
   public
   CFContext getContext() {
     return checker;
   }
}