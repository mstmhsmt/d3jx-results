// generated by Diff/AST Java Unparser
package com.redhat.rhn.frontend.xmlrpc.system;
import static java.util.stream.Collectors.toList;
import com.redhat.rhn.FaultException;
import com.redhat.rhn.common.client.ClientCertificate;
import com.redhat.rhn.common.conf.ConfigDefaults;
import com.redhat.rhn.common.db.datasource.DataResult;
import com.redhat.rhn.common.hibernate.HibernateFactory;
import com.redhat.rhn.common.hibernate.LookupException;
import com.redhat.rhn.common.localization.LocalizationService;
import com.redhat.rhn.common.messaging.MessageQueue;
import com.redhat.rhn.common.validator.ValidatorError;
import com.redhat.rhn.common.validator.ValidatorResult;
import com.redhat.rhn.domain.action.Action;
import com.redhat.rhn.domain.action.ActionFactory;
import com.redhat.rhn.domain.action.ActionType;
import com.redhat.rhn.domain.action.script.ScriptAction;
import com.redhat.rhn.domain.action.script.ScriptActionDetails;
import com.redhat.rhn.domain.action.script.ScriptResult;
import com.redhat.rhn.domain.action.script.ScriptRunAction;
import com.redhat.rhn.domain.action.server.ServerAction;
import com.redhat.rhn.domain.action.virtualization.VirtualizationSetMemoryAction;
import com.redhat.rhn.domain.action.virtualization.VirtualizationSetVcpusAction;
import com.redhat.rhn.domain.channel.Channel;
import com.redhat.rhn.domain.channel.ChannelArch;
import com.redhat.rhn.domain.channel.ChannelFactory;
import com.redhat.rhn.domain.channel.ClonedChannel;
import com.redhat.rhn.domain.channel.NoBaseChannelFoundException;
import com.redhat.rhn.domain.entitlement.Entitlement;
import com.redhat.rhn.domain.errata.Errata;
import com.redhat.rhn.domain.kickstart.KickstartData;
import com.redhat.rhn.domain.kickstart.KickstartFactory;
import com.redhat.rhn.domain.org.CustomDataKey;
import com.redhat.rhn.domain.org.Org;
import com.redhat.rhn.domain.org.OrgFactory;
import com.redhat.rhn.domain.product.SUSEProductSet;
import com.redhat.rhn.domain.rhnpackage.Package;
import com.redhat.rhn.domain.rhnpackage.PackageArch;
import com.redhat.rhn.domain.rhnpackage.PackageEvrFactory;
import com.redhat.rhn.domain.rhnpackage.PackageFactory;
import com.redhat.rhn.domain.rhnpackage.PackageName;
import com.redhat.rhn.domain.rhnpackage.profile.DuplicateProfileNameException;
import com.redhat.rhn.domain.rhnpackage.profile.Profile;
import com.redhat.rhn.domain.rhnpackage.profile.ProfileFactory;
import com.redhat.rhn.domain.role.RoleFactory;
import com.redhat.rhn.domain.server.CPU;
import com.redhat.rhn.domain.server.ContactMethod;
import com.redhat.rhn.domain.server.CustomDataValue;
import com.redhat.rhn.domain.server.Device;
import com.redhat.rhn.domain.server.Dmi;
import com.redhat.rhn.domain.server.Location;
import com.redhat.rhn.domain.server.ManagedServerGroup;
import com.redhat.rhn.domain.server.MinionServer;
import com.redhat.rhn.domain.server.NetworkInterface;
import com.redhat.rhn.domain.server.Note;
import com.redhat.rhn.domain.server.PushClient;
import com.redhat.rhn.domain.server.Server;
import com.redhat.rhn.domain.server.ServerFactory;
import com.redhat.rhn.domain.server.ServerSnapshot;
import com.redhat.rhn.domain.server.SnapshotTag;
import com.redhat.rhn.domain.server.VirtualInstance;
import com.redhat.rhn.domain.server.VirtualInstanceFactory;
import com.redhat.rhn.domain.token.ActivationKey;
import com.redhat.rhn.domain.token.ActivationKeyFactory;
import com.redhat.rhn.domain.user.User;
import com.redhat.rhn.frontend.dto.ActivationKeyDto;
import com.redhat.rhn.frontend.dto.ErrataOverview;
import com.redhat.rhn.frontend.dto.EssentialChannelDto;
import com.redhat.rhn.frontend.dto.HistoryEvent;
import com.redhat.rhn.frontend.dto.PackageListItem;
import com.redhat.rhn.frontend.dto.ProfileOverviewDto;
import com.redhat.rhn.frontend.dto.ServerPath;
import com.redhat.rhn.frontend.dto.SystemCurrency;
import com.redhat.rhn.frontend.dto.SystemOverview;
import com.redhat.rhn.frontend.dto.VirtualSystemOverview;
import com.redhat.rhn.frontend.events.SsmDeleteServersEvent;
import com.redhat.rhn.frontend.xmlrpc.BaseHandler;
import com.redhat.rhn.frontend.xmlrpc.InvalidActionTypeException;
import com.redhat.rhn.frontend.xmlrpc.InvalidChannelException;
import com.redhat.rhn.frontend.xmlrpc.InvalidChannelLabelException;
import com.redhat.rhn.frontend.xmlrpc.InvalidChannelListException;
import com.redhat.rhn.frontend.xmlrpc.InvalidEntitlementException;
import com.redhat.rhn.frontend.xmlrpc.InvalidPackageArchException;
import com.redhat.rhn.frontend.xmlrpc.InvalidPackageException;
import com.redhat.rhn.frontend.xmlrpc.InvalidParameterException;
import com.redhat.rhn.frontend.xmlrpc.InvalidProfileLabelException;
import com.redhat.rhn.frontend.xmlrpc.InvalidSystemException;
import com.redhat.rhn.frontend.xmlrpc.MethodInvalidParamException;
import com.redhat.rhn.frontend.xmlrpc.NoPushClientException;
import com.redhat.rhn.frontend.xmlrpc.NoSuchActionException;
import com.redhat.rhn.frontend.xmlrpc.NoSuchCobblerSystemRecordException;
import com.redhat.rhn.frontend.xmlrpc.NoSuchNetworkInterfaceException;
import com.redhat.rhn.frontend.xmlrpc.NoSuchPackageException;
import com.redhat.rhn.frontend.xmlrpc.NoSuchSnapshotTagException;
import com.redhat.rhn.frontend.xmlrpc.NoSuchSystemException;
import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;
import com.redhat.rhn.frontend.xmlrpc.ProfileNameTooLongException;
import com.redhat.rhn.frontend.xmlrpc.ProfileNameTooShortException;
import com.redhat.rhn.frontend.xmlrpc.ProfileNoBaseChannelException;
import com.redhat.rhn.frontend.xmlrpc.RhnXmlRpcServer;
import com.redhat.rhn.frontend.xmlrpc.SnapshotTagAlreadyExistsException;
import com.redhat.rhn.frontend.xmlrpc.SystemIdInstantiationException;
import com.redhat.rhn.frontend.xmlrpc.SystemsNotDeletedException;
import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;
import com.redhat.rhn.frontend.xmlrpc.UndefinedCustomFieldsException;
import com.redhat.rhn.frontend.xmlrpc.UnrecognizedCountryException;
import com.redhat.rhn.frontend.xmlrpc.kickstart.XmlRpcKickstartHelper;
import com.redhat.rhn.frontend.xmlrpc.user.XmlRpcUserHelper;
import com.redhat.rhn.manager.MissingCapabilityException;
import com.redhat.rhn.manager.MissingEntitlementException;
import com.redhat.rhn.manager.action.ActionManager;
import com.redhat.rhn.manager.channel.ChannelManager;
import com.redhat.rhn.manager.distupgrade.DistUpgradeException;
import com.redhat.rhn.manager.distupgrade.DistUpgradeManager;
import com.redhat.rhn.manager.entitlement.EntitlementManager;
import com.redhat.rhn.manager.errata.ErrataManager;
import com.redhat.rhn.manager.kickstart.KickstartFormatter;
import com.redhat.rhn.manager.kickstart.KickstartScheduleCommand;
import com.redhat.rhn.manager.kickstart.ProvisionVirtualInstanceCommand;
import com.redhat.rhn.manager.kickstart.cobbler.CobblerSystemCreateCommand;
import com.redhat.rhn.manager.kickstart.cobbler.CobblerUnregisteredSystemCreateCommand;
import com.redhat.rhn.manager.kickstart.cobbler.CobblerUnregisteredSystemCreateCommand.CobblerNetworkInterface;
import com.redhat.rhn.manager.kickstart.cobbler.CobblerXMLRPCHelper;
import com.redhat.rhn.manager.profile.ProfileManager;
import com.redhat.rhn.manager.rhnpackage.PackageManager;
import com.redhat.rhn.manager.satellite.SystemCommandExecutor;
import com.redhat.rhn.manager.system.DuplicateSystemGrouping;
import com.redhat.rhn.manager.system.ServerGroupManager;
import com.redhat.rhn.manager.system.SystemManager;
import com.redhat.rhn.manager.system.UpdateBaseChannelCommand;
import com.redhat.rhn.manager.system.UpdateChildChannelsCommand;
import com.redhat.rhn.manager.system.VirtualizationActionCommand;
import com.redhat.rhn.manager.token.ActivationKeyManager;
import com.redhat.rhn.taskomatic.TaskomaticApi;
import com.suse.manager.webui.utils.gson.JSONBootstrapHosts;
import org.apache.commons.lang3.StringUtils;
import org.apache.log4j.Logger;
import org.cobbler.SystemRecord;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TimeZone;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
public
class SystemHandler extends BaseHandler
{
   private static Logger log = Logger.getLogger(SystemHandler.class);
   private static final TaskomaticApi TASKOMATIC_API = new TaskomaticApi();
   public
   String obtainReactivationKey(User loggedInUser, Integer sid)
     throws FaultException {
     Server server = lookupServer(loggedInUser, sid);
     return getReactivationKey(loggedInUser, server);
   }
   private
   String getReactivationKey(User loggedInUser, Server server) {
     if (!SystemManager.serverHasFeature(server.getId(), "ftr_agent_smith")) {
       throw new PermissionCheckFailureException();
     }
     ActivationKeyFactory.removeKeysForServer(server.getId());
     String note = "Reactivation key for " + server.getName() + ".";
     ActivationKey key =
       ActivationKeyManager.getInstance().createNewReActivationKey(loggedInUser,
         server, note);
     key.setUsageLimit(new Long(1));
     return key.getKey();
   }
   public
   String obtainReactivationKey(String clientCert) throws FaultException {
     Server server = validateClientCertificate(clientCert);
     return getReactivationKey(server.getOrg().getActiveOrgAdmins().get(0),
              server);
   }
   public
   int upgradeEntitlement(User loggedInUser, Integer sid, 
                          String entitlementLevel)
     throws FaultException {
     Server server = lookupServer(loggedInUser, sid);
     final Entitlement entitlement =
       EntitlementManager.getByName(entitlementLevel);
     validateEntitlements(new ArrayList()
                          {
                             
                             {
                                add(entitlement);
                             }
                          });
     if (!SystemManager.canEntitleServer(server, entitlement)) {
       throw new PermissionCheckFailureException();
     }
     SystemManager.entitleServer(server, entitlement);
     SystemManager.snapshotServer(server,
       LocalizationService.getInstance().getMessage("snapshots.entitlements"));
     return 1;
   }
   public
   int setChildChannels(User loggedInUser, Integer sid, 
                        List channelIdsOrLabels)
     throws FaultException {
     Server server = lookupServer(loggedInUser, sid);
     boolean receivedLabels = false;
     if (channelIdsOrLabels.size() > 0) {
       if (channelIdsOrLabels.get(0) instanceof String) {
         receivedLabels = true;
       }
       for (Object object : channelIdsOrLabels) {
         if (receivedLabels) {
           if (!(object instanceof String)) {
             throw new InvalidChannelListException();
           }
         } else {
           if (!(object instanceof Integer)) {
             throw new InvalidChannelListException();
           }
         }
       }
     }
     List<Long> channelIds = new ArrayList<Long>();
     if (receivedLabels) {
       channelIds = ChannelFactory.getChannelIds(channelIdsOrLabels);
       if (channelIds.size() != channelIdsOrLabels.size()) {
         throw new InvalidChannelLabelException();
       }
     } else {
       for (Object channelId : channelIdsOrLabels) {
         channelIds.add(new Long((Integer)channelId));
       }
     }
     UpdateChildChannelsCommand cmd =
       new UpdateChildChannelsCommand(loggedInUser, server, channelIds);
     cmd.store();
     SystemManager.snapshotServer(server,
       LocalizationService.getInstance().getMessage("snapshots.childchannel"));
     return 1;
   }
   @Deprecated
   public
   int setBaseChannel(User loggedInUser, Integer sid, Integer cid)
     throws FaultException {
     Server server = lookupServer(loggedInUser, sid);
     UpdateBaseChannelCommand cmd =
       new UpdateBaseChannelCommand(loggedInUser, server,
         new Long(cid.longValue()));
     ValidatorError ve = cmd.store();
     if (ve != null) {
       throw new InvalidChannelException(LocalizationService.getInstance().getMessage(
                                           ve.getKey(), ve.getValues()));
     }
     return 1;
   }
   public
   int setBaseChannel(User loggedInUser, Integer sid, String channelLabel)
     throws FaultException {
     Server server = lookupServer(loggedInUser, sid);
     UpdateBaseChannelCommand cmd = null;
     if (StringUtils.isEmpty(channelLabel)) {
       cmd = new UpdateBaseChannelCommand(loggedInUser, server, new Long(-1));
     } else {
       List<String> channelLabels = new ArrayList<String>();
       channelLabels.add(channelLabel);
       List<Long> channelIds = new ArrayList<Long>();
       channelIds = ChannelFactory.getChannelIds(channelLabels);
       if (channelIds.size() > 0) {
         cmd =
         new UpdateBaseChannelCommand(loggedInUser, server,
           channelIds.get(0));
       } else {
         throw new InvalidChannelLabelException();
       }
     }
     ValidatorError ve = cmd.store();
     if (ve != null) {
       throw new InvalidChannelException(LocalizationService.getInstance().getMessage(
                                           ve.getKey(), ve.getValues()));
     }
     SystemManager.snapshotServer(server,
       LocalizationService.getInstance().getMessage("snapshots.basechannel"));
     return 1;
   }
   @Deprecated
   public
   Object[] listBaseChannels(User loggedInUser, Integer sid)
     throws FaultException {
     return listSubscribableBaseChannels(loggedInUser, sid);
   }
   public
   Object[] listSubscribableBaseChannels(User loggedInUser, Integer sid)
     throws FaultException {
     Server server = lookupServer(loggedInUser, sid);
     Channel baseChannel = server.getBaseChannel();
     List<Map<String,Object>> returnList =
       new ArrayList<Map<String,Object>>();
     List<EssentialChannelDto> list =
       ChannelManager.listBaseChannelsForSystem(loggedInUser, server);
     for (EssentialChannelDto ch : list) {
       Boolean currentBase =
         (baseChannel != null) && baseChannel.getId().equals(ch.getId());
       returnList.add(createChannelMap(ch, currentBase));
     }
     return returnList.toArray();
   }
   public
   Object[] listSystems(User loggedInUser) throws FaultException {
     DataResult<SystemOverview> dr =
       SystemManager.systemListShort(loggedInUser, null);
     dr.elaborate();
     return dr.toArray();
   }
   public
   List<SystemOverview> listActiveSystems(User loggedInUser)
     throws FaultException {
     return SystemManager.systemListShortActive(loggedInUser, null);
   }
   private
   Date convertLocalToUtc(Date in) {
     Calendar c = Calendar.getInstance();
     c.setTime(in);
     TimeZone z = c.getTimeZone();
     int offset = z.getRawOffset();
     if (z.inDaylightTime(in)) {
       offset += z.getDSTSavings();
     }
     int offsetHrs = offset / 1000 / 60 / 60;
     int offsetMins = offset / 1000 / 60 % 60;
     c.add(Calendar.HOUR_OF_DAY, (-offsetHrs));
     c.add(Calendar.MINUTE, (-offsetMins));
     c.set(Calendar.MILLISECOND, 0);
     return c.getTime();
   }
   public
   List<Map<String,Object>> listActiveSystemsDetails(User loggedInUser, 
                                                     List<Integer> serverIds)
     throws FaultException {
     List<Server> servers =
       XmlRpcSystemHelper.getInstance().lookupServers(loggedInUser,
         serverIds);
     List<Map<String,Object>> ret = new ArrayList<Map<String,Object>>();
     for (Server server : servers) {
       if (!server.isInactive()) {
         Map<String,Object> m = new HashMap<String,Object>();
         m.put("id", server.getId());
         m.put("name", server.getName());
         m.put("last_checkin", convertLocalToUtc(server.getLastCheckin()));
         m.put("ram", new Long(server.getRam()));
         m.put("swap", new Long(server.getSwap()));
         CPU cpu = server.getCpu();
         if (cpu == null) {
           m.put("cpu_info", new HashMap<String,String>());
         } else {
           m.put("cpu_info", cpu);
         }
         Dmi dmi = server.getDmi();
         if (dmi == null) {
           m.put("dmi_info", new HashMap<String,String>());
         } else {
           m.put("dmi_info", dmi);
         }
         m.put("network_devices",
           new ArrayList<NetworkInterface>(server.getNetworkInterfaces()));
         List<Map<String,Object>> channels =
           new ArrayList<Map<String,Object>>();
         Channel base = server.getBaseChannel();
         if (base != null) {
           Map<String,Object> basec = new HashMap<String,Object>();
           basec.put("channel_id", base.getId());
           basec.put("channel_label", base.getLabel());
           channels.add(basec);
           for (Channel child : server.getChildChannels()) {
             Map<String,Object> childc = new HashMap<String,Object>();
             childc.put("channel_id", child.getId());
             childc.put("channel_label", child.getLabel());
             channels.add(childc);
           }
         }
         m.put("subscribed_channels", channels);
         Collection<VirtualInstance> guests = server.getGuests();
         List<Long> guestList = new ArrayList<Long>();
         for (VirtualInstance guest : guests) {
           Server g = guest.getGuestSystem();
           if (g != null && !g.isInactive()) {
             guestList.add(g.getId());
           }
         }
         ret.add(m);
       }
     }
     return ret;
   }
   private
   Map<String,Object> createChannelMap(EssentialChannelDto channel, 
                                       Boolean currentBase) {
     Map<String,Object> ret = new HashMap<String,Object>();
     ret.put("id", channel.getId());
     ret.put("name", channel.getName());
     ret.put("label", channel.getLabel());
     ret.put("current_base", currentBase ? new Integer(1) : new Integer(0));
     return ret;
   }
   @Deprecated
   public
   Object[] listChildChannels(User loggedInUser, Integer sid)
     throws FaultException {
     return listSubscribableChildChannels(loggedInUser, sid);
   }
   public
   Object[] listSubscribableChildChannels(User loggedInUser, Integer sid)
     throws FaultException {
     Server server = lookupServer(loggedInUser, sid);
     Channel baseChannel = server.getBaseChannel();
     List<Map<String,Object>> returnList =
       new ArrayList<Map<String,Object>>();
     if (baseChannel == null) {
       return returnList.toArray();
     }
     DataResult<Map<String,Object>> dr =
       SystemManager.subscribableChannels(server.getId(),
         loggedInUser.getId(), baseChannel.getId());
     for (Iterator<Map<String,Object>> itr = dr.iterator(); itr.hasNext(); ) {
       Map<String,Object> row = itr.next();
       Map<String,Object> channel = new HashMap<String,Object>();
       channel.put("id", row.get("id"));
       channel.put("label", row.get("label"));
       channel.put("name", row.get("name"));
       channel.put("summary", row.get("summary"));
       channel.put("has_license", "");
       channel.put("gpg_key_url",
         StringUtils.defaultString((String)row.get("gpg_key_url")));
       returnList.add(channel);
     }
     return returnList.toArray();
   }
   public
   Object[] listOlderInstalledPackages(User loggedInUser, Integer sid, 
                                       String name, String version, 
                                       String release, String epoch)
     throws FaultException {
     Server server = lookupServer(loggedInUser, sid);
     List toCheck = packagesToCheck(server, name);
     List returnList = new ArrayList();
     for (Iterator itr = toCheck.iterator(); itr.hasNext(); ) {
       Map pkg = (Map)itr.next();
       String pkgName = (String)pkg.get("name");
       String pkgVersion = (String)pkg.get("version");
       String pkgRelease = (String)pkg.get("release");
       String pkgEpoch = (String)pkg.get("epoch");
       int c =
         PackageManager.verCmp(pkgEpoch, pkgVersion, pkgRelease, epoch,
           version, release);
       if (0 > c) {
         returnList.add(fillOutPackage(pkgName, pkgVersion, pkgRelease,
                          pkgEpoch));
       }
     }
     return returnList.toArray();
   }
   public
   Object[] listNewerInstalledPackages(User loggedInUser, Integer sid, 
                                       String name, String version, 
                                       String release, String epoch)
     throws FaultException {
     Server server = lookupServer(loggedInUser, sid);
     List toCheck = packagesToCheck(server, name);
     List returnList = new ArrayList();
     for (Iterator itr = toCheck.iterator(); itr.hasNext(); ) {
       Map pkg = (Map)itr.next();
       String pkgName = (String)pkg.get("name");
       String pkgVersion = (String)pkg.get("version");
       String pkgRelease = (String)pkg.get("release");
       String pkgEpoch = (String)pkg.get("epoch");
       int c =
         PackageManager.verCmp(pkgEpoch, pkgVersion, pkgRelease, epoch,
           version, release);
       if (0 < c) {
         returnList.add(fillOutPackage(pkgName, pkgVersion, pkgRelease,
                          pkgEpoch));
       }
     }
     return returnList.toArray();
   }
   private
   List<Map<String,Object>> packagesToCheck(Server server, String name)
     throws NoSuchPackageException {
     DataResult<Map<String,Object>> installed =
       SystemManager.installedPackages(server.getId(), false);
     List<Map<String,Object>> toCheck = new ArrayList<Map<String,Object>>();
     for (Iterator<Map<String,Object>> itr = installed.iterator();
          itr.hasNext(); ) {
       Map<String,Object> pkg = itr.next();
       String pkgName = StringUtils.trim((String)pkg.get("name"));
       if (pkgName.equals(StringUtils.trim(name))) {
         toCheck.add(pkg);
       }
     }
     if (toCheck.isEmpty()) {
       throw new NoSuchPackageException();
     }
     return toCheck;
   }
   private
   Map<String,String> fillOutPackage(String pkgName, String pkgVersion, 
                                     String pkgRelease, String pkgEpoch) {
     Map<String,String> map = new HashMap<String,String>();
     map.put("name", StringUtils.defaultString(pkgName));
     map.put("version", StringUtils.defaultString(pkgVersion));
     map.put("release", StringUtils.defaultString(pkgRelease));
     map.put("epoch", StringUtils.defaultString(pkgEpoch));
     return map;
   }
   public
   int isNvreInstalled(User loggedInUser, Integer sid, String name, 
                       String version, String release)
     throws FaultException {
     return isNvreInstalled(loggedInUser, sid, name, version, release, null);
   }
   public
   int isNvreInstalled(User loggedInUser, Integer sid, String name, 
                       String version, String release, String epoch)
     throws FaultException {
     Server server = lookupServer(loggedInUser, sid);
     DataResult<Map<String,Object>> packages =
       SystemManager.installedPackages(server.getId(), false);
     for (Iterator<Map<String,Object>> itr = packages.iterator();
          itr.hasNext(); ) {
       Map<String,Object> pkg = itr.next();
       String pkgName = StringUtils.trim((String)pkg.get("name"));
       if (!pkgName.equals(StringUtils.trim(name))) {
         continue;
       }
       String pkgVersion = StringUtils.trim((String)pkg.get("version"));
       if (!pkgVersion.equals(StringUtils.trim(version))) {
         continue;
       }
       String pkgRelease = StringUtils.trim((String)pkg.get("release"));
       if (!pkgRelease.equals(StringUtils.trim(release))) {
         continue;
       }
       String pkgEpoch = StringUtils.trim((String)pkg.get("epoch"));
       if ((epoch != null) && !pkgEpoch.equals(StringUtils.trim(epoch))) {
         continue;
       }
       return 1;
     }
     return 0;
   }
   public
   List<Map<String,Object>> listLatestUpgradablePackages(User loggedInUser, 
                                                         Integer sid)
     throws FaultException {
     Server server = lookupServer(loggedInUser, sid);
     return SystemManager.latestUpgradablePackages(server.getId());
   }
   public
   List<Map<String,Object>> listAllInstallablePackages(User loggedInUser, 
                                                       Integer sid)
     throws FaultException {
     Server server = lookupServer(loggedInUser, sid);
     return SystemManager.allInstallablePackages(server.getId());
   }
   public
   List<Map<String,Object>> listLatestInstallablePackages(User loggedInUser, 
                                                          Integer sid)
     throws FaultException {
     Server server = lookupServer(loggedInUser, sid);
     return SystemManager.latestInstallablePackages(server.getId());
   }
   public
   List<Map<String,Object>> listLatestAvailablePackage(User loggedInUser, 
                                                       List<Integer> systemIds,
                                                       String name)
     throws FaultException {
     List<Map<String,Object>> list = new ArrayList<Map<String,Object>>();
     for (Integer sid : systemIds) {
       Server server = lookupServer(loggedInUser, sid);
       Map<String,Object> systemMap = new HashMap<String,Object>();
       Map pkgEvr =
         PackageManager.lookupEvrIdByPackageName(sid.longValue(), name);
       if (pkgEvr != null) {
         Package pkg =
           PackageManager.guestimatePackageBySystem(sid.longValue(),
             (Long)pkgEvr.get("name_id"), (Long)pkgEvr.get("evr_id"), null,
             loggedInUser.getOrg());
         if (pkg != null) {
           Map<String,Object> pkgMap = new HashMap<String,Object>();
           pkgMap.put("id", pkg.getId());
           pkgMap.put("name", pkg.getPackageName().getName());
           pkgMap.put("version", pkg.getPackageEvr().getVersion());
           pkgMap.put("release", pkg.getPackageEvr().getRelease());
           pkgMap.put("arch", pkg.getPackageArch().getLabel());
           if (pkg.getPackageEvr().getEpoch() != null) {
             pkgMap.put("epoch", pkg.getPackageEvr().getEpoch());
           } else {
             pkgMap.put("epoch", "");
           }
           systemMap.put("id", sid);
           systemMap.put("name", server.getName());
           systemMap.put("package", pkgMap);
           list.add(systemMap);
         }
       }
     }
     return list;
   }
   public
   Object[] getEntitlements(User loggedInUser, Integer sid)
     throws FaultException {
     Server server = lookupServer(loggedInUser, sid);
     List<String> entitlements = new ArrayList<String>();
     for (Iterator<Entitlement> itr = server.getEntitlements().iterator();
          itr.hasNext(); ) {
       Entitlement entitlement = itr.next();
       entitlements.add(entitlement.getLabel());
     }
     return entitlements.toArray();
   }
   public
   String downloadSystemId(User loggedInUser, Integer sid)
     throws FaultException {
     Server server = lookupServer(loggedInUser, sid);
     try {
       ClientCertificate cert =
         SystemManager.createClientCertificate(server);
       return cert.asXml();
     } catch (InstantiationException e) {
       throw new SystemIdInstantiationException();
     } 
   }
   public
   List<Map<String,Object>> listPackages(User loggedInUser, Integer sid)
     throws FaultException {
     Server server = lookupServer(loggedInUser, sid);
     return SystemManager.installedPackages(server.getId(), false);
   }
   public
   Integer deleteGuestProfiles(User loggedInUser, Integer hostId, 
                               List<String> guestNames) {
     Server server = lookupServer(loggedInUser, hostId);
     if (server != null && !server.isVirtualHost()) {
       throw new FaultException(1005, "notAHostSystem",
               "The system ID specified (" + hostId + ") does not represent a host system");
     }
     List<String> availableGuests = new ArrayList<String>();
     for (VirtualInstance vi : server.getGuests()) {
       availableGuests.add(vi.getName());
     }
     for (String gn : guestNames) {
       if (!availableGuests.contains(gn)) {
         throw new InvalidSystemException();
       }
     }
     for (VirtualInstance vi : server.getGuests()) {
       if (!guestNames.contains(vi.getName())) {
         continue;
       }
       if (vi.isRegisteredGuest()) {
         throw new SystemsNotDeletedException("Unable to delete guest profile " + 
                 vi.getName() + ": the guest is registered.");
       }
       VirtualInstanceFactory.getInstance().deleteVirtualInstanceOnly(vi);
     }
     return 1;
   }
   public
   int deleteSystems(User loggedInUser, List<Integer> systemIds)
     throws FaultException {
     List<Integer> skippedSids = new ArrayList<Integer>();
     List<Long> deletion = new LinkedList<Long>();
     for (Integer sysId : systemIds) {
       if (SystemManager.isAvailableToUser(loggedInUser, sysId.longValue())) {
         deletion.add(sysId.longValue());
       } else {
         log.warn("system " + sysId + " is not available to user, hence will not be deleted");
         skippedSids.add(sysId);
       }
     }
     SsmDeleteServersEvent event =
       new SsmDeleteServersEvent(loggedInUser, deletion);
     MessageQueue.publish(event);
     if (skippedSids.size() > 0) {
       StringBuilder msg =
         new StringBuilder("The following systems were NOT deleted: ");
       for (Integer sid : skippedSids) {
         msg.append("\n" + sid);
       }
       throw new SystemsNotDeletedException(msg.toString());
     }
     return 1;
   }
   public
   int deleteSystem(String clientCert) throws FaultException {
     Server server = validateClientCertificate(clientCert);
     SystemManager.deleteServer(server.getOrg().getActiveOrgAdmins().get(0),
       server.getId());
     return 1;
   }
   public
   int deleteSystem(User loggedInUser, Integer serverId)
     throws FaultException {
     Server server = lookupServer(loggedInUser, serverId);
     SystemManager.deleteServer(loggedInUser, server.getId());
     return 1;
   }
   public
   Map<String,String> getNetwork(User loggedInUser, Integer sid)
     throws FaultException {
     Server server = lookupServer(loggedInUser, sid);
     String ip = server.getIpAddress();
     String ip6 = server.getIp6Address();
     String hostname = server.getHostname();
     Map<String,String> network = new HashMap<String,String>();
     network.put("ip", StringUtils.defaultString(ip));
     network.put("ip6", StringUtils.defaultString(ip6));
     network.put("hostname", StringUtils.defaultString(hostname));
     return network;
   }
   public
   List<NetworkInterface> getNetworkDevices(User loggedInUser, Integer sid)
     throws FaultException {
     Server server = lookupServer(loggedInUser, sid);
     Set<NetworkInterface> devices = server.getNetworkInterfaces();
     return new ArrayList<NetworkInterface>(devices);
   }
   public
   int setGroupMembership(User loggedInUser, Integer sid, Integer sgid, 
                          boolean member)
     throws FaultException {
     ensureSystemGroupAdmin(loggedInUser);
     Server server = lookupServer(loggedInUser, sid);
     ServerGroupManager manager = ServerGroupManager.getInstance();
     try {
       ManagedServerGroup group =
         manager.lookup(new Long(sgid.longValue()), loggedInUser);
       List<Server> servers = new ArrayList<Server>(1);
       servers.add(server);
       if (member) {
         manager.addServers(group, servers, loggedInUser);
       } else {
         manager.removeServers(group, servers, loggedInUser);
       }
     } catch (LookupException le) {
       throw new PermissionCheckFailureException(le);
     } 
     return 1;
   }
   public
   Object[] listGroups(User loggedInUser, Integer sid) throws FaultException {
     Server server = lookupServer(loggedInUser, sid);
     DataResult<Map<String,Object>> groups =
       SystemManager.availableSystemGroups(server, loggedInUser);
     List<Map<String,Object>> returnList =
       new ArrayList<Map<String,Object>>();
     for (Iterator<Map<String,Object>> itr = groups.iterator();
          itr.hasNext(); ) {
       Map<String,Object> map = itr.next();
       Map<String,Object> row = new HashMap<String,Object>();
       row.put("id", map.get("id"));
       row.put("sgid", map.get("id").toString());
       row.put("system_group_name",
         StringUtils.defaultString((String)map.get("group_name")));
       row.put("subscribed", map.get("is_system_member"));
       returnList.add(row);
     }
     return returnList.toArray();
   }
   public
   List<SystemOverview> listUserSystems(User loggedInUser, String login)
     throws FaultException {
     User target =
       XmlRpcUserHelper.getInstance().lookupTargetUser(loggedInUser, login);
     return SystemManager.systemListShort(target, null);
   }
   public
   List<SystemOverview> listUserSystems(User loggedInUser) {
     return SystemManager.systemListShort(loggedInUser, null);
   }
   public
   int setCustomValues(User loggedInUser, Integer sid, 
                       Map<String,String> values)
     throws FaultException {
     Server server = lookupServer(loggedInUser, sid);
     Org org = loggedInUser.getOrg();
     List<String> skippedKeys = new ArrayList<String>();
     Set<String> keys = values.keySet();
     for (Iterator<String> itr = keys.iterator(); itr.hasNext(); ) {
       String label = itr.next();
       if (org.hasCustomDataKey(label) && !StringUtils.isBlank(values.get(label))) {
         server.addCustomDataValue(label, values.get(label), loggedInUser);
       } else {
         skippedKeys.add(label);
       }
     }
     if (skippedKeys.size() > 0) {
       StringBuilder msg =
         new StringBuilder("One or more of the following " + "custom info fields was not defined: ");
       for (Iterator<String> itr = skippedKeys.iterator(); itr.hasNext(); ) {
         String label = itr.next();
         msg.append("\n" + label);
       }
       throw new UndefinedCustomFieldsException(msg.toString());
     }
     return 1;
   }
   public
   Map<String,String> getCustomValues(User loggedInUser, Integer sid)
     throws FaultException {
     Server server = lookupServer(loggedInUser, sid);
     Set<CustomDataValue> customDataValues = server.getCustomDataValues();
     Map<String,String> returnMap = new HashMap<String,String>();
     for (Iterator<CustomDataValue> itr = customDataValues.iterator();
          itr.hasNext(); ) {
       CustomDataValue val = itr.next();
       if (val.getValue() != null) {
         returnMap.put(val.getKey().getLabel(), val.getValue());
       } else {
         returnMap.put(val.getKey().getLabel(), new String(""));
       }
     }
     return returnMap;
   }
   public
   int deleteCustomValues(User loggedInUser, Integer sid, List<String> keys)
     throws FaultException {
     Server server = lookupServer(loggedInUser, sid);
     loggedInUser.getOrg();
     List<String> skippedKeys = new ArrayList<String>();
     for (String label : keys) {
       CustomDataKey key =
         OrgFactory.lookupKeyByLabelAndOrg(label, loggedInUser.getOrg());
       if (key == null || key.getLabel() == null) {
         skippedKeys.add(label);
       } else {
         ServerFactory.removeCustomDataValue(server, key);
       }
     }
     if (skippedKeys.size() > 0) {
       StringBuilder msg =
         new StringBuilder("One or more of the following " + "custom info keys was not defined: ");
       for (String label : skippedKeys) {
         msg.append("\n" + label);
       }
       throw new UndefinedCustomFieldsException(msg.toString());
     }
     return 1;
   }
   public
   int setProfileName(User loggedInUser, Integer sid, String name)
     throws FaultException {
     Server server = lookupServer(loggedInUser, sid);
     name = StringUtils.trim(name);
     validateProfileName(name);
     server.setName(name);
     SystemManager.storeServer(server);
     return 1;
   }
   private
   void validateProfileName(String name) throws FaultException {
     if (name == null || name.length() < 2) {
       throw new ProfileNameTooShortException();
     }
     if (name.length() > 128) {
       throw new ProfileNameTooLongException();
     }
   }
   public
   int addNote(User loggedInUser, Integer sid, String subject, String body)
     throws FaultException {
     Server server = lookupServer(loggedInUser, sid);
     server.addNote(loggedInUser, subject, body);
     SystemManager.storeServer(server);
     return 1;
   }
   public
   int deleteNote(User loggedInUser, Integer sid, Integer nid) {
     if (sid == null) {
       throw new IllegalArgumentException("sid cannot be null");
     }
     if (nid == null) {
       throw new IllegalArgumentException("nid cannot be null");
     }
     SystemManager.deleteNote(loggedInUser, sid.longValue(), nid.longValue());
     return 1;
   }
   public
   int deleteNotes(User loggedInUser, Integer sid) {
     if (sid == null) {
       throw new IllegalArgumentException("sid cannot be null");
     }
     SystemManager.deleteNotes(loggedInUser, sid.longValue());
     return 1;
   }
   public
   List<Map<String,Object>> listSystemEvents(User loggedInUser, Integer sid, 
                                             String actionType) {
     Server server = lookupServer(loggedInUser, sid);
     List<ServerAction> sActions =
       ActionFactory.listServerActionsForServer(server);
     List<Map<String,Object>> results = new ArrayList<Map<String,Object>>();
     ActionType at = null;
     if (actionType != null) {
       at = ActionFactory.lookupActionTypeByName(actionType);
       if (at == null) {
         throw new IllegalArgumentException("Action type not found: " + actionType);
       }
     }
     for (ServerAction sAction : sActions) {
       Map<String,Object> result = new HashMap<String,Object>();
       Action action = sAction.getParentAction();
       if (at != null && !action.getActionType().equals(at)) {
         continue;
       }
       if (action.getFailedCount() != null) {
         result.put("failed_count", action.getFailedCount());
       }
       if (action.getActionType().getName() != null) {
         result.put("action_type", action.getActionType().getName());
       }
       if (action.getSuccessfulCount() != null) {
         result.put("successful_count", action.getSuccessfulCount());
       }
       if (action.getEarliestAction() != null) {
         result.put("earliest_action", action.getEarliestAction().toString());
       }
       if (action.getArchived() != null) {
         result.put("archived", action.getArchived());
       }
       if ((action.getSchedulerUser() != null) && (action.getSchedulerUser().getLogin() != null)) {
         result.put("scheduler_user", action.getSchedulerUser().getLogin());
       }
       if (action.getPrerequisite() != null) {
         result.put("prerequisite", action.getPrerequisite());
       }
       if (action.getName() != null) {
         result.put("name", action.getName());
       }
       if (action.getId() != null) {
         result.put("id", action.getId());
       }
       if (action.getVersion() != null) {
         result.put("version", action.getVersion().toString());
       }
       if (sAction.getCompletionTime() != null) {
         result.put("completion_time",
           sAction.getCompletionTime().toString());
       }
       if (sAction.getPickupTime() != null) {
         result.put("pickup_time", sAction.getPickupTime().toString());
       }
       if (sAction.getModified() != null) {
         result.put("modified", sAction.getModified().toString());
         result.put("modified_date", sAction.getModified());
       }
       if (sAction.getCreated() != null) {
         result.put("created", sAction.getCreated().toString());
         result.put("created_date", sAction.getCreated());
       }
       if (sAction.getCompletionTime() != null) {
         result.put("completed_date", sAction.getCompletionTime());
       }
       if (sAction.getPickupTime() != null) {
         result.put("pickup_date", sAction.getPickupTime());
       }
       if (sAction.getResultMsg() != null) {
         result.put("result_msg", sAction.getResultMsg());
       }
       ActionType type = action.getActionType();
       List<Map<String,String>> additionalInfo =
         new ArrayList<Map<String,String>>();
       if (type.equals(ActionFactory.TYPE_PACKAGES_REMOVE) || type.equals(ActionFactory.TYPE_PACKAGES_UPDATE) || 
       type.equals(ActionFactory.TYPE_PACKAGES_VERIFY)) {
         DataResult pkgs =
           ActionManager.getPackageList(action.getId(), null);
         for (Iterator itr = pkgs.iterator(); itr.hasNext(); ) {
           Map pkg = (Map)itr.next();
           String detail = (String)pkg.get("nvre");
           Map<String,String> info = new HashMap<String,String>();
           info.put("detail", detail);
           additionalInfo.add(info);
         }
       } else if (type.equals(ActionFactory.TYPE_ERRATA)) {
         DataResult errata = ActionManager.getErrataList(action.getId());
         for (Iterator itr = errata.iterator(); itr.hasNext(); ) {
           Map erratum = (Map)itr.next();
           String detail = (String)erratum.get("advisory");
           detail += " (" + (String)erratum.get("synopsis") + ")";
           Map<String,String> info = new HashMap<String,String>();
           info.put("detail", detail);
           additionalInfo.add(info);
         }
       } else if (type.equals(ActionFactory.TYPE_CONFIGFILES_UPLOAD) || 
       type.equals(ActionFactory.TYPE_CONFIGFILES_MTIME_UPLOAD)) {
         DataResult files =
           ActionManager.getConfigFileUploadList(action.getId());
         for (Iterator itr = files.iterator(); itr.hasNext(); ) {
           Map file = (Map)itr.next();
           Map<String,String> info = new HashMap<String,String>();
           info.put("detail", (String)file.get("path"));
           String error = (String)file.get("failure_reason");
           if (error != null) {
             info.put("result", error);
           }
           additionalInfo.add(info);
         }
       } else if (type.equals(ActionFactory.TYPE_CONFIGFILES_DEPLOY)) {
         DataResult files =
           ActionManager.getConfigFileDeployList(action.getId());
         for (Iterator itr = files.iterator(); itr.hasNext(); ) {
           Map file = (Map)itr.next();
           Map<String,String> info = new HashMap<String,String>();
           String path = (String)file.get("path");
           path += " (rev. " + file.get("revision") + ")";
           info.put("detail", path);
           String error = (String)file.get("failure_reason");
           if (error != null) {
             info.put("result", error);
           }
           additionalInfo.add(info);
         }
       } else if (type.equals(ActionFactory.TYPE_CONFIGFILES_DIFF)) {
         DataResult files =
           ActionManager.getConfigFileDiffList(action.getId());
         for (Iterator itr = files.iterator(); itr.hasNext(); ) {
           Map file = (Map)itr.next();
           Map<String,String> info = new HashMap<String,String>();
           String path = (String)file.get("path");
           path += " (rev. " + file.get("revision") + ")";
           info.put("detail", path);
           String error = (String)file.get("failure_reason");
           if (error != null) {
             info.put("result", error);
           } else {
             String diffString =
               HibernateFactory.getBlobContents(file.get("diff"));
             if (diffString != null) {
               info.put("result", diffString);
             }
           }
           additionalInfo.add(info);
         }
       }
       if (additionalInfo.size() > 0) {
         result.put("additional_info", additionalInfo);
       }
       results.add(result);
     }
     return results;
   }
   public
   List<Map<String,Object>> listSystemEvents(User loggedInUser, Integer sid) {
     return listSystemEvents(loggedInUser, sid, null);
   }
   public
   int provisionVirtualGuest(User loggedInUser, Integer sid, 
                             String guestName, String profileName) {
     return provisionVirtualGuest(loggedInUser, sid, guestName, profileName,
              new Integer(512), new Integer(1), new Integer(3), "");
   }
   public
   int provisionSystem(User loggedInUser, Integer serverId, 
                       String profileName)
     throws FaultException {
     log.debug("provisionSystem called.");
     Server server = lookupServer(loggedInUser, serverId);
     if (!(server.hasEntitlement(EntitlementManager.MANAGEMENT))) {
       throw new FaultException(-2, "provisionError",
               "System does not have management entitlement");
     }
     KickstartData ksdata =
       KickstartFactory.lookupKickstartDataByLabelAndOrgId(profileName,
         loggedInUser.getOrg().getId());
     if (ksdata == null) {
       throw new FaultException(-3, "kickstartProfileNotFound",
               "No Kickstart Profile found with label: " + profileName);
     }
     String host = RhnXmlRpcServer.getServerName();
     KickstartScheduleCommand cmd =
       new KickstartScheduleCommand(Long.valueOf(serverId), ksdata.getId(),
         loggedInUser, new Date(), host);
     ValidatorError ve = cmd.store();
     if (ve != null) {
       throw new FaultException(-2, "provisionError",
               LocalizationService.getInstance().getMessage(ve.getKey()));
     }
     return cmd.getScheduledAction().getId().intValue();
   }
   public
   int provisionSystem(User loggedInUser, Integer serverId, 
                       String profileName, Date earliestDate)
     throws FaultException {
     log.debug("provisionSystem called.");
     Server server = lookupServer(loggedInUser, serverId);
     if (!(server.hasEntitlement(EntitlementManager.MANAGEMENT))) {
       throw new FaultException(-2, "provisionError",
               "System cannot be provisioned");
     }
     KickstartData ksdata =
       KickstartFactory.lookupKickstartDataByLabelAndOrgId(profileName,
         loggedInUser.getOrg().getId());
     if (ksdata == null) {
       throw new FaultException(-3, "kickstartProfileNotFound",
               "No Kickstart Profile found with label: " + profileName);
     }
     String host = RhnXmlRpcServer.getServerName();
     KickstartScheduleCommand cmd =
       new KickstartScheduleCommand(Long.valueOf(serverId), ksdata.getId(),
         loggedInUser, earliestDate, host);
     ValidatorError ve = cmd.store();
     if (ve != null) {
       throw new FaultException(-2, "provisionError",
               LocalizationService.getInstance().getMessage(ve.getKey()));
     }
     return cmd.getScheduledAction().getId().intValue();
   }
   public
   int provisionVirtualGuest(User loggedInUser, Integer sid, 
                             String guestName, String profileName, 
                             Integer memoryMb, Integer vcpus, 
                             Integer storageGb) {
     return provisionVirtualGuest(loggedInUser, sid, guestName, profileName,
              memoryMb, vcpus, storageGb, "");
   }
   public
   int provisionVirtualGuest(User loggedInUser, Integer sid, 
                             String guestName, String profileName, 
                             Integer memoryMb, Integer vcpus, 
                             Integer storageGb, String macAddress) {
     log.debug("provisionVirtualGuest called.");
     lookupServer(loggedInUser, sid);
     KickstartData ksdata =
       KickstartFactory.lookupKickstartDataByLabelAndOrgId(profileName,
         loggedInUser.getOrg().getId());
     if (ksdata == null) {
       throw new FaultException(-3, "kickstartProfileNotFound",
               "No Kickstart Profile found with label: " + profileName);
     }
     ProvisionVirtualInstanceCommand cmd =
       new ProvisionVirtualInstanceCommand(new Long(sid.longValue()),
         ksdata.getId(), loggedInUser, new Date(),
         ConfigDefaults.get().getCobblerHost());
     cmd.setGuestName(guestName);
     cmd.setMemoryAllocation(new Long(memoryMb));
     cmd.setVirtualCpus(new Long(vcpus.toString()));
     cmd.setLocalStorageSize(new Long(storageGb));
     cmd.setMacAddress(macAddress);
     cmd.setFilePath("");
     ValidatorError ve = cmd.store();
     if (ve != null) {
       throw new FaultException(-2, "provisionError",
               LocalizationService.getInstance().getMessage(ve.getKey(),
                 ve.getValues()));
     }
     return 1;
   }
   private
   Server lookupServer(User user, Integer sid) throws NoSuchSystemException {
     return XmlRpcSystemHelper.getInstance().lookupServer(user, sid);
   }
   public
   List<SystemOverview> getId(User loggedInUser, String name) {
     return SystemManager.listSystemsByName(loggedInUser, name);
   }
   public
   Map<String,Object> getName(User loggedInUser, Integer serverId) {
     Server server = lookupServer(loggedInUser, serverId);
     Map<String,Object> name = new HashMap<String,Object>();
     name.put("id", server.getId());
     name.put("name", server.getName());
     name.put("last_checkin", server.getLastCheckin());
     return name;
   }
   public
   Date getRegistrationDate(User loggedInUser, Integer sid) {
     Server server = lookupServer(loggedInUser, sid);
     return server.getCreated();
   }
   public
   List<Channel> listSubscribedChildChannels(User loggedInUser, Integer sid) {
     Server server = lookupServer(loggedInUser, sid);
     Set<Channel> childChannels = server.getChildChannels();
     if (childChannels == null) {
       return new ArrayList<Channel>();
     }
     return new ArrayList<Channel>(childChannels);
   }
   public
   List<SystemOverview> searchByName(User loggedInUser, String regexp) {
     List<SystemOverview> systems =
       SystemManager.systemListShort(loggedInUser, null);
     List<SystemOverview> returnList = new ArrayList<SystemOverview>();
     Pattern pattern = Pattern.compile(regexp, Pattern.CASE_INSENSITIVE);
     for (SystemOverview system : systems) {
       Matcher match = pattern.matcher(system.getName());
       if (match.find()) {
         returnList.add(system);
       }
     }
     return returnList;
   }
   public
   Object[] listAdministrators(User loggedInUser, Integer sid) {
     Server server = lookupServer(loggedInUser, sid);
     return ServerFactory.listAdministrators(server).toArray();
   }
   public
   String getRunningKernel(User loggedInUser, Integer sid) {
     try {
       Server server =
         SystemManager.lookupByIdAndUser(new Long(sid.longValue()),
           loggedInUser);
       if (server.getRunningKernel() != null) {
         return server.getRunningKernel();
       }
       return LocalizationService.getInstance().getMessage("server.runningkernel.unknown");
     } catch (LookupException e) {
       throw new NoSuchSystemException(e);
     } 
   }
   public
   Object[] getEventHistory(User loggedInUser, Integer sid) {
     Server server = lookupServer(loggedInUser, sid);
     List<HistoryEvent> history = ServerFactory.getServerHistory(server);
     return history.toArray();
   }
   public
   Object[] getRelevantErrata(User loggedInUser, Integer sid) {
     Server server = lookupServer(loggedInUser, sid);
     DataResult<ErrataOverview> dr =
       SystemManager.relevantErrata(loggedInUser, server.getId());
     return dr.toArray();
   }
   public
   Object[] getRelevantErrataByType(User loggedInUser, Integer serverId, 
                                    String advisoryType)
     throws FaultException {
     Server server = lookupServer(loggedInUser, serverId);
     DataResult<ErrataOverview> dr =
       SystemManager.relevantErrataByType(loggedInUser, server.getId(),
         advisoryType);
     return dr.toArray();
   }
   public
   Errata[] getUnscheduledErrata(User loggedInUser, Integer sid) {
     Server server = lookupServer(loggedInUser, sid);
     DataResult<Errata> dr =
       SystemManager.unscheduledErrata(loggedInUser, server.getId(), null);
     dr.elaborate();
     return dr.toArray(new Errata[]{  });
   }
   public
   List<Long> scheduleApplyErrata(User loggedInUser, List<Integer> serverIds, 
                                  List<Integer> errataIds) {
     return scheduleApplyErrata(loggedInUser, serverIds, errataIds, null);
   }
   public
   List<Long> scheduleApplyErrata(User loggedInUser, 
                                  List<Integer> serverIdsIn, 
                                  List<Integer> errataIdsIn, 
                                  Date earliestOccurrence) {
     List<Long> serverIds =
       serverIdsIn.stream().map(Integer::longValue).collect(toList());
     List<Long> errataIds =
       errataIdsIn.stream().map(Integer::longValue).collect(toList());
     try {
       return ErrataManager.applyErrataHelper(loggedInUser, serverIds,
                errataIds, earliestOccurrence);
     } catch (com.redhat.rhn.taskomatic.TaskomaticApiException e) {
       throw new TaskomaticApiException(e.getMessage());
     } 
   }
   @Deprecated
   public
   int applyErrata(User loggedInUser, Integer sid, List<Integer> errataIds) {
     scheduleApplyErrata(loggedInUser, sid, errataIds);
     return 1;
   }
   public
   List<Long> scheduleApplyErrata(User loggedInUser, Integer sid, 
                                  List<Integer> errataIds) {
     List<Integer> serverIds = new ArrayList<Integer>();
     serverIds.add(sid);
     return scheduleApplyErrata(loggedInUser, serverIds, errataIds);
   }
   public
   List<Long> scheduleApplyErrata(User loggedInUser, Integer sid, 
                                  List<Integer> errataIds, 
                                  Date earliestOccurrence) {
     List<Integer> serverIds = new ArrayList<Integer>();
     serverIds.add(sid);
     return scheduleApplyErrata(loggedInUser, serverIds, errataIds,
              earliestOccurrence);
   }
   public
   Object[] comparePackages(User loggedInUser, Integer sid1, Integer sid2) {
     Server target = null;
     Server source = null;
     try {
       target =
       SystemManager.lookupByIdAndUser(new Long(sid1.longValue()),
         loggedInUser);
       source =
       SystemManager.lookupByIdAndUser(new Long(sid2.longValue()),
         loggedInUser);
     } catch (LookupException e) {
       throw new NoSuchSystemException();
     } 
     if (!isCompatible(loggedInUser, target, source)) {
       throw new InvalidSystemException();
     }
     DataResult result = null;
     try {
       result =
       ProfileManager.compareServerToServer(new Long(sid1.longValue()),
         new Long(sid2.longValue()), loggedInUser.getOrg().getId(), null);
     } catch (MissingEntitlementException e) {
       throw new com.redhat.rhn.frontend.xmlrpc.MissingEntitlementException();
     } 
     return result.toArray();
   }
   public
   Object getDmi(User loggedInUser, Integer sid) {
     Server server = lookupServer(loggedInUser, sid);
     Dmi dmi = server.getDmi();
     if (dmi == null) {
       return new HashMap<String,String>();
     }
     return dmi;
   }
   public
   Object getCpu(User loggedInUser, Integer sid) {
     Server server = lookupServer(loggedInUser, sid);
     CPU cpu = server.getCpu();
     if (cpu == null) {
       return new HashMap<String,String>();
     }
     return cpu;
   }
   public
   Map<String,Long> getMemory(User loggedInUser, Integer sid) {
     Server server = lookupServer(loggedInUser, sid);
     Map<String,Long> memory = new HashMap<String,Long>();
     memory.put("swap", new Long(server.getSwap()));
     memory.put("ram", new Long(server.getRam()));
     return memory;
   }
   public
   Object[] getDevices(User loggedInUser, Integer sid) {
     Server server = lookupServer(loggedInUser, sid);
     Set<Device> devices = server.getDevices();
     return devices.toArray();
   }
   private
   Long[] schedulePackagesAction(User loggedInUser, List<Integer> sids, 
                                 List<Map<String,Long>> packageMaps, 
                                 Date earliestOccurrence, ActionType acT) {
     List<Long> actionIds = new ArrayList<Long>();
     for (Integer sid : sids) {
       Server server =
         SystemManager.lookupByIdAndUser(new Long(sid.longValue()),
           loggedInUser);
       if (!(SystemManager.hasEntitlement(server.getId(),
               EntitlementManager.MANAGEMENT) || SystemManager.hasEntitlement(
                                                   server.getId(),
                                                   EntitlementManager.SALT))) {
         throw new MissingEntitlementException(EntitlementManager.MANAGEMENT.getHumanReadableLabel() + " or " + 
                 EntitlementManager.SALT.getHumanReadableLabel());
       }
       Action action = null;
       try {
         action =
         ActionManager.schedulePackageAction(loggedInUser, packageMaps, acT,
           earliestOccurrence, server);
       } catch (MissingEntitlementException e) {
         throw new com.redhat.rhn.frontend.xmlrpc.MissingEntitlementException();
       }catch (com.redhat.rhn.taskomatic.TaskomaticApiException e) {
         throw new TaskomaticApiException(e.getMessage());
       } 
       actionIds.add(action.getId());
     }
     return actionIds.toArray(new Long[actionIds.size()]);
   }
   private
   List<Map<String,Long>> packageIdsToMaps(User user, 
                                           List<Integer> packageIds) {
     List<Map<String,Long>> packageMaps = new LinkedList<Map<String,Long>>();
     for (Integer pkgId : packageIds) {
       Map<String,Long> pkgMap = new HashMap<String,Long>();
       Package p =
         PackageManager.lookupByIdAndUser(new Long(pkgId.longValue()), user);
       if (p == null) {
         throw new InvalidPackageException("cannot find package with name " + 
                 pkgId.toString() + " in Satellite database");
       }
       pkgMap.put("name_id", p.getPackageName().getId());
       pkgMap.put("evr_id", p.getPackageEvr().getId());
       pkgMap.put("arch_id", p.getPackageArch().getId());
       packageMaps.add(pkgMap);
     }
     if (packageMaps.isEmpty()) {
       throw new InvalidParameterException("No packages to install/remove.");
     }
     return packageMaps;
   }
   private
   List<Map<String,Long>> packageNevrasToMaps(User user, 
                                              List<Map<String,String>> packageNevraList,
                                              Boolean lookupNevra) {
     List<Map<String,Long>> packageMaps = new LinkedList<Map<String,Long>>();
     for (Map<String,String> packageNevra : packageNevraList) {
       Map<String,Long> pkgMap = new HashMap<String,Long>();
       PackageArch arch =
         PackageFactory.lookupPackageArchByLabel(packageNevra.get("package_arch"));
       String epoch = packageNevra.get("package_epoch");
       if (arch == null) {
         throw new InvalidPackageArchException(packageNevra.get("package_arch"));
       }
       if (epoch != null && epoch.equals("")) {
         epoch = null;
       }
       List<Package> pl =
         PackageFactory.lookupByNevra(user.getOrg(),
           packageNevra.get("package_name"),
           packageNevra.get("package_version"),
           packageNevra.get("package_release"), epoch, arch);
       if (pl == null || pl.size() == 0) {
         PackageName pkgName =
           PackageFactory.lookupPackageName(packageNevra.get("package_name"));
         if (pkgName == null || !lookupNevra) {
           throw new InvalidPackageException(packageNevra.get("package_name"));
         }
         pkgMap.put("name_id", pkgName.getId());
         pkgMap.put("evr_id",
           PackageEvrFactory.lookupOrCreatePackageEvr(epoch,
             packageNevra.get("package_version"),
             packageNevra.get("package_release")).getId());
         pkgMap.put("arch_id", arch.getId());
       } else {
         pkgMap.put("name_id", pl.get(0).getPackageName().getId());
         pkgMap.put("evr_id", pl.get(0).getPackageEvr().getId());
         pkgMap.put("arch_id", pl.get(0).getPackageArch().getId());
       }
       packageMaps.add(pkgMap);
     }
     if (packageMaps.isEmpty()) {
       throw new InvalidParameterException("No packages to install/remove.");
     }
     return packageMaps;
   }
   public
   Long[] schedulePackageInstall(User loggedInUser, List<Integer> sids, 
                                 List<Integer> packageIds, 
                                 Date earliestOccurrence) {
     return schedulePackagesAction(loggedInUser, sids,
              packageIdsToMaps(loggedInUser, packageIds), earliestOccurrence,
              ActionFactory.TYPE_PACKAGES_UPDATE);
   }
   public
   Long schedulePackageInstall(User loggedInUser, final Integer sid, 
                               List<Integer> packageIds, 
                               Date earliestOccurrence) {
     List<Integer> sids = new ArrayList<Integer>();
     sids.add(sid);
     return schedulePackagesAction(loggedInUser, sids,
              packageIdsToMaps(loggedInUser, packageIds), earliestOccurrence,
              ActionFactory.TYPE_PACKAGES_UPDATE)[0];
   }
   public
   Long[] schedulePackageInstallByNevra(User loggedInUser, 
                                        List<Integer> sids, 
                                        List<Map<String,String>> packageNevraList,
                                        Date earliestOccurrence) {
     return schedulePackagesAction(loggedInUser, sids,
              packageNevrasToMaps(loggedInUser, packageNevraList, false),
              earliestOccurrence, ActionFactory.TYPE_PACKAGES_UPDATE);
   }
   public
   Long schedulePackageInstallByNevra(User loggedInUser, final Integer sid, 
                                      List<Map<String,String>> packageNevraList,
                                      Date earliestOccurrence) {
     List<Integer> sids = new ArrayList<Integer>();
     sids.add(sid);
     return schedulePackagesAction(loggedInUser, sids,
              packageNevrasToMaps(loggedInUser, packageNevraList, false),
              earliestOccurrence, ActionFactory.TYPE_PACKAGES_UPDATE)[0];
   }
   public
   Long[] schedulePackageRemove(User loggedInUser, List<Integer> sids, 
                                List<Integer> packageIds, 
                                Date earliestOccurrence) {
     return schedulePackagesAction(loggedInUser, sids,
              packageIdsToMaps(loggedInUser, packageIds), earliestOccurrence,
              ActionFactory.TYPE_PACKAGES_REMOVE);
   }
   public
   int schedulePackageRemove(User loggedInUser, Integer sid, 
                             List<Integer> packageIds, 
                             Date earliestOccurrence) {
     List<Integer> sids = new ArrayList<Integer>();
     sids.add(sid);
     return schedulePackagesAction(loggedInUser, sids,
              packageIdsToMaps(loggedInUser, packageIds), earliestOccurrence,
              ActionFactory.TYPE_PACKAGES_REMOVE)[0].intValue();
   }
   public
   Long[] schedulePackageRemoveByNevra(User loggedInUser, List<Integer> sids, 
                                       List<Map<String,String>> packageNevraList,
                                       Date earliestOccurrence) {
     return schedulePackagesAction(loggedInUser, sids,
              packageNevrasToMaps(loggedInUser, packageNevraList, true),
              earliestOccurrence, ActionFactory.TYPE_PACKAGES_REMOVE);
   }
   public
   int schedulePackageRemoveByNevra(User loggedInUser, final Integer sid, 
                                    List<Map<String,String>> packageNevraList,
                                    Date earliestOccurrence) {
     List<Integer> sids = new ArrayList<Integer>();
     sids.add(sid);
     return schedulePackagesAction(loggedInUser, sids,
              packageNevrasToMaps(loggedInUser, packageNevraList, true),
              earliestOccurrence, ActionFactory.TYPE_PACKAGES_REMOVE)[0].intValue();
   }
   public
   Set<Note> listNotes(User loggedInUser, Integer sid) {
     Server server =
       SystemManager.lookupByIdAndUser(new Long(sid.longValue()),
         loggedInUser);
     return server.getNotes();
   }
   public
   List<Map<String,Object>> listPackagesFromChannel(User loggedInUser, 
                                                    Integer sid, 
                                                    String channelLabel) {
     SystemManager.lookupByIdAndUser(new Long(sid.longValue()), loggedInUser);
     Channel channel =
       ChannelFactory.lookupByLabelAndUser(channelLabel, loggedInUser);
     return SystemManager.packagesFromChannel(sid.longValue(),
              channel.getId());
   }
   public
   Long scheduleHardwareRefresh(User loggedInUser, Integer sid, 
                                Date earliestOccurrence) {
     Server server =
       SystemManager.lookupByIdAndUser(new Long(sid.longValue()),
         loggedInUser);
     try {
       Action a =
         ActionManager.scheduleHardwareRefreshAction(loggedInUser, server,
           earliestOccurrence);
       Action action = ActionFactory.save(a);
       TASKOMATIC_API.scheduleActionExecution(action);
       return action.getId();
     } catch (MissingEntitlementException e) {
       throw new com.redhat.rhn.frontend.xmlrpc.MissingEntitlementException();
     }catch (com.redhat.rhn.taskomatic.TaskomaticApiException e) {
       throw new TaskomaticApiException(e.getMessage());
     } 
   }
   public
   int schedulePackageRefresh(User loggedInUser, Integer sid, 
                              Date earliestOccurrence) {
     Server server =
       SystemManager.lookupByIdAndUser(new Long(sid.longValue()),
         loggedInUser);
     try {
       Action a =
         ActionManager.schedulePackageRefresh(loggedInUser, server,
           earliestOccurrence);
       ActionFactory.save(a);
       return a.getId().intValue();
     } catch (MissingEntitlementException e) {
       throw new com.redhat.rhn.frontend.xmlrpc.MissingEntitlementException();
     }catch (com.redhat.rhn.taskomatic.TaskomaticApiException e) {
       throw new TaskomaticApiException(e.getMessage());
     } 
   }
   public
   Integer scheduleScriptRun(User loggedInUser, String label, 
                             List<Integer> systemIds, String username, 
                             String groupname, Integer timeout, 
                             String script, Date earliest) {
     ScriptActionDetails scriptDetails =
       ActionManager.createScript(username, groupname,
         new Long(timeout.longValue()), script);
     ScriptAction action = null;
     List<Long> servers = new ArrayList<Long>();
     for (Iterator<Integer> sysIter = systemIds.iterator();
          sysIter.hasNext(); ) {
       Integer sidAsInt = sysIter.next();
       Long sid = new Long(sidAsInt.longValue());
       try {
         SystemManager.lookupByIdAndUser(new Long(sid.longValue()),
           loggedInUser);
         servers.add(sid);
       } catch (LookupException e) {
         throw new NoSuchSystemException();
       } 
     }
     try {
       action =
       ActionManager.scheduleScriptRun(loggedInUser, servers, label,
         scriptDetails, earliest);
     } catch (MissingCapabilityException e) {
       throw new com.redhat.rhn.frontend.xmlrpc.MissingCapabilityException();
     }catch (MissingEntitlementException e) {
       throw new com.redhat.rhn.frontend.xmlrpc.MissingEntitlementException();
     }catch (com.redhat.rhn.taskomatic.TaskomaticApiException e) {
       throw new TaskomaticApiException(e.getMessage());
     } 
     return new Integer(action.getId().intValue());
   }
   public
   Integer scheduleScriptRun(User loggedInUser, List<Integer> systemIds, 
                             String username, String groupname, 
                             Integer timeout, String script, Date earliest) {
     return scheduleScriptRun(loggedInUser, null, systemIds, username,
              groupname, timeout, script, earliest);
   }
   public
   Integer scheduleScriptRun(User loggedInUser, Integer sid, String username, 
                             String groupname, Integer timeout, 
                             String script, Date earliest) {
     List<Integer> systemIds = new ArrayList<Integer>();
     systemIds.add(sid);
     return scheduleScriptRun(loggedInUser, null, systemIds, username,
              groupname, timeout, script, earliest);
   }
   public
   Integer scheduleScriptRun(User loggedInUser, String label, Integer sid, 
                             String username, String groupname, 
                             Integer timeout, String script, Date earliest) {
     List<Integer> systemIds = new ArrayList<Integer>();
     systemIds.add(sid);
     return scheduleScriptRun(loggedInUser, label, systemIds, username,
              groupname, timeout, script, earliest);
   }
   public
   Object[] getScriptResults(User loggedInUser, Integer actionId) {
     ScriptRunAction action = lookupScriptRunAction(actionId, loggedInUser);
     ScriptActionDetails details = action.getScriptActionDetails();
     if (details.getResults() == null) {
       return new Object[]{
       
       };
     }
     List<ScriptResult> results = new LinkedList<ScriptResult>();
     for (Iterator<ScriptResult> it = details.getResults().iterator();
          it.hasNext(); ) {
       ScriptResult r = it.next();
       results.add(r);
     }
     return results.toArray();
   }
   public
   Map<String,Object> getScriptActionDetails(User loggedInUser, 
                                             Integer actionId) {
     Map<String,Object> retDetails = new HashMap<String,Object>();
     ScriptRunAction action = lookupScriptRunAction(actionId, loggedInUser);
     ScriptActionDetails details = action.getScriptActionDetails();
     retDetails.put("id", action.getId());
     retDetails.put("content", details.getScriptContents());
     retDetails.put("run_as_user", details.getUsername());
     retDetails.put("run_as_group", details.getGroupname());
     retDetails.put("timeout", details.getTimeout());
     if (details.getResults() != null) {
       List<ScriptResult> results = new LinkedList<ScriptResult>();
       for (Iterator<ScriptResult> it = details.getResults().iterator();
            it.hasNext(); ) {
         ScriptResult r = it.next();
         results.add(r);
       }
       retDetails.put("result", results.toArray());
     }
     return retDetails;
   }
   private
   ScriptRunAction lookupScriptRunAction(Integer actionId, User loggedInUser) {
     ScriptRunAction action = null;
     try {
       action =
       (ScriptRunAction)ActionManager.lookupAction(loggedInUser,
                          new Long(actionId.longValue()));
     } catch (LookupException e) {
       throw new NoSuchActionException(actionId.toString(), e);
     }catch (ClassCastException e) {
       throw new InvalidActionTypeException(e);
     } 
     return action;
   }
   public
   Long scheduleReboot(User loggedInUser, Integer sid, 
                       Date earliestOccurrence) {
     try {
       Server server =
         SystemManager.lookupByIdAndUser(new Long(sid.longValue()),
           loggedInUser);
       Action a =
         ActionManager.scheduleRebootAction(loggedInUser, server,
           earliestOccurrence);
       a = ActionFactory.save(a);
       TASKOMATIC_API.scheduleActionExecution(a);
       return a.getId();
     } catch (com.redhat.rhn.taskomatic.TaskomaticApiException e) {
       throw new TaskomaticApiException(e.getMessage());
     } 
   }
   public
   Object getDetails(User loggedInUser, Integer serverId) {
     Server server = null;
     try {
       server =
       SystemManager.lookupByIdAndUser(new Long(serverId.longValue()),
         loggedInUser);
     } catch (LookupException e) {
       throw new NoSuchSystemException();
     } 
     return server;
   }
   public
   Integer setDetails(User loggedInUser, Integer serverId, 
                      Map<String,Object> details) {
     Set<String> validKeys = new HashSet<String>();
     validKeys.add("profile_name");
     validKeys.add("base_entitlement");
     validKeys.add("auto_errata_update");
     validKeys.add("address1");
     validKeys.add("address2");
     validKeys.add("city");
     validKeys.add("state");
     validKeys.add("country");
     validKeys.add("building");
     validKeys.add("room");
     validKeys.add("rack");
     validKeys.add("description");
     validKeys.add("contact_method");
     validateMap(validKeys, details);
     Server server = null;
     try {
       server =
       SystemManager.lookupByIdAndUser(new Long(serverId.longValue()),
         loggedInUser);
     } catch (LookupException e) {
       throw new NoSuchSystemException();
     } 
     if (details.containsKey("profile_name")) {
       String name = (String)details.get("profile_name");
       name = StringUtils.trim(name);
       validateProfileName(name);
       server.setName(name);
     }
     if (details.containsKey("description")) {
       server.setDescription((String)details.get("description"));
     }
     if (details.containsKey("base_entitlement")) {
       if (!loggedInUser.hasRole(RoleFactory.ORG_ADMIN)) {
         throw new PermissionCheckFailureException();
       }
       String selectedEnt = (String)details.get("base_entitlement");
       Entitlement base = EntitlementManager.getByName(selectedEnt);
       if (base != null) {
         try {
           server.setBaseEntitlement(base);
         } catch (com.redhat.rhn.taskomatic.TaskomaticApiException e) {
           throw new TaskomaticApiException(e.getMessage());
         } 
       } else if (selectedEnt.equals("unentitle")) {
         SystemManager.removeAllServerEntitlements(server.getId());
       }
     }
     if (details.containsKey("auto_errata_update")) {
       Boolean autoUpdate = (Boolean)details.get("auto_errata_update");
       if (autoUpdate.booleanValue()) {
         if (server.getAutoUpdate().equals("N")) {
           try {
             ActionManager.scheduleAllErrataUpdate(loggedInUser, server,
               new Date());
           } catch (com.redhat.rhn.taskomatic.TaskomaticApiException e) {
             throw new TaskomaticApiException(e.getMessage());
           } 
         }
         server.setAutoUpdate("Y");
       } else {
         server.setAutoUpdate("N");
       }
     }
     if (server.getLocation() == null) {
       Location l = new Location();
       server.setLocation(l);
       l.setServer(server);
     }
     if (details.containsKey("address1")) {
       server.getLocation().setAddress1((String)details.get("address1"));
     }
     if (details.containsKey("address2")) {
       server.getLocation().setAddress2((String)details.get("address2"));
     }
     if (details.containsKey("city")) {
       server.getLocation().setCity((String)details.get("city"));
     }
     if (details.containsKey("state")) {
       server.getLocation().setState((String)details.get("state"));
     }
     if (details.containsKey("country")) {
       String country = (String)details.get("country");
       Map<String,String> map =
         LocalizationService.getInstance().availableCountries();
       if (country.length() > 2 || !map.containsValue(country)) {
         throw new UnrecognizedCountryException(country);
       }
       server.getLocation().setCountry(country);
     }
     if (details.containsKey("building")) {
       server.getLocation().setBuilding((String)details.get("building"));
     }
     if (details.containsKey("room")) {
       server.getLocation().setRoom((String)details.get("room"));
     }
     if (details.containsKey("rack")) {
       server.getLocation().setRack((String)details.get("rack"));
     }
     if (details.containsKey("contact_method")) {
       ContactMethod contactMethod =
         ServerFactory.findContactMethodByLabel((String)details.get("contact_method"));
       if (server.asMinionServer().isPresent()) {
         throw new FaultException(-1, "contactMethodChangeNotAllowed",
                 "Changing the contact method is not allowed for Salt systems.");
       } else if (contactMethod != null) {
         server.setContactMethod(contactMethod);
       } else {
         throw new FaultException(-1, "invalidContactMethod",
                 "Invalid contact method: " + details.get("contact_method"));
       }
     }
     return 1;
   }
   public
   Integer setLockStatus(User loggedInUser, Integer serverId, 
                         boolean lockStatus) {
     Server server = null;
     try {
       server =
       SystemManager.lookupByIdAndUser(new Long(serverId.longValue()),
         loggedInUser);
     } catch (LookupException e) {
       throw new NoSuchSystemException();
     } 
     LocalizationService ls = LocalizationService.getInstance();
     if (server.hasEntitlement(EntitlementManager.SALT)) {
       throw new MissingCapabilityException("System locking/unlocking is not available for Salt entitled systems",
               server);
     } else {
       if (lockStatus) {
         if (server.getLock() == null) {
           SystemManager.lockServer(loggedInUser, server,
             ls.getMessage("sdc.details.overview.lock.reason"));
         }
       } else {
         if (server.getLock() != null) {
           SystemManager.unlockServer(loggedInUser, server);
         }
       }
       return 1;
     }
   }
   public
   int addEntitlements(User loggedInUser, Integer serverId, 
                       List<String> entitlements) {
     boolean needsSnapshot = false;
     Entitlement entitlement = null;
     List<Entitlement> entitlementL = new ArrayList<Entitlement>();
     for (String e : entitlements) {
       entitlement = EntitlementManager.getByName(e);
       entitlementL.add(entitlement);
     }
     Server server = null;
     try {
       server =
       SystemManager.lookupByIdAndUser(new Long(serverId.longValue()),
         loggedInUser);
     } catch (LookupException e) {
       throw new NoSuchSystemException();
     } 
     validateEntitlements(entitlementL);
     try {
       List<String> addOnEnts = new LinkedList<String>(entitlements);
       for (Entitlement en : EntitlementManager.getBaseEntitlements()) {
         if (addOnEnts.contains(en.getLabel())) {
           addOnEnts.remove(en.getLabel());
           server.setBaseEntitlement(en);
         }
       }
       if ((server.getBaseEntitlement() == null) && (!addOnEnts.isEmpty())) {
         throw new InvalidEntitlementException("Base entitlement missing");
       }
       for (Iterator<String> it = addOnEnts.iterator(); it.hasNext(); ) {
         Entitlement ent = EntitlementManager.getByName(it.next());
         if (server.hasEntitlement(ent)) {
           log.debug("System " + server.getName() + " already has entitlement: " + 
             ent.getLabel());
           continue;
         }
         if (SystemManager.canEntitleServer(server, ent)) {
           ValidatorResult vr = SystemManager.entitleServer(server, ent);
           needsSnapshot = true;
           if (vr.getErrors().size() > 0) {
             throw new InvalidEntitlementException();
           }
         } else {
           throw new InvalidEntitlementException();
         }
       }
     } catch (com.redhat.rhn.taskomatic.TaskomaticApiException e) {
       throw new TaskomaticApiException(e.getMessage());
     } 
     if (needsSnapshot) {
       SystemManager.snapshotServer(server,
         LocalizationService.getInstance().getMessage("snapshots.entitlements"));
     }
     return 1;
   }
   public
   int removeEntitlements(User loggedInUser, Integer serverId, 
                          List<String> entitlements) {
     boolean needsSnapshot = false;
     List<Entitlement> entitlementL = new ArrayList<Entitlement>();
     Entitlement entitlement;
     for (String e : entitlements) {
       entitlement = EntitlementManager.getByName(e);
       entitlementL.add(entitlement);
     }
     Server server = null;
     try {
       server =
       SystemManager.lookupByIdAndUser(new Long(serverId.longValue()),
         loggedInUser);
     } catch (LookupException e) {
       throw new NoSuchSystemException();
     } 
     validateEntitlements(entitlementL);
     List<Entitlement> baseEnts = new LinkedList<Entitlement>();
     for (Iterator<String> it = entitlements.iterator(); it.hasNext(); ) {
       Entitlement ent = EntitlementManager.getByName(it.next());
       if (ent.isBase()) {
         baseEnts.add(ent);
         continue;
       }
       SystemManager.removeServerEntitlement(server.getId(), ent);
       needsSnapshot = true;
     }
     if (!baseEnts.isEmpty()) {
       SystemManager.removeAllServerEntitlements(server.getId());
       needsSnapshot = true;
     }
     if (needsSnapshot) {
       SystemManager.snapshotServer(server,
         LocalizationService.getInstance().getMessage("snapshots.entitlements"));
     }
     return 1;
   }
   public
   int unentitle(String clientCert) {
     Server server = validateClientCertificate(clientCert);
     if (server.getBaseEntitlement().isPermanent()) {
       throw new InvalidEntitlementException();
     }
     SystemManager.removeAllServerEntitlements(server.getId());
     SystemManager.snapshotServer(server,
       LocalizationService.getInstance().getMessage("snapshots.entitlements"));
     return 1;
   }
   public
   Map transitionDataForSystem(String clientCert)
     throws FileNotFoundException, NoSuchSystemException {
     final File transitionFolder = new File("/usr/share/rhn/transition");
     final String csvUuid = "uuid";
     final String csvSystemId = "system_id";
     final String csvStamp = "timestamp";
     final String csvHostname = "hostname";
     Server server = validateClientCertificate(clientCert);
     String systemIdStr = server.getId().toString();
     Map<String,Object> map = new HashMap<String,Object>();
     map.put(csvStamp, 0);
     File[] files = transitionFolder.listFiles();
     if (files == null) {
       throw new FileNotFoundException("Transition data not available");
     }
     for (File file : files) {
       Pattern pattern = Pattern.compile("id_to_uuid-(\\d+).map");
       Matcher matcher = pattern.matcher(file.getName());
       if (matcher.find()) {
         Integer fileStamp;
         try {
           fileStamp = Integer.parseInt(matcher.group(1));
         } catch (NumberFormatException nfe) {
           log.debug("Skipping " + file.getName());
           break;
         } 
         try {
           BufferedReader br = new BufferedReader(new FileReader(file));
           String line;
           String[] header = null;
           Integer systemIdPos = null, uuidPos = null;
           while ((line = br.readLine()) != null) {
             if (header == null) {
               header = line.split(",");
               for (int i = 0; i < header.length; i++) {
                 if (header[i].equals(csvUuid)) {
                   uuidPos = i;
                 }
                 if (header[i].equals(csvSystemId)) {
                   systemIdPos = i;
                 }
               }
               if (uuidPos == null || systemIdPos == null) {
                 log.warn("Unexpected format of mapping file " + file.getName());
                 break;
               }
               continue;
             }
             String[] record = line.split(",");
             if (record.length <= uuidPos || record.length <= systemIdPos) {
               log.warn("Unexpected format of mapping file " + file.getName());
               break;
             }
             if (record[systemIdPos].equals(systemIdStr) && fileStamp > (Integer)
             map.get(csvStamp)) {
               map.put(csvUuid, record[uuidPos]);
               map.put(csvSystemId, record[systemIdPos]);
               map.put(csvStamp, fileStamp);
               String[] cmd = { "rpm", "--qf=%{NAME}", "-qf",
               file.getAbsolutePath() };
               map.remove(csvHostname);
               SystemCommandExecutor ce = new SystemCommandExecutor();
               if (ce.execute(cmd) == 0) {
                 Pattern rpmPattern =
                   Pattern.compile("system-profile-transition-(\\S+)-" + fileStamp + "\n$");
                 matcher = rpmPattern.matcher(ce.getLastCommandOutput());
                 if (matcher.find()) {
                   map.put(csvHostname, matcher.group(1));
                 }
               }
             }
           }
           br.close();
         } catch (IOException e) {
           log.warn("Cannot read " + file.getName());
         } 
       }
     }
     if (!map.containsKey(csvUuid)) {
       throw new NoSuchSystemException("No transition data for system " + systemIdStr);
     }
     return map;
   }
   public
   Object[] listPackageProfiles(User loggedInUser) {
     DataResult<ProfileOverviewDto> profiles =
       ProfileManager.listProfileOverviews(loggedInUser.getOrg().getId());
     return profiles.toArray();
   }
   public
   int deletePackageProfile(User loggedInUser, Integer profileId) {
     Profile profile =
       ProfileManager.lookupByIdAndOrg(profileId.longValue(),
         loggedInUser.getOrg());
     return ProfileManager.deleteProfile(profile);
   }
   public
   int createPackageProfile(User loggedInUser, Integer sid, 
                            String profileLabel, String desc) {
     Server server =
       SystemManager.lookupByIdAndUser(new Long(sid.longValue()),
         loggedInUser);
     try {
       Profile profile =
         ProfileManager.createProfile(loggedInUser, server, profileLabel,
           desc);
       ProfileManager.copyFrom(server, profile);
     } catch (DuplicateProfileNameException dbe) {
       throw new DuplicateProfileNameException("Package Profile already exists " + "with name: " + profileLabel);
     }catch (NoBaseChannelFoundException nbcfe) {
       throw new ProfileNoBaseChannelException();
     } 
     ProfileFactory.findByNameAndOrgId(profileLabel,
       loggedInUser.getOrg().getId());
     return 1;
   }
   public
   Object[] comparePackageProfile(User loggedInUser, Integer serverId, 
                                  String profileLabel) {
     Long sid = new Long(serverId.longValue());
     SystemManager.lookupByIdAndUser(sid, loggedInUser);
     Profile profile =
       ProfileFactory.findByNameAndOrgId(profileLabel,
         loggedInUser.getOrg().getId());
     if (profile == null) {
       throw new InvalidProfileLabelException(profileLabel);
     }
     DataResult dr =
       ProfileManager.compareServerToProfile(sid, profile.getId(),
         loggedInUser.getOrg().getId(), null);
     return dr.toArray();
   }
   public
   Object[] listOutOfDateSystems(User loggedInUser) {
     DataResult<SystemOverview> list =
       SystemManager.outOfDateList(loggedInUser, null);
     list.elaborate();
     return list.toArray();
   }
   public
   Long scheduleSyncPackagesWithSystem(User loggedInUser, 
                                       Integer targetServerId, 
                                       Integer sourceServerId, 
                                       List<Integer> packageIds, 
                                       Date earliest) {
     Server target = null;
     Server source = null;
     try {
       target =
       SystemManager.lookupByIdAndUser(new Long(targetServerId.longValue()),
         loggedInUser);
       source =
       SystemManager.lookupByIdAndUser(new Long(sourceServerId.longValue()),
         loggedInUser);
     } catch (LookupException e) {
       throw new NoSuchSystemException();
     } 
     if (!isCompatible(loggedInUser, target, source)) {
       throw new InvalidSystemException();
     }
     Set<String> pkgIdCombos = new HashSet<String>();
     for (Iterator<Integer> it = packageIds.iterator(); it.hasNext(); ) {
       Integer i = it.next();
       Package pkg =
         PackageManager.lookupByIdAndUser(i.longValue(), loggedInUser);
       if (pkg != null) {
         StringBuilder idCombo = new StringBuilder();
         idCombo.append(pkg.getPackageName().getId()).append("|");
         if (pkg.getPackageEvr() != null) {
           idCombo.append(pkg.getPackageEvr().getId()).append("|");
         }
         if (pkg.getPackageArch() != null) {
           idCombo.append(pkg.getPackageArch().getId());
         }
         pkgIdCombos.add(idCombo.toString());
       }
     }
     Action action = null;
     try {
       action =
       ProfileManager.syncToSystem(loggedInUser,
         new Long(targetServerId.longValue()),
         new Long(sourceServerId.longValue()), pkgIdCombos, null, earliest);
     } catch (MissingEntitlementException e) {
       throw new com.redhat.rhn.frontend.xmlrpc.MissingEntitlementException();
     }catch (com.redhat.rhn.taskomatic.TaskomaticApiException e) {
       throw new TaskomaticApiException(e.getMessage());
     } 
     if (action == null) {
       throw new InvalidParameterException("No packages to sync");
     }
     return action.getId();
   }
   private
   boolean isCompatible(User user, Server target, Server source) {
     List<Map<String,Object>> compatibleServers =
       SystemManager.compatibleWithServer(user, target);
     boolean found = false;
     for (Iterator<Map<String,Object>> it = compatibleServers.iterator();
          it.hasNext(); ) {
       Map<String,Object> m = it.next();
       Long currentId = (Long)m.get("id");
       if (currentId.longValue() == source.getId().longValue()) {
         found = true;
         break;
       }
     }
     return found;
   }
   public
   List<SystemOverview> listUngroupedSystems(User loggedInUser) {
     return SystemManager.ungroupedList(loggedInUser, null);
   }
   public
   Object getSubscribedBaseChannel(User loggedInUser, Integer sid) {
     Server server = lookupServer(loggedInUser, sid);
     Channel base = server.getBaseChannel();
     if (base == null) {
       return new HashMap<String,String>();
     }
     return base;
   }
   public
   List<SystemOverview> listInactiveSystems(User loggedInUser) {
     return SystemManager.systemListShortInactive(loggedInUser, null);
   }
   public
   List<SystemOverview> listInactiveSystems(User loggedInUser, Integer days) {
     return SystemManager.systemListShortInactive(loggedInUser, days, null);
   }
   public
   User whoRegistered(User loggedInUser, Integer sid) {
     Server server = lookupServer(loggedInUser, sid);
     return server.getCreator();
   }
   public
   List<SystemOverview> listSystemsWithPackage(User loggedInUser, Integer pid) {
     Package pack =
       PackageFactory.lookupByIdAndOrg(pid.longValue(),
         loggedInUser.getOrg());
     if (pack == null) {
       throw new InvalidPackageException(pid.toString());
     }
     return SystemManager.listSystemsWithPackage(loggedInUser,
              pid.longValue());
   }
   public
   List<SystemOverview> listSystemsWithPackage(User loggedInUser, 
                                               String name, String version, 
                                               String release) {
     return SystemManager.listSystemsWithPackage(loggedInUser, name, version,
              release);
   }
   public
   Object[] listPhysicalSystems(User loggedInUser) throws FaultException {
     DataResult<SystemOverview> dr =
       SystemManager.physicalList(loggedInUser, null);
     dr.elaborate();
     return dr.toArray();
   }
   public
   List<SystemOverview> listVirtualHosts(User loggedInUser) {
     return SystemManager.listVirtualHosts(loggedInUser);
   }
   public
   List<VirtualSystemOverview> listVirtualGuests(User loggedInUser, 
                                                 Integer sid) {
     DataResult<VirtualSystemOverview> result =
       SystemManager.virtualGuestsForHostList(loggedInUser, sid.longValue(),
         null);
     result.elaborate();
     return result;
   }
   public
   int setGuestMemory(User loggedInUser, Integer sid, Integer memory) {
     VirtualInstance vi =
       VirtualInstanceFactory.getInstance().lookupByGuestId(loggedInUser.getOrg(),
         sid.longValue());
     Map<String,String> context = new HashMap<String,String>();
     context.put(VirtualizationSetMemoryAction.SET_MEMORY_STRING,
       new Integer(memory * 1024).toString());
     VirtualizationActionCommand cmd =
       new VirtualizationActionCommand(loggedInUser, new Date(),
         ActionFactory.TYPE_VIRTUALIZATION_SET_MEMORY, vi.getHostSystem(),
         vi.getUuid(), context);
     try {
       cmd.store();
       return cmd.getAction().getId().intValue();
     } catch (com.redhat.rhn.taskomatic.TaskomaticApiException e) {
       throw new TaskomaticApiException(e.getMessage());
     } 
   }
   public
   int setGuestCpus(User loggedInUser, Integer sid, Integer numOfCpus) {
     VirtualInstance vi =
       VirtualInstanceFactory.getInstance().lookupByGuestId(loggedInUser.getOrg(),
         sid.longValue());
     Map<String,String> context = new HashMap<String,String>();
     context.put(VirtualizationSetVcpusAction.SET_CPU_STRING,
       numOfCpus.toString());
     VirtualizationActionCommand cmd =
       new VirtualizationActionCommand(loggedInUser, new Date(),
         ActionFactory.TYPE_VIRTUALIZATION_SET_VCPUS, vi.getHostSystem(),
         vi.getUuid(), context);
     try {
       cmd.store();
       return cmd.getAction().getId().intValue();
     } catch (com.redhat.rhn.taskomatic.TaskomaticApiException e) {
       throw new TaskomaticApiException(e.getMessage());
     } 
   }
   public
   int scheduleGuestAction(User loggedInUser, Integer sid, String state, 
                           Date date) {
     VirtualInstance vi =
       VirtualInstanceFactory.getInstance().lookupByGuestId(loggedInUser.getOrg(),
         sid.longValue());
     ActionType action;
     if (state.equals("start")) {
       action = ActionFactory.TYPE_VIRTUALIZATION_START;
     } else if (state.equals("suspend")) {
       action = ActionFactory.TYPE_VIRTUALIZATION_SUSPEND;
     } else if (state.equals("resume")) {
       action = ActionFactory.TYPE_VIRTUALIZATION_RESUME;
     } else if (state.equals("restart")) {
       action = ActionFactory.TYPE_VIRTUALIZATION_REBOOT;
     } else if (state.equals("shutdown")) {
       action = ActionFactory.TYPE_VIRTUALIZATION_SHUTDOWN;
     } else {
       throw new InvalidActionTypeException();
     }
     VirtualizationActionCommand cmd =
       new VirtualizationActionCommand(loggedInUser,
         date == null ? new Date() : date, action, vi.getHostSystem(),
         vi.getUuid(), new HashMap<String,String>());
     try {
       cmd.store();
       return cmd.getAction().getId().intValue();
     } catch (com.redhat.rhn.taskomatic.TaskomaticApiException e) {
       throw new TaskomaticApiException(e.getMessage());
     } 
   }
   public
   int scheduleGuestAction(User loggedInUser, Integer sid, String state) {
     return scheduleGuestAction(loggedInUser, sid, state, null);
   }
   public
   List<String> listActivationKeys(User loggedInUser, Integer serverId) {
     Server server = lookupServer(loggedInUser, serverId);
     DataResult<ActivationKeyDto> result =
       SystemManager.getActivationKeys(server);
     List<String> returnList = new ArrayList<String>();
     for (Iterator itr = result.iterator(); itr.hasNext(); ) {
       ActivationKeyDto key = (ActivationKeyDto)itr.next();
       returnList.add(key.getToken());
     }
     return returnList;
   }
   public
   Object[] getConnectionPath(User loggedInUser, Integer sid)
     throws FaultException {
     Server server = lookupServer(loggedInUser, sid);
     DataResult<ServerPath> dr =
       SystemManager.getConnectionPath(server.getId());
     return dr.toArray();
   }
   private
   SystemRecord getSystemRecordFromClientCert(String clientcert) {
     Server server = validateClientCertificate(clientcert);
     return server.getCobblerObject(null);
   }
   public
   int setupStaticNetwork(String clientcert, Map<String,Object> data) {
     SystemRecord rec = getSystemRecordFromClientCert(clientcert);
     if (rec == null) {
       throw new NoSuchSystemException();
     }
     String device = (String)data.get("device");
     String gateway = (String)data.get("gateway");
     List<String> nameservers = (List<String>)data.get("nameservers");
     String ip = (String)data.get("ip");
     String netmask = (String)data.get("netmask");
     String hostName = (String)data.get("hostname");
     String command =
       KickstartFormatter.makeStaticNetworkCommand(device, ip, gateway,
         nameservers.get(0), netmask, hostName);
     rec.setHostName(hostName);
     rec.setGateway(gateway);
     rec.setNameServers(nameservers);
     Map<String,Object> meta = rec.getKsMeta();
     meta.put(KickstartFormatter.STATIC_NETWORK_VAR, command);
     rec.setKsMeta(meta);
     rec.save();
     return 1;
   }
   public
   int setupStaticNetwork(String clientcert, Map<String,Object> data, 
                          Map<String,Object> data6) {
     SystemRecord rec = getSystemRecordFromClientCert(clientcert);
     if (rec == null) {
       throw new NoSuchSystemException();
     }
     String device = (String)data.get("device");
     String hostName = (String)data.get("hostname");
     List<String> nameservers = (List<String>)data.get("nameservers");
     String ip4 = (String)data.get("ip");
     String nm4 = (String)data.get("netmask");
     String gw4 = (String)data.get("gateway");
     String ip6 = (String)data6.get("ip");
     String nm6 = (String)data6.get("netmask");
     String gw6 = (String)data6.get("gateway");
     Map<String,Object> meta = rec.getKsMeta();
     String ipv6GatewayMeta =
       (String)meta.get(KickstartFormatter.USE_IPV6_GATEWAY);
     boolean preferIpv6Gateway = false;
     if (ipv6GatewayMeta != null && ipv6GatewayMeta.equals("true")) {
       preferIpv6Gateway = true;
     }
     String ksDistro = (String)meta.get(KickstartFormatter.KS_DISTRO);
     String command =
       KickstartFormatter.makeStaticNetworkCommand(device, hostName,
         nameservers.get(0), ip4, nm4, gw4, ip6, nm6, gw6, preferIpv6Gateway,
         ksDistro);
     rec.setHostName(hostName);
     rec.setGateway((preferIpv6Gateway) ? gw6 : gw4);
     rec.setNameServers(nameservers);
     meta.put(KickstartFormatter.STATIC_NETWORK_VAR, command);
     rec.setKsMeta(meta);
     rec.save();
     return 1;
   }
   private
   KickstartData lookupKsData(String label, Org org) {
     return XmlRpcKickstartHelper.getInstance().lookupKsData(label, org);
   }
   public
   int createSystemRecord(User loggedInUser, Integer serverId, String ksLabel) {
     Server server = null;
     try {
       server =
       SystemManager.lookupByIdAndUser(serverId.longValue(), loggedInUser);
     } catch (LookupException e) {
       throw new NoSuchSystemException();
     } 
     if (!(server.hasEntitlement(EntitlementManager.MANAGEMENT))) {
       throw new FaultException(-2, "provisionError",
               "System cannot be provisioned");
     }
     KickstartData ksData = lookupKsData(ksLabel, loggedInUser.getOrg());
     CobblerSystemCreateCommand cmd =
       new CobblerSystemCreateCommand(loggedInUser, server,
         ksData.getCobblerObject(loggedInUser).getName());
     cmd.store();
     return 1;
   }
   public
   int createSystemRecord(User loggedInUser, String sysName, String ksLabel, 
                          String kOptions, String comment, 
                          List<HashMap<String,String>> netDevices) {
     KickstartData ksData = lookupKsData(ksLabel, loggedInUser.getOrg());
     Server server = ServerFactory.createServer();
     server.setName(sysName);
     server.setOrg(loggedInUser.getOrg());
     CobblerUnregisteredSystemCreateCommand cmd;
     cmd =
     new CobblerUnregisteredSystemCreateCommand(loggedInUser, server,
       ksData.getCobblerObject(loggedInUser).getName());
     Set<NetworkInterface> set = new HashSet<NetworkInterface>();
     for (HashMap<String,String> map : netDevices) {
       CobblerNetworkInterface device = cmd.new CobblerNetworkInterface();
       device.setName(map.get("name"));
       device.setIpaddr(map.get("ip"));
       device.setHwaddr(map.get("mac"));
       if (device.isMacValid() || device.isIpValid()) {
         if (device.getName() == null || device.getName().isEmpty()) {
           throw new FaultException(-2, "networkDeviceError",
                   "Network device name needs to be specified, e.g. 'eth0'");
         }
         server.addNetworkInterface(device);
       }
     }
     if (server.getNetworkInterfaces().size() == 0) {
       throw new FaultException(-2, "networkDeviceError",
               "At least one valid network device is needed");
     }
     cmd.setKernelOptions(kOptions);
     cmd.setComment(comment);
     cmd.store();
     return 1;
   }
   public
   Map<String,Object> getVariables(User loggedInUser, Integer serverId) {
     Server server = null;
     try {
       server =
       SystemManager.lookupByIdAndUser(serverId.longValue(), loggedInUser);
     } catch (LookupException e) {
       throw new NoSuchSystemException();
     } 
     if (!(server.hasEntitlement(EntitlementManager.MANAGEMENT))) {
       throw new FaultException(-2, "provisionError",
               "System cannot be provisioned");
     }
     SystemRecord rec =
       SystemRecord.lookupById(CobblerXMLRPCHelper.getConnection(loggedInUser),
         server.getCobblerId());
     if (rec == null) {
       throw new NoSuchCobblerSystemRecordException();
     }
     Map<String,Object> vars = new HashMap<String,Object>();
     vars.put("netboot", rec.isNetbootEnabled());
     vars.put("variables", rec.getKsMeta());
     return vars;
   }
   public
   int setVariables(User loggedInUser, Integer serverId, Boolean netboot, 
                    Map<String,Object> variables) {
     Server server = null;
     try {
       server =
       SystemManager.lookupByIdAndUser(serverId.longValue(), loggedInUser);
     } catch (LookupException e) {
       throw new NoSuchSystemException();
     } 
     if (!(server.hasEntitlement(EntitlementManager.MANAGEMENT))) {
       throw new FaultException(-2, "provisionError",
               "System cannot be provisioned");
     }
     SystemRecord rec =
       SystemRecord.lookupById(CobblerXMLRPCHelper.getConnection(loggedInUser),
         server.getCobblerId());
     if (rec == null) {
       throw new NoSuchCobblerSystemRecordException();
     }
     rec.enableNetboot(netboot);
     rec.setKsMeta(variables);
     rec.save();
     return 1;
   }
   private
   List<Map<String,Object>> transformDuplicate(List<DuplicateSystemGrouping> list,
                                               String propName) {
     List<Map<String,Object>> toRet = new ArrayList<Map<String,Object>>();
     for (DuplicateSystemGrouping b : list) {
       Map<String,Object> map = new HashMap<String,Object>();
       map.put(propName, b.getKey());
       map.put("systems", b.getSystems());
       toRet.add(map);
     }
     return toRet;
   }
   public
   List<Map<String,Object>> listDuplicatesByIp(User loggedInUser) {
     List<DuplicateSystemGrouping> list =
       SystemManager.listDuplicatesByIP(loggedInUser, 0L);
     return transformDuplicate(list, "ip");
   }
   public
   List listDuplicatesByMac(User loggedInUser) {
     List<DuplicateSystemGrouping> list =
       SystemManager.listDuplicatesByMac(loggedInUser, 0L);
     return transformDuplicate(list, "mac");
   }
   public
   List<Map<String,Object>> listDuplicatesByHostname(User loggedInUser) {
     List<DuplicateSystemGrouping> list =
       SystemManager.listDuplicatesByHostname(loggedInUser, 0L);
     return transformDuplicate(list, "hostname");
   }
   public
   Map<String,Integer> getSystemCurrencyMultipliers(User loggedInUser) {
     Map<String,Integer> multipliers = new HashMap<String,Integer>();
     multipliers.put("scCrit", ConfigDefaults.get().getSCCrit());
     multipliers.put("scImp", ConfigDefaults.get().getSCImp());
     multipliers.put("scMod", ConfigDefaults.get().getSCMod());
     multipliers.put("scLow", ConfigDefaults.get().getSCLow());
     multipliers.put("scBug", ConfigDefaults.get().getSCBug());
     multipliers.put("scEnh", ConfigDefaults.get().getSCEnh());
     return multipliers;
   }
   public
   List<Map<String,Long>> getSystemCurrencyScores(User loggedInUser) {
     DataResult<SystemCurrency> dr =
       SystemManager.systemCurrencyList(loggedInUser, null);
     List<Map<String,Long>> l = new ArrayList<Map<String,Long>>();
     for (Iterator<SystemCurrency> it = dr.iterator(); it.hasNext(); ) {
       Map<String,Long> m = new HashMap<String,Long>();
       SystemCurrency s = it.next();
       m.put("sid", s.getId());
       m.put("crit", s.getCritical());
       m.put("imp", s.getImportant());
       m.put("mod", s.getModerate());
       m.put("low", s.getLow());
       m.put("bug", s.getBug());
       m.put("enh", s.getEnhancement());
       m.put("score", s.getScore());
       l.add(m);
     }
     return l;
   }
   public
   String getUuid(User loggedInUser, Integer serverId) {
     Server server = lookupServer(loggedInUser, serverId);
     if (server.isVirtualGuest()) {
       return server.getVirtualInstance().getUuid();
     }
     return "";
   }
   public
   int tagLatestSnapshot(User loggedInUser, Integer serverId, String tagName) {
     Server server = lookupServer(loggedInUser, serverId);
     if (!(server.hasEntitlement(EntitlementManager.MANAGEMENT))) {
       throw new FaultException(-2, "provisionError",
               "System cannot be provisioned");
     }
     List<ServerSnapshot> snps =
       ServerFactory.listSnapshots(loggedInUser.getOrg(), server, null, null);
     if (snps.isEmpty()) {
       SystemManager.snapshotServer(server, "Initial snapshot");
       snps =
       ServerFactory.listSnapshots(loggedInUser.getOrg(), server, null, null);
     }
     if (!snps.get(0).addTag(tagName)) {
       throw new SnapshotTagAlreadyExistsException(tagName);
     }
     return 1;
   }
   public
   int deleteTagFromSnapshot(User loggedInUser, Integer serverId, 
                             String tagName) {
     Server server = lookupServer(loggedInUser, serverId);
     SnapshotTag tag = ServerFactory.lookupSnapshotTagbyName(tagName);
     if (tag == null) {
       throw new NoSuchSnapshotTagException(tagName);
     }
     ServerFactory.removeTagFromSnapshot(server.getId(), tag);
     return 1;
   }
   public
   Object[] listSystemsWithExtraPackages(User loggedInUser) {
     return SystemManager.getExtraPackagesSystems(loggedInUser, null).toArray();
   }
   public
   List<Map<String,Object>> listExtraPackages(User loggedInUser, 
                                              Integer serverId) {
     DataResult<PackageListItem> dr =
       SystemManager.listExtraPackages(new Long(serverId));
     List<Map<String,Object>> returnList =
       new ArrayList<Map<String,Object>>();
     for (Iterator<PackageListItem> itr = dr.iterator(); itr.hasNext(); ) {
       PackageListItem row = itr.next();
       Map<String,Object> pkg = new HashMap<String,Object>();
       pkg.put("name", row.getName());
       pkg.put("version", row.getVersion());
       pkg.put("release", row.getRelease());
       if (row.getEpoch() != null) {
         pkg.put("epoch", row.getEpoch());
       }
       if (row.getArch() != null) {
         pkg.put("arch", row.getArch());
       }
       pkg.put("installtime", row.getInstallTime());
       returnList.add(pkg);
     }
     return returnList;
   }
   public
   int setPrimaryInterface(User loggedInUser, Integer serverId, 
                           String interfaceName)
     throws Exception {
     Server server = lookupServer(loggedInUser, serverId);
     if (!server.existsActiveInterfaceWithName(interfaceName)) {
       throw new NoSuchNetworkInterfaceException("No such network interface: " + interfaceName);
     }
     server.setPrimaryInterfaceWithName(interfaceName);
     return 1;
   }
   public
   int scheduleCertificateUpdate(User loggedInUser, Integer serverId) {
     return scheduleCertificateUpdate(loggedInUser, serverId, new Date());
   }
   public
   int scheduleCertificateUpdate(User loggedInUser, Integer serverId, 
                                 Date date) {
     Server server = lookupServer(loggedInUser, serverId);
     if (server == null) {
       throw new InvalidSystemException();
     }
     Action action = null;
     try {
       action =
       ActionManager.scheduleCertificateUpdate(loggedInUser, server, null);
     } catch (MissingCapabilityException e) {
       throw new com.redhat.rhn.frontend.xmlrpc.MissingCapabilityException();
     }catch (com.redhat.rhn.taskomatic.TaskomaticApiException e) {
       throw new TaskomaticApiException(e.getMessage());
     } 
     return action.getId().intValue();
   }
   public
   int sendOsaPing(User loggedInUser, Integer serverId) {
     Server server = lookupServer(loggedInUser, serverId);
     if (server == null) {
       throw new InvalidSystemException();
     }
     PushClient client = null;
     client = server.getPushClient();
     if (client == null) {
       throw new NoPushClientException();
     }
     client.setLastPingTime(new Date());
     client.setNextActionTime(null);
     SystemManager.storeServer(server);
     return 1;
   }
   public
   Map<String,Object> getOsaPing(User loggedInUser, Integer serverId) {
     Server server = lookupServer(loggedInUser, serverId);
     Map<String,Object> map = new HashMap<String,Object>();
     if (server.getPushClient() != null) {
       if (server.getPushClient().getState().getName() == null) {
         map.put("state", "unknown");
       } else {
         map.put("state", server.getPushClient().getState().getName());
       }
       if (server.getPushClient().getLastMessageTime() == null) {
         map.put("lastMessageTime", new Date(0));
       } else {
         map.put("lastMessageTime",
           server.getPushClient().getLastMessageTime());
       }
       if (server.getPushClient().getLastPingTime() == null) {
         map.put("lastPingTime", new Date(0));
       } else {
         map.put("lastPingTime", server.getPushClient().getLastPingTime());
       }
     } else {
       map.put("state", "unknown");
       map.put("lastMessageTime", new Date(0));
       map.put("lastPingTime", new Date(0));
     }
     return map;
   }
   public
   List<Map<String,Object>> listMigrationTargets(User loggedInUser, 
                                                 Integer serverId) {
     List<Map<String,Object>> returnList =
       new ArrayList<Map<String,Object>>();
     Server server = lookupServer(loggedInUser, serverId);
     SUSEProductSet installedProducts = server.getInstalledProductSet();
     if (installedProducts == null) {
       throw new FaultException(-1, "listMigrationTargetError",
               "Server has no Products installed.");
     }
     ChannelArch arch = server.getServerArch().getCompatibleChannelArch();
     List<SUSEProductSet> migrationTargets =
       DistUpgradeManager.getTargetProductSets(installedProducts, arch,
         loggedInUser);
     for (SUSEProductSet ps : migrationTargets) {
       if (!ps.getIsEveryChannelSynced()) {
         continue;
       }
       Map<String,Object> target = new HashMap<String,Object>();
       target.put("ident", ps.getSerializedProductIDs());
       target.put("friendly", ps.toString());
       returnList.add(target);
     }
     return returnList;
   }
   public
   Long scheduleSPMigration(User loggedInUser, Integer sid, 
                            String baseChannelLabel, 
                            List<String> optionalChildChannels, 
                            boolean dryRun, Date earliest) {
     return scheduleSPMigration(loggedInUser, sid, null, baseChannelLabel,
              optionalChildChannels, dryRun, earliest);
   }
   public
   Long scheduleSPMigration(User loggedInUser, Integer sid, 
                            String targetIdent, String baseChannelLabel, 
                            List<String> optionalChildChannels, 
                            boolean dryRun, Date earliest) {
     Server server = null;
     try {
       server =
       DistUpgradeManager.performServerChecks(sid.longValue(), loggedInUser);
     } catch (DistUpgradeException e) {
       throw new FaultException(-1, "distUpgradeServerError", e.getMessage());
     } 
     Set<Long> channelIDs = null;
     optionalChildChannels.add(baseChannelLabel);
     try {
       channelIDs =
       DistUpgradeManager.performChannelChecks(optionalChildChannels,
         loggedInUser);
     } catch (DistUpgradeException e) {
       throw new FaultException(-1, "distUpgradeChannelError",
               e.getMessage());
     } 
     SUSEProductSet installedProducts = server.getInstalledProductSet();
     ChannelArch arch = server.getServerArch().getCompatibleChannelArch();
     List<SUSEProductSet> targets =
       DistUpgradeManager.getTargetProductSets(installedProducts, arch,
         loggedInUser);
     if (targets.size() > 0) {
       SUSEProductSet targetProducts = null;
       if (StringUtils.isBlank(targetIdent)) {
         targetProducts = targets.get(targets.size() - 1);
       } else {
         for (SUSEProductSet target : targets) {
           String ident = target.getSerializedProductIDs();
           if (ident.equals(targetIdent)) {
             targetProducts = target;
             break;
           }
         }
       }
       if (targetProducts == null) {
         throw new FaultException(-1, "servicePackMigrationNoTarget",
                 "No target found for SP migration");
       }
       if (!targetProducts.getIsEveryChannelSynced()) {
         throw new FaultException(-1, "servicePackMigrationNoTarget",
                 "Target not available, the following channels are not synced: " + 
                 targetProducts.getMissingChannelsMessage());
       }
       EssentialChannelDto baseChannel =
         DistUpgradeManager.getProductBaseChannelDto(targetProducts.getBaseProduct().getId(),
           arch);
       try {
         if (baseChannel != null && baseChannel.getLabel().equals(baseChannelLabel)) {
           List<EssentialChannelDto> channels =
             DistUpgradeManager.getRequiredChannels(targetProducts,
               baseChannel.getId());
           for (EssentialChannelDto channel : channels) {
             channelIDs.add(channel.getId());
           }
           return DistUpgradeManager.scheduleDistUpgrade(loggedInUser,
                    server, targetProducts, channelIDs, dryRun, earliest);
         }
         Map<ClonedChannel,List<Long>> alternatives =
           DistUpgradeManager.getAlternatives(targetProducts, arch,
             loggedInUser);
         for (ClonedChannel clonedBaseChannel : alternatives.keySet()) {
           if (clonedBaseChannel.getLabel().equals(baseChannelLabel)) {
             channelIDs.addAll(alternatives.get(clonedBaseChannel));
             return DistUpgradeManager.scheduleDistUpgrade(loggedInUser,
                      server, targetProducts, channelIDs, dryRun, earliest);
           }
         }
       } catch (com.redhat.rhn.taskomatic.TaskomaticApiException e) {
         throw new TaskomaticApiException(e.getMessage());
       } 
     }
     throw new FaultException(-1, "servicePackMigrationNoTarget",
             "No target found for SP migration");
   }
   public
   Long scheduleDistUpgrade(User loggedInUser, Integer sid, 
                            List<String> channels, boolean dryRun, 
                            Date earliest) {
     Server server = null;
     try {
       server =
       DistUpgradeManager.performServerChecks(sid.longValue(), loggedInUser);
     } catch (DistUpgradeException e) {
       throw new FaultException(-1, "distUpgradeServerError", e.getMessage());
     } 
     Set<Long> channelIDs = null;
     try {
       channelIDs =
       DistUpgradeManager.performChannelChecks(channels, loggedInUser);
       return DistUpgradeManager.scheduleDistUpgrade(loggedInUser, server,
                null, channelIDs, dryRun, earliest);
     } catch (DistUpgradeException e) {
       throw new FaultException(-1, "distUpgradeChannelError",
               e.getMessage());
     }catch (com.redhat.rhn.taskomatic.TaskomaticApiException e) {
       throw new TaskomaticApiException(e.getMessage());
     } 
   }
   public
   Object[] listSuggestedReboot(User loggedInUser) {
     return SystemManager.requiringRebootList(loggedInUser, null).toArray();
   }
   public
   List<SUSEInstalledProduct> getInstalledProducts(User loggedInUser, 
                                                   Integer serverId)
     throws FaultException {
     Server server = lookupServer(loggedInUser, serverId);
     return server.getInstalledProducts().stream().filter(p -> p.getSUSEProduct() != null).map(p -> 
              new SUSEInstalledProduct(p.getName(), p.getVersion(),
                p.getArch().getLabel(), p.getRelease(), p.isBaseproduct(),
                p.getSUSEProduct().getFriendlyName())).collect(Collectors.toList());
   }
   public
   String getKernelLivePatch(User loggedInUser, Integer sid) {
     try {
       Server server =
         SystemManager.lookupByIdAndUser(sid.longValue(), loggedInUser);
       return server.asMinionServer().map(MinionServer::getKernelLiveVersion).orElse("");
     } catch (LookupException e) {
       throw new NoSuchSystemException(e);
     } 
   }
   public
   int bootstrap(User user, String host, Integer sshPort, String sshUser, 
                 String sshPassword, String activationKey, boolean saltSSH) {
     JSONBootstrapHosts input =
       new JSONBootstrapHosts(host, sshPort, sshUser, sshPassword,
         activationKey, null);
     return XmlRpcSystemHelper.getInstance().bootstrap(user, input, saltSSH);
   }
   public
   int bootstrap(User user, String host, Integer sshPort, String sshUser, 
                 String sshPassword, String activationKey, Integer proxyId, 
                 boolean saltSSH) {
     JSONBootstrapHosts input =
       new JSONBootstrapHosts(host, sshPort, sshUser, sshPassword,
         activationKey, proxyId.longValue());
     return XmlRpcSystemHelper.getInstance().bootstrap(user, input, saltSSH);
   }
}