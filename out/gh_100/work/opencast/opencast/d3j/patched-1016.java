// generated by Diff/AST Java Unparser
package org.opencastproject.composer.impl;
import static java.lang.String.format;
import static org.opencastproject.fun.juc.Immutables.list;
import static org.opencastproject.serviceregistry.api.Incidents.NO_DETAILS;
import static org.opencastproject.util.data.Option.none;
import static org.opencastproject.util.data.Option.some;
import static org.opencastproject.util.data.Tuple.tuple;
import org.opencastproject.composer.api.ComposerService;
import org.opencastproject.composer.api.EmbedderEngine;
import org.opencastproject.composer.api.EmbedderEngineFactory;
import org.opencastproject.composer.api.EmbedderException;
import org.opencastproject.composer.api.EncoderEngine;
import org.opencastproject.composer.api.EncoderEngineFactory;
import org.opencastproject.composer.api.EncoderException;
import org.opencastproject.composer.api.EncodingProfile;
import org.opencastproject.composer.api.LaidOutElement;
import org.opencastproject.composer.layout.Dimension;
import org.opencastproject.composer.layout.Layout;
import org.opencastproject.composer.layout.Serializer;
import org.opencastproject.fun.juc.Mutables;
import org.opencastproject.inspection.api.MediaInspectionException;
import org.opencastproject.inspection.api.MediaInspectionService;
import org.opencastproject.job.api.AbstractJobProducer;
import org.opencastproject.job.api.Job;
import org.opencastproject.job.api.JobBarrier;
import org.opencastproject.mediapackage.Attachment;
import org.opencastproject.mediapackage.Catalog;
import org.opencastproject.mediapackage.MediaPackageElement;
import org.opencastproject.mediapackage.MediaPackageElement.Type;
import org.opencastproject.mediapackage.MediaPackageElementBuilder;
import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;
import org.opencastproject.mediapackage.MediaPackageElementParser;
import org.opencastproject.mediapackage.MediaPackageException;
import org.opencastproject.mediapackage.Stream;
import org.opencastproject.mediapackage.Track;
import org.opencastproject.mediapackage.VideoStream;
import org.opencastproject.mediapackage.identifier.IdBuilder;
import org.opencastproject.mediapackage.identifier.IdBuilderFactory;
import org.opencastproject.security.api.OrganizationDirectoryService;
import org.opencastproject.security.api.SecurityService;
import org.opencastproject.security.api.UserDirectoryService;
import org.opencastproject.serviceregistry.api.ServiceRegistry;
import org.opencastproject.serviceregistry.api.ServiceRegistryException;
import org.opencastproject.util.IoSupport;
import org.opencastproject.util.JsonObj;
import org.opencastproject.util.LoadUtil;
import org.opencastproject.util.MimeTypes;
import org.opencastproject.util.NotFoundException;
import org.opencastproject.util.data.Collections;
import org.opencastproject.util.data.Option;
import org.opencastproject.util.data.Tuple;
import org.opencastproject.workspace.api.Workspace;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.osgi.framework.BundleContext;
import org.osgi.service.cm.ConfigurationException;
import org.osgi.service.cm.ManagedService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Dictionary;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
public
class ComposerServiceImpl extends AbstractJobProducer
  implements ComposerService, ManagedService
{
   private static final int WORKSPACE_GET_IO_EXCEPTION = 1;
   private static final int WORKSPACE_GET_NOT_FOUND = 2;
   private static final int WORKSPACE_PUT_COLLECTION_IO_EXCEPTION = 3;
   private static final int PROFILE_NOT_FOUND = 4;
   private static final int ENCODER_ENGINE_NOT_FOUND = 5;
   private static final int EMBEDDER_ENGINE_NOT_FOUND = 6;
   private static final int ENCODING_FAILED = 7;
   private static final int TRIMMING_FAILED = 8;
   private static final int COMPOSITE_FAILED = 9;
   private static final int CONCAT_FAILED = 10;
   private static final int CONCAT_LESS_TRACKS = 11;
   private static final int CONCAT_NO_DIMENSION = 12;
   private static final int IMAGE_TO_VIDEO_FAILED = 13;
   private static final int CONVERT_IMAGE_FAILED = 14;
   private static final int IMAGE_EXTRACTION_FAILED = 15;
   private static final int IMAGE_EXTRACTION_UNKNOWN_DURATION = 16;
   private static final int IMAGE_EXTRACTION_TIME_OUTSIDE_DURATION = 17;
   private static final int IMAGE_EXTRACTION_NO_VIDEO = 18;
   private static final int CAPTION_EMBEDD_FAILED = 19;
   private static final int CAPTION_NO_VIDEO = 20;
   private static final int CAPTION_NO_LANGUAGE = 21;
   private static final int WATERMARK_NOT_FOUND = 22;
   private static final int NO_STREAMS = 23;
   private static final Logger logger =
     LoggerFactory.getLogger(ComposerServiceImpl.class);
   public static final String COLLECTION = "composer";
   public static final float DEFAULT_CAPTION_JOB_LOAD = 1.0f;
   public static final String CAPTION_JOB_LOAD_KEY =
     "job.load.caption.embed";
   private float captionJobLoad = DEFAULT_CAPTION_JOB_LOAD;
   private
   enum Operation
   {
      Caption, Encode, Image, ImageConversion, Mux, Trim, Watermark, 
      Composite, Concat, ImageToVideo, ParallelEncode
   }
   private EncodingProfileScanner profileScanner = null;
   private MediaInspectionService inspectionService = null;
   private Workspace workspace = null;
   private ServiceRegistry serviceRegistry;
   private EncoderEngineFactory encoderEngineFactory;
   private EmbedderEngineFactory embedderEngineFactory;
   protected OrganizationDirectoryService organizationDirectoryService =
     null;
   private final IdBuilder idBuilder =
     IdBuilderFactory.newInstance().newIdBuilder();
   protected SecurityService securityService = null;
   protected UserDirectoryService userDirectoryService = null;
   public
   ComposerServiceImpl() {
     super(JOB_TYPE);
   }
   void activate(BundleContext ctx) {
     logger.info("Activating composer service");
   }
   @Override
   public
   Job encode(Track sourceTrack, String profileId)
     throws EncoderException, MediaPackageException {
     try {
       return serviceRegistry.createJob(JOB_TYPE,
                Operation.Encode.toString(),
                Arrays.asList(MediaPackageElementParser.getAsXml(sourceTrack),
                  profileId));
     } catch (ServiceRegistryException e) {
       throw new EncoderException("Unable to create a job", e);
     } 
   }
   protected
   Option<Track> encode(final Job job, Track videoTrack, Track audioTrack, 
                        String profileId, Map<String,String> properties)
     throws EncoderException, MediaPackageException {
     if (job == null)
       throw new IllegalArgumentException("The Job parameter must not be null");
     final String targetTrackId = idBuilder.createNew().toString();
     try {
       final File audioFile;
       if (audioTrack == null) {
         audioFile = null;
       } else {
         try {
           audioFile = workspace.get(audioTrack.getURI());
         } catch (NotFoundException e) {
           incident().recordFailure(job, WORKSPACE_GET_NOT_FOUND, e,
             getWorkspaceMediapackageParams("audio", Type.Track,
               audioTrack.getURI()),
             NO_DETAILS);
           throw new EncoderException("Requested audio track " + audioTrack + " is not found");
         }catch (IOException e) {
           incident().recordFailure(job, WORKSPACE_GET_IO_EXCEPTION, e,
             getWorkspaceMediapackageParams("audio", Type.Track,
               audioTrack.getURI()),
             NO_DETAILS);
           throw new EncoderException("Unable to access audio track " + audioTrack);
         } 
       }
       final File videoFile;
       if (videoTrack == null) {
         videoFile = null;
       } else {
         try {
           videoFile = workspace.get(videoTrack.getURI());
         } catch (NotFoundException e) {
           incident().recordFailure(job, WORKSPACE_GET_NOT_FOUND, e,
             getWorkspaceMediapackageParams("video", Type.Track,
               audioTrack.getURI()),
             NO_DETAILS);
           throw new EncoderException("Requested video track " + audioTrack + " is not found");
         }catch (IOException e) {
           incident().recordFailure(job, WORKSPACE_GET_IO_EXCEPTION, e,
             getWorkspaceMediapackageParams("video", Type.Track,
               audioTrack.getURI()),
             NO_DETAILS);
           throw new EncoderException("Unable to access video track " + audioTrack);
         } 
       }
       final EncodingProfile profile = getProfile(job, profileId);
       final EncoderEngine encoderEngine = getEncoderEngine(job, profile);
       if (audioTrack != null && videoTrack != null)
         logger.info(format("Muxing audio track %s and video track %s into %s",
                       audioTrack.getIdentifier(),
                       videoTrack.getIdentifier(), targetTrackId)); else if (audioTrack == null)
         logger.info(format("Encoding video track %s to %s using profile '%s'",
                       videoTrack.getIdentifier(), targetTrackId, profileId)); else if (videoTrack == null)
         logger.info(format("Encoding audio track %s to %s using profile '%s'",
                       audioTrack.getIdentifier(), targetTrackId, profileId));
       Option<File> output;
       try {
         output =
         encoderEngine.mux(audioFile, videoFile, profile, properties);
       } catch (EncoderException e) {
         Map<String,String> params = new HashMap<String,String>();
         if (audioFile != null) {
           params.put("audio", audioTrack.getURI().toString());
         } else {
           params.put("audio", "EMPTY");
         }
         if (videoFile != null) {
           params.put("video", videoTrack.getURI().toString());
         } else {
           params.put("video", "EMPTY");
         }
         params.put("profile", profile.getIdentifier());
         if (properties != null) {
           params.put("properties", properties.toString());
         } else {
           params.put("properties", "EMPTY");
         }
         incident().recordFailure(job, ENCODING_FAILED, e, params,
           detailsFor(e, encoderEngine));
         throw e;
       } 
       if (output.isNone() || !output.get().exists() || output.get().length() == 0)
         return none();
       URI workspaceURI = putToCollection(job, output.get(), "encoded file");
       Job inspectionJob = inspect(job, workspaceURI);
       Track inspectedTrack =
         (Track)MediaPackageElementParser.getFromXml(inspectionJob.getPayload());
       inspectedTrack.setIdentifier(targetTrackId);
       if (profile.getMimeType() != null)
         inspectedTrack.setMimeType(MimeTypes.parseMimeType(profile.getMimeType()));
       return some(inspectedTrack);
     } catch (Exception e) {
       logger.warn("Error encoding " + videoTrack + " and " + audioTrack, e);
       if (e instanceof EncoderException) {
         throw (EncoderException)e;
       } else {
         throw new EncoderException(e);
       }
     } 
   }
   protected
   List<Track> parralelEncode(Job job, Track mediaTrack, String profileId, 
                              Map<String,String> properties)
     throws EncoderException, MediaPackageException {
     if (job == null) {
       throw new EncoderException("The Job parameter must not be null");
     }
     try {
       final File mediaFile;
       if (mediaTrack == null) {
         mediaFile = null;
       } else {
         try {
           mediaFile = workspace.get(mediaTrack.getURI());
         } catch (NotFoundException e) {
           throw new EncoderException("Requested media track " + mediaTrack + " is not found");
         }catch (IOException e) {
           throw new EncoderException("Unable to access media track " + mediaTrack);
         } 
       }
       final EncodingProfile profile = profileScanner.getProfile(profileId);
       if (profile == null) {
         throw new EncoderException(null,
                 "Profile '" + profileId + " is unknown");
       }
       final EncoderEngine encoderEngine =
         encoderEngineFactory.newEncoderEngine(profile);
       if (encoderEngine == null) {
         throw new EncoderException(null,
                 "No encoder engine available for profile '" + profileId + "'");
       }
       LinkedList<Track> encodedTracks = new LinkedList<Track>();
       int i = 0;
       for (File encodingOutput : encoderEngine.parallelEncode(mediaFile,
                                    profile, properties)) {
         URI returnURL = null;
         InputStream in = null;
         final String targetTrackId = idBuilder.createNew().toString();
         try {
           in = new FileInputStream(encodingOutput);
           returnURL =
           workspace.putInCollection(COLLECTION,
             job.getId() + "-" + i + "." + FilenameUtils.getExtension(
                                             encodingOutput.getAbsolutePath()),
             in);
           logger.info("Copied the encoded file to the workspace at {}",
             returnURL);
           if (encodingOutput.delete()) {
             logger.info("Deleted the local copy of the encoded file at {}",
               encodingOutput.getAbsolutePath());
           } else {
             logger.warn("Unable to delete the encoding output at {}",
               encodingOutput);
           }
         } catch (Exception e) {
           throw new EncoderException("Unable to put the encoded file into the workspace",
                   e);
         } finally{
           IOUtils.closeQuietly(in);
         } 
         Job inspectionJob = null;
         try {
           inspectionJob = inspectionService.inspect(returnURL);
           JobBarrier barrier =
             new JobBarrier(job, serviceRegistry, inspectionJob);
           if (!barrier.waitForJobs().isSuccess()) {
             throw new EncoderException("Media inspection of " + returnURL + " failed");
           }
         } catch (MediaInspectionException e) {
           throw new EncoderException("Media inspection of " + returnURL + " failed",
                   e);
         } 
         Track inspectedTrack =
           (Track)MediaPackageElementParser.getFromXml(inspectionJob.getPayload());
         inspectedTrack.setIdentifier(targetTrackId);
         List<String> tags = profile.getTags();
         if (tags.size() > 0) {
           for (int j = 0; j < tags.size(); j++) {
             if (encodingOutput.getName().endsWith(profile.getSuffix(
                                                     tags.get(j))))
               inspectedTrack.addTag(tags.get(j));
           }
         }
         encodedTracks.add(inspectedTrack);
         i++;
       }
       return encodedTracks;
     } catch (Exception e) {
       logger.warn("Error encoding " + mediaTrack, e);
       if (e instanceof EncoderException) {
         throw (EncoderException)e;
       } else {
         throw new EncoderException(e);
       }
     } 
   }
   @Override
   public
   Job parallelEncode(Track sourceTrack, String profileId)
     throws EncoderException, MediaPackageException {
     try {
       logger.info("Starting parallel encode with profile {} ", profileId);
       return serviceRegistry.createJob(JOB_TYPE,
                Operation.ParallelEncode.toString(),
                Arrays.asList(MediaPackageElementParser.getAsXml(sourceTrack),
                  profileId));
     } catch (ServiceRegistryException e) {
       throw new EncoderException("Unable to create a job", e);
     } 
   }
   @Override
   public
   Job trim(final Track sourceTrack, final String profileId, 
            final long start, final long duration)
     throws EncoderException, MediaPackageException {
     try {
       return serviceRegistry.createJob(JOB_TYPE, Operation.Trim.toString(),
                Arrays.asList(MediaPackageElementParser.getAsXml(sourceTrack),
                  profileId, Long.toString(start), Long.toString(duration)));
     } catch (ServiceRegistryException e) {
       throw new EncoderException("Unable to create a job", e);
     } 
   }
   protected
   Option<Track> trim(Job job, Track sourceTrack, String profileId, 
                      long start, long duration)
     throws EncoderException {
     try {
       String targetTrackId = idBuilder.createNew().toString();
       final File trackFile;
       try {
         trackFile = workspace.get(sourceTrack.getURI());
       } catch (NotFoundException e) {
         incident().recordFailure(job, WORKSPACE_GET_NOT_FOUND, e,
           getWorkspaceMediapackageParams("source", Type.Track,
             sourceTrack.getURI()),
           NO_DETAILS);
         throw new EncoderException("Requested track " + sourceTrack + " is not found");
       }catch (IOException e) {
         incident().recordFailure(job, WORKSPACE_GET_IO_EXCEPTION, e,
           getWorkspaceMediapackageParams("source", Type.Track,
             sourceTrack.getURI()),
           NO_DETAILS);
         throw new EncoderException("Unable to access track " + sourceTrack);
       } 
       final EncodingProfile profile = getProfile(job, profileId);
       final EncoderEngine encoderEngine = getEncoderEngine(job, profile);
       Option<File> output;
       try {
         output =
         encoderEngine.trim(trackFile, profile, start, duration, null);
       } catch (EncoderException e) {
         Map<String,String> params = new HashMap<String,String>();
         params.put("track", sourceTrack.getURI().toString());
         params.put("profile", profile.getIdentifier());
         params.put("start", Long.toString(start));
         params.put("duration", Long.toString(duration));
         incident().recordFailure(job, TRIMMING_FAILED, e, params,
           detailsFor(e, encoderEngine));
         throw e;
       } 
       if (output.isNone() || !output.get().exists() || output.get().length() == 0)
         return none();
       URI workspaceURI = putToCollection(job, output.get(), "trimmed file");
       Job inspectionJob = inspect(job, workspaceURI);
       Track inspectedTrack =
         (Track)MediaPackageElementParser.getFromXml(inspectionJob.getPayload());
       inspectedTrack.setIdentifier(targetTrackId);
       return some(inspectedTrack);
     } catch (Exception e) {
       logger.warn("Error trimming " + sourceTrack, e);
       if (e instanceof EncoderException) {
         throw (EncoderException)e;
       } else {
         throw new EncoderException(e);
       }
     } 
   }
   @Override
   public
   Job mux(Track videoTrack, Track audioTrack, String profileId)
     throws EncoderException, MediaPackageException {
     try {
       return serviceRegistry.createJob(JOB_TYPE, Operation.Mux.toString(),
                Arrays.asList(MediaPackageElementParser.getAsXml(videoTrack),
                  MediaPackageElementParser.getAsXml(audioTrack), profileId));
     } catch (ServiceRegistryException e) {
       throw new EncoderException("Unable to create a job", e);
     } 
   }
   protected
   Option<Track> mux(Job job, Track videoTrack, Track audioTrack, 
                     String profileId)
     throws EncoderException, MediaPackageException {
     return encode(job, videoTrack, audioTrack, profileId, null);
   }
   @Override
   public
   Job composite(Dimension compositeTrackSize, 
                 LaidOutElement<Track> upperTrack, 
                 LaidOutElement<Track> lowerTrack, 
                 Option<LaidOutElement<Attachment>> watermark, 
                 String profileId, String background)
     throws EncoderException, MediaPackageException {
     List<String> arguments = new ArrayList<String>();
     arguments.add(0,
       MediaPackageElementParser.getAsXml(lowerTrack.getElement()));
     arguments.add(1, Serializer.json(lowerTrack.getLayout()).toJson());
     arguments.add(2,
       MediaPackageElementParser.getAsXml(upperTrack.getElement()));
     arguments.add(3, Serializer.json(upperTrack.getLayout()).toJson());
     arguments.add(4, Serializer.json(compositeTrackSize).toJson());
     arguments.add(5, profileId);
     arguments.add(6, background);
     if (watermark.isSome()) {
       LaidOutElement<Attachment> watermarkLaidOutElement = watermark.get();
       arguments.add(7,
         MediaPackageElementParser.getAsXml(watermarkLaidOutElement.getElement()));
       arguments.add(8,
         Serializer.json(watermarkLaidOutElement.getLayout()).toJson());
     }
     try {
       return serviceRegistry.createJob(JOB_TYPE,
                Operation.Composite.toString(), arguments);
     } catch (ServiceRegistryException e) {
       throw new EncoderException("Unable to create composite job", e);
     } 
   }
   protected
   Option<Track> composite(Job job, Dimension compositeTrackSize, 
                           LaidOutElement<Track> lowerLaidOutElement, 
                           LaidOutElement<Track> upperLaiedOutElement, 
                           Option<LaidOutElement<Attachment>> watermarkOption,
                           String profileId, String backgroundColor)
     throws EncoderException, MediaPackageException {
     if (job == null)
       throw new EncoderException("The Job parameter must not be null");
     if (compositeTrackSize == null)
       throw new EncoderException("The composite track size parameter must not be null");
     if (lowerLaidOutElement == null)
       throw new EncoderException("The lower laid out element parameter must not be null");
     if (upperLaiedOutElement == null)
       throw new EncoderException("The upper laid out element parameter must not be null");
     if (watermarkOption == null)
       throw new EncoderException("The optional watermark laid out element parameter must not be null");
     if (profileId == null)
       throw new EncoderException("The profileId parameter must not be null");
     if (backgroundColor == null)
       throw new EncoderException("The background color parameter must not be null");
     final EncodingProfile profile = getProfile(job, profileId);
     final EncoderEngine encoderEngine = getEncoderEngine(job, profile);
     final String targetTrackId = idBuilder.createNew().toString();
     try {
       final File lowerVideoFile;
       try {
         lowerVideoFile =
         workspace.get(lowerLaidOutElement.getElement().getURI());
       } catch (NotFoundException e) {
         incident().recordFailure(job, WORKSPACE_GET_NOT_FOUND, e,
           getWorkspaceMediapackageParams("lower video", Type.Track,
             lowerLaidOutElement.getElement().getURI()),
           NO_DETAILS);
         throw new EncoderException("Requested lower video track " + 
                 lowerLaidOutElement.getElement() + " is not found");
       }catch (IOException e) {
         incident().recordFailure(job, WORKSPACE_GET_IO_EXCEPTION, e,
           getWorkspaceMediapackageParams("lower video", Type.Track,
             lowerLaidOutElement.getElement().getURI()),
           NO_DETAILS);
         throw new EncoderException("Unable to access lower video track " + 
                 lowerLaidOutElement.getElement());
       } 
       final File upperVideoFile;
       try {
         upperVideoFile =
         workspace.get(upperLaiedOutElement.getElement().getURI());
       } catch (NotFoundException e) {
         incident().recordFailure(job, WORKSPACE_GET_NOT_FOUND, e,
           getWorkspaceMediapackageParams("upper video", Type.Track,
             upperLaiedOutElement.getElement().getURI()),
           NO_DETAILS);
         throw new EncoderException("Requested upper video track " + 
                 upperLaiedOutElement.getElement() + " is not found");
       }catch (IOException e) {
         incident().recordFailure(job, WORKSPACE_GET_IO_EXCEPTION, e,
           getWorkspaceMediapackageParams("upper video", Type.Track,
             upperLaiedOutElement.getElement().getURI()),
           NO_DETAILS);
         throw new EncoderException("Unable to access upper video track " + 
                 upperLaiedOutElement.getElement());
       } 
       File watermarkFile = null;
       if (watermarkOption.isSome()) {
         try {
           watermarkFile =
           workspace.get(watermarkOption.get().getElement().getURI());
         } catch (NotFoundException e) {
           incident().recordFailure(job, WORKSPACE_GET_NOT_FOUND, e,
             getWorkspaceMediapackageParams("watermark image",
               Type.Attachment, watermarkOption.get().getElement().getURI()),
             NO_DETAILS);
           throw new EncoderException("Requested watermark image " + 
                   watermarkOption.get().getElement() + " is not found");
         }catch (IOException e) {
           incident().recordFailure(job, WORKSPACE_GET_IO_EXCEPTION, e,
             getWorkspaceMediapackageParams("watermark image",
               Type.Attachment, watermarkOption.get().getElement().getURI()),
             NO_DETAILS);
           throw new EncoderException("Unable to access right watermark image " + 
                   watermarkOption.get().getElement());
         } 
         logger.info(format("Composing lower video track %s and upper video track %s including watermark %s into %s",
                       lowerLaidOutElement.getElement().getIdentifier(),
                       upperLaiedOutElement.getElement().getIdentifier(),
                       watermarkOption.get().getElement().getIdentifier(),
                       targetTrackId));
       } else {
         logger.info(format("Composing lower video track %s and upper video track %s into %s",
                       lowerLaidOutElement.getElement().getIdentifier(),
                       upperLaiedOutElement.getElement().getIdentifier(),
                       targetTrackId));
       }
       String compositeCommand =
         buildCompositeCommand(compositeTrackSize, lowerLaidOutElement,
           upperLaiedOutElement, watermarkOption, upperVideoFile,
           watermarkFile, backgroundColor);
       Map<String,String> properties = new HashMap<String,String>();
       properties.put("compositeCommand", compositeCommand);
       Option<File> output;
       try {
         output =
         encoderEngine.mux(upperVideoFile, lowerVideoFile, profile,
           properties);
       } catch (EncoderException e) {
         Map<String,String> params = new HashMap<String,String>();
         params.put("upper",
           upperLaiedOutElement.getElement().getURI().toString());
         params.put("lower",
           lowerLaidOutElement.getElement().getURI().toString());
         if (watermarkFile != null)
           params.put("watermark",
             watermarkOption.get().getElement().getURI().toString());
         params.put("profile", profile.getIdentifier());
         params.put("properties", properties.toString());
         incident().recordFailure(job, COMPOSITE_FAILED, e, params,
           detailsFor(e, encoderEngine));
         throw e;
       } 
       if (output.isNone() || !output.get().exists() || output.get().length() == 0)
         return none();
       URI workspaceURI =
         putToCollection(job, output.get(), "compound file");
       Job inspectionJob = inspect(job, workspaceURI);
       Track inspectedTrack =
         (Track)MediaPackageElementParser.getFromXml(inspectionJob.getPayload());
       inspectedTrack.setIdentifier(targetTrackId);
       if (profile.getMimeType() != null)
         inspectedTrack.setMimeType(MimeTypes.parseMimeType(profile.getMimeType()));
       return some(inspectedTrack);
     } catch (Exception e) {
       logger.warn("Error composing " + lowerLaidOutElement.getElement() + " and " + 
         upperLaiedOutElement.getElement(), e);
       if (e instanceof EncoderException) {
         throw (EncoderException)e;
       } else {
         throw new EncoderException(e);
       }
     } 
   }
   @Override
   public
   Job concat(String profileId, Dimension outputDimension, Track... tracks)
     throws EncoderException, MediaPackageException {
     ArrayList<String> arguments = new ArrayList<String>();
     arguments.add(0, profileId);
     if (outputDimension != null) {
       arguments.add(1, Serializer.json(outputDimension).toJson());
     } else {
       arguments.add(1, "");
     }
     for (int i = 0; i < tracks.length; i++) {
       arguments.add(i + 2, MediaPackageElementParser.getAsXml(tracks[i]));
     }
     try {
       return serviceRegistry.createJob(JOB_TYPE,
                Operation.Concat.toString(), arguments);
     } catch (ServiceRegistryException e) {
       throw new EncoderException("Unable to create concat job", e);
     } 
   }
   protected
   Option<Track> concat(Job job, List<Track> tracks, String profileId, 
                        Dimension outputDimension)
     throws EncoderException, MediaPackageException {
     if (job == null)
       throw new EncoderException("The job parameter must not be null");
     if (tracks == null)
       throw new EncoderException("The track parameter must not be null");
     if (profileId == null)
       throw new EncoderException("The profile id parameter must not be null");
     if (tracks.size() < 2) {
       Map<String,String> params = new HashMap<String,String>();
       params.put("tracks-size", Integer.toString(tracks.size()));
       params.put("tracks", StringUtils.join(tracks, ","));
       incident().recordFailure(job, CONCAT_LESS_TRACKS, params);
       throw new EncoderException("The track parameter must at least have two tracks present");
     }
     boolean onlyAudio = true;
     for (Track t : tracks) {
       if (t.hasVideo()) {
         onlyAudio = false;
         break;
       }
     }
     if (!onlyAudio && outputDimension == null) {
       Map<String,String> params = new HashMap<String,String>();
       params.put("tracks", StringUtils.join(tracks, ","));
       incident().recordFailure(job, CONCAT_NO_DIMENSION, params);
       throw new EncoderException("The output dimension id parameter must not be null when concatenating video");
     }
     final EncodingProfile profile = getProfile(job, profileId);
     InputStream in = null;
     final String targetTrackId = idBuilder.createNew().toString();
     try {
       List<File> trackFiles = new ArrayList<File>();
       int i = 0;
       for (Track track : tracks) {
         if (!track.hasAudio() && !track.hasVideo()) {
           Map<String,String> params = new HashMap<String,String>();
           params.put("track-id", track.getIdentifier());
           params.put("track-url", track.getURI().toString());
           incident().recordFailure(job, NO_STREAMS, params);
           throw new EncoderException("Track has no audio or video stream available: " + track);
         }
         try {
           trackFiles.add(i++, workspace.get(track.getURI()));
         } catch (NotFoundException e) {
           incident().recordFailure(job, WORKSPACE_GET_NOT_FOUND, e,
             getWorkspaceMediapackageParams("concat", Type.Track,
               track.getURI()),
             NO_DETAILS);
           throw new EncoderException("Requested track " + track + " is not found");
         }catch (IOException e) {
           incident().recordFailure(job, WORKSPACE_GET_IO_EXCEPTION, e,
             getWorkspaceMediapackageParams("concat", Type.Track,
               track.getURI()),
             NO_DETAILS);
           throw new EncoderException("Unable to access track " + track);
         } 
       }
       final EncoderEngine encoderEngine = getEncoderEngine(job, profile);
       if (onlyAudio) {
         logger.info(format("Concatenating audio tracks %s into %s",
                       trackFiles, targetTrackId));
       } else {
         logger.info(format("Concatenating video tracks %s into %s",
                       trackFiles, targetTrackId));
       }
       String concatCommand =
         buildConcatCommand(onlyAudio, outputDimension, trackFiles, tracks);
       Map<String,String> properties = new HashMap<String,String>();
       properties.put("concatCommand", concatCommand);
       Option<File> output;
       try {
         output =
         encoderEngine.encode(trackFiles.get(0), profile, properties);
       } catch (EncoderException e) {
         Map<String,String> params = new HashMap<String,String>();
         List<String> trackList = new ArrayList<String>();
         for (Track t : tracks) {
           trackList.add(t.getURI().toString());
         }
         params.put("tracks", StringUtils.join(trackList, ","));
         params.put("profile", profile.getIdentifier());
         params.put("properties", properties.toString());
         incident().recordFailure(job, CONCAT_FAILED, e, params,
           detailsFor(e, encoderEngine));
         throw e;
       } 
       if (output.isNone() || !output.get().exists() || output.get().length() == 0)
         return none();
       URI workspaceURI =
         putToCollection(job, output.get(), "concatenated file");
       Job inspectionJob = inspect(job, workspaceURI);
       Track inspectedTrack =
         (Track)MediaPackageElementParser.getFromXml(inspectionJob.getPayload());
       inspectedTrack.setIdentifier(targetTrackId);
       if (profile.getMimeType() != null)
         inspectedTrack.setMimeType(MimeTypes.parseMimeType(profile.getMimeType()));
       return some(inspectedTrack);
     } catch (Exception e) {
       logger.warn("Error concatenating tracks {}: {}", tracks, e);
       if (e instanceof EncoderException) {
         throw (EncoderException)e;
       } else {
         throw new EncoderException(e);
       }
     } finally{
       IoSupport.closeQuietly(in);
     } 
   }
   @Override
   public
   Job imageToVideo(Attachment sourceImageAttachment, String profileId, 
                    double time)
     throws EncoderException, MediaPackageException {
     try {
       return serviceRegistry.createJob(JOB_TYPE,
                Operation.ImageToVideo.toString(),
                Arrays.asList(MediaPackageElementParser.getAsXml(sourceImageAttachment),
                  profileId, Double.toString(time)));
     } catch (ServiceRegistryException e) {
       throw new EncoderException("Unable to create image to video job", e);
     } 
   }
   protected
   Option<Track> imageToVideo(Job job, Attachment sourceImage, 
                              String profileId, Double time)
     throws EncoderException, MediaPackageException {
     if (job == null)
       throw new EncoderException("The Job parameter must not be null");
     if (sourceImage == null)
       throw new EncoderException("The sourceImage attachment parameter must not be null");
     if (profileId == null)
       throw new EncoderException("The profileId parameter must not be null");
     if (time == null)
       throw new EncoderException("The time parameter must not be null");
     final EncodingProfile profile = getProfile(job, profileId);
     final String targetTrackId = idBuilder.createNew().toString();
     try {
       File imageFile = null;
       try {
         imageFile = workspace.get(sourceImage.getURI());
       } catch (NotFoundException e) {
         incident().recordFailure(job, WORKSPACE_GET_NOT_FOUND, e,
           getWorkspaceMediapackageParams("source image", Type.Attachment,
             sourceImage.getURI()),
           NO_DETAILS);
         throw new EncoderException("Requested source image " + sourceImage + " is not found");
       }catch (IOException e) {
         incident().recordFailure(job, WORKSPACE_GET_IO_EXCEPTION, e,
           getWorkspaceMediapackageParams("source image", Type.Attachment,
             sourceImage.getURI()),
           NO_DETAILS);
         throw new EncoderException("Unable to access source image " + sourceImage);
       } 
       final EncoderEngine encoderEngine = getEncoderEngine(job, profile);
       logger.info(format("Converting image attachment %s into video %s",
                     sourceImage.getIdentifier(), targetTrackId));
       Map<String,String> properties = new HashMap<String,String>();
       if (time == null || time == -1)
         time = 0D;
       DecimalFormatSymbols ffmpegFormat = new DecimalFormatSymbols();
       ffmpegFormat.setDecimalSeparator('.');
       DecimalFormat df = new DecimalFormat("0.000", ffmpegFormat);
       properties.put("time", df.format(time));
       Option<File> output;
       try {
         output = encoderEngine.encode(imageFile, profile, properties);
       } catch (EncoderException e) {
         Map<String,String> params = new HashMap<String,String>();
         params.put("image", sourceImage.getURI().toString());
         params.put("profile", profile.getIdentifier());
         params.put("properties", properties.toString());
         incident().recordFailure(job, IMAGE_TO_VIDEO_FAILED, e, params,
           detailsFor(e, encoderEngine));
         throw e;
       } 
       if (output.isNone() || !output.get().exists() || output.get().length() == 0)
         return none();
       URI workspaceURI =
         putToCollection(job, output.get(), "converted image file");
       Job inspectionJob = inspect(job, workspaceURI);
       Track inspectedTrack =
         (Track)MediaPackageElementParser.getFromXml(inspectionJob.getPayload());
       inspectedTrack.setIdentifier(targetTrackId);
       if (profile.getMimeType() != null)
         inspectedTrack.setMimeType(MimeTypes.parseMimeType(profile.getMimeType()));
       return some(inspectedTrack);
     } catch (Exception e) {
       logger.warn("Error converting " + sourceImage, e);
       if (e instanceof EncoderException) {
         throw (EncoderException)e;
       } else {
         throw new EncoderException(e);
       }
     } 
   }
   @Override
   public
   Job image(Track sourceTrack, String profileId, double... times)
     throws EncoderException, MediaPackageException {
     if (sourceTrack == null)
       throw new IllegalArgumentException("SourceTrack cannot be null");
     if (times.length == 0)
       throw new IllegalArgumentException("At least one time argument has to be specified");
     String[] parameters = new String[times.length + 2];
     parameters[0] = MediaPackageElementParser.getAsXml(sourceTrack);
     parameters[1] = profileId;
     for (int i = 0; i < times.length; i++) {
       parameters[i + 2] = Double.toString(times[i]);
     }
     try {
       return serviceRegistry.createJob(JOB_TYPE, Operation.Image.toString(),
                Arrays.asList(parameters));
     } catch (ServiceRegistryException e) {
       throw new EncoderException("Unable to create a job", e);
     } 
   }
   protected
   List<Attachment> image(Job job, Track sourceTrack, String profileId, 
                          double... times)
     throws EncoderException, MediaPackageException {
     if (sourceTrack == null)
       throw new EncoderException("SourceTrack cannot be null");
     if (sourceTrack != null && !sourceTrack.hasVideo()) {
       Map<String,String> params = new HashMap<String,String>();
       params.put("track-id", sourceTrack.getIdentifier());
       params.put("track-url", sourceTrack.getURI().toString());
       incident().recordFailure(job, IMAGE_EXTRACTION_NO_VIDEO, params);
       throw new EncoderException("Cannot extract an image without a video stream");
     }
     for (double time : times) {
       if (sourceTrack.getDuration() == null) {
         Map<String,String> params = new HashMap<String,String>();
         params.put("track-id", sourceTrack.getIdentifier());
         params.put("track-url", sourceTrack.getURI().toString());
         incident().recordFailure(job, IMAGE_EXTRACTION_UNKNOWN_DURATION,
           params);
         throw new EncoderException("Unable to extract an image from a track with unknown duration");
       }
       if (time < 0 || time * 1000 > sourceTrack.getDuration()) {
         Map<String,String> params = new HashMap<String,String>();
         params.put("track-id", sourceTrack.getIdentifier());
         params.put("track-url", sourceTrack.getURI().toString());
         params.put("track-duration", sourceTrack.getDuration().toString());
         params.put("time", Double.toString(time));
         incident().recordFailure(job,
           IMAGE_EXTRACTION_TIME_OUTSIDE_DURATION, params);
         throw new EncoderException("Can not extract an image at time " + time + " from a track with duration " + 
                 sourceTrack.getDuration());
       }
     }
     try {
       logger.info("creating an image using video track {}",
         sourceTrack.getIdentifier());
       final EncodingProfile profile = getProfile(job, profileId);
       final EncoderEngine encoderEngine = getEncoderEngine(job, profile);
       File videoFile;
       try {
         videoFile = workspace.get(sourceTrack.getURI());
       } catch (NotFoundException e) {
         incident().recordFailure(job, WORKSPACE_GET_NOT_FOUND, e,
           getWorkspaceMediapackageParams("video", Type.Track,
             sourceTrack.getURI()),
           NO_DETAILS);
         throw new EncoderException("Requested video track " + sourceTrack + " was not found",
                 e);
       }catch (IOException e) {
         incident().recordFailure(job, WORKSPACE_GET_IO_EXCEPTION, e,
           getWorkspaceMediapackageParams("video", Type.Track,
             sourceTrack.getURI()),
           NO_DETAILS);
         throw new EncoderException("Error accessing video track " + sourceTrack,
                 e);
       } 
       List<File> encodingOutput;
       try {
         encodingOutput =
         encoderEngine.extract(videoFile, profile, null, times);
         if (encodingOutput == null || encodingOutput.isEmpty()) {
           logger.error("Image extraction from video {} with profile {} failed: no images were produced",
             sourceTrack.getURI(), profile.getIdentifier());
           throw new EncoderException("Image extraction failed: no images were produced");
         }
       } catch (EncoderException e) {
         Map<String,String> params = new HashMap<String,String>();
         params.put("video", sourceTrack.getURI().toString());
         params.put("profile", profile.getIdentifier());
         params.put("positions", Arrays.toString(times));
         incident().recordFailure(job, IMAGE_EXTRACTION_FAILED, e, params,
           detailsFor(e, encoderEngine));
         throw e;
       } 
       int i = 0;
       List<URI> workspaceURIs = new LinkedList<URI>();
       for (File output : encodingOutput) {
         if (!output.exists() || output.length() == 0) {
           logger.warn("Extracted image {} is empty!", output);
           throw new NotFoundException("Extracted image " + output.toString() + " is empty!");
         }
         InputStream in = null;
         try {
           in = new FileInputStream(output);
           URI returnURL =
             workspace.putInCollection(COLLECTION,
               job.getId() + "_" + i++ + "." + FilenameUtils.getExtension(
                                                 output.getAbsolutePath()),
               in);
           logger.debug("Copied image file to the workspace at {}",
             returnURL);
           workspaceURIs.add(returnURL);
         } catch (Exception e) {
           cleanup(encodingOutput.toArray(new File[encodingOutput.size()]));
           cleanupWorkspace(workspaceURIs.toArray(new URI[workspaceURIs.size()]));
           incident().recordFailure(job,
             WORKSPACE_PUT_COLLECTION_IO_EXCEPTION, e,
             getWorkspaceCollectionParams("extracted image file", COLLECTION,
               output.toURI()),
             NO_DETAILS);
           throw new EncoderException("Unable to put image file into the workspace",
                   e);
         } finally{
           IOUtils.closeQuietly(in);
         } 
       }
       cleanup(encodingOutput.toArray(new File[encodingOutput.size()]));
       MediaPackageElementBuilder builder =
         MediaPackageElementBuilderFactory.newInstance().newElementBuilder();
       List<Attachment> imageAttachments = new LinkedList<Attachment>();
       for (URI url : workspaceURIs) {
         Attachment attachment =
           (Attachment)builder.elementFromURI(url, Attachment.TYPE, null);
         imageAttachments.add(attachment);
       }
       return imageAttachments;
     } catch (Exception e) {
       logger.warn("Error extracting image from " + sourceTrack, e);
       if (e instanceof EncoderException) {
         throw (EncoderException)e;
       } else {
         throw new EncoderException(e);
       }
     } 
   }
   private
   void validateVideoStream(Job job, Track sourceTrack)
     throws EncoderException {
     if (sourceTrack != null && !sourceTrack.hasVideo()) {
       Map<String,String> params = new HashMap<String,String>();
       params.put("track-id", sourceTrack.getIdentifier());
       params.put("track-url", sourceTrack.getURI().toString());
       incident().recordFailure(job, IMAGE_EXTRACTION_NO_VIDEO, params);
       throw new EncoderException("Cannot extract an image without a video stream");
     }
   }
   @Override
   public
   Job convertImage(Attachment image, String profileId)
     throws EncoderException, MediaPackageException {
     if (image == null)
       throw new IllegalArgumentException("Source image cannot be null");
     String[] parameters = new String[2];
     parameters[0] = MediaPackageElementParser.getAsXml(image);
     parameters[1] = profileId;
     try {
       return serviceRegistry.createJob(JOB_TYPE,
                Operation.ImageConversion.toString(),
                Arrays.asList(parameters));
     } catch (ServiceRegistryException e) {
       throw new EncoderException("Unable to create a job", e);
     } 
   }
   protected
   Option<Attachment> convertImage(Job job, Attachment sourceImage, 
                                   String profileId)
     throws EncoderException, MediaPackageException {
     if (sourceImage == null)
       throw new EncoderException("SourceImage cannot be null");
     try {
       logger.info("Converting {}", sourceImage);
       final EncodingProfile profile = getProfile(job, profileId);
       final EncoderEngine encoderEngine = getEncoderEngine(job, profile);
       File imageFile;
       try {
         imageFile = workspace.get(sourceImage.getURI());
       } catch (NotFoundException e) {
         incident().recordFailure(job, WORKSPACE_GET_NOT_FOUND, e,
           getWorkspaceMediapackageParams("source image", Type.Attachment,
             sourceImage.getURI()),
           NO_DETAILS);
         throw new EncoderException("Requested video track " + sourceImage + " was not found",
                 e);
       }catch (IOException e) {
         incident().recordFailure(job, WORKSPACE_GET_IO_EXCEPTION, e,
           getWorkspaceMediapackageParams("source image", Type.Attachment,
             sourceImage.getURI()),
           NO_DETAILS);
         throw new EncoderException("Error accessing video track " + sourceImage,
                 e);
       } 
       Option<File> output;
       try {
         output = encoderEngine.encode(imageFile, profile, null);
       } catch (EncoderException e) {
         Map<String,String> params = new HashMap<String,String>();
         params.put("image", sourceImage.getURI().toString());
         params.put("profile", profile.getIdentifier());
         incident().recordFailure(job, CONVERT_IMAGE_FAILED, e, params,
           detailsFor(e, encoderEngine));
         throw e;
       } 
       if (output.isNone() || !output.get().exists() || output.get().length() == 0)
         return none();
       URI workspaceURI =
         putToCollection(job, output.get(), "converted image file");
       MediaPackageElementBuilder builder =
         MediaPackageElementBuilderFactory.newInstance().newElementBuilder();
       Attachment attachment =
         (Attachment)builder.elementFromURI(workspaceURI, Attachment.TYPE,
                       null);
       return some(attachment);
     } catch (Exception e) {
       logger.warn("Error converting image " + sourceImage, e);
       if (e instanceof EncoderException) {
         throw (EncoderException)e;
       } else {
         throw new EncoderException(e);
       }
     } 
   }
   @Override
   public
   Job captions(final Track mediaTrack, final Catalog[] captions)
     throws EmbedderException, MediaPackageException {
     List<String> args = new ArrayList<String>();
     args.set(0, MediaPackageElementParser.getAsXml(mediaTrack));
     for (int i = 0; i < captions.length; i++) {
       args.set(i + 1, MediaPackageElementParser.getAsXml(captions[i]));
     }
     try {
       return serviceRegistry.createJob(JOB_TYPE,
                Operation.Caption.toString(), args, captionJobLoad);
     } catch (ServiceRegistryException e) {
       throw new EmbedderException("Unable to create a job", e);
     } 
   }
   @SuppressWarnings("unchecked")
   protected
   Track captions(Job job, Track mediaTrack, Catalog[] captions)
     throws EmbedderException {
     try {
       logger.info("Attempting to create and embed subtitles to video track");
       final String targetTrackId = idBuilder.createNew().toString();
       if (mediaTrack == null || !mediaTrack.hasVideo()) {
         Map<String,String> params = new HashMap<String,String>();
         params.put("track-id", mediaTrack.getIdentifier());
         params.put("track-url", mediaTrack.getURI().toString());
         incident().recordFailure(job, CAPTION_NO_VIDEO, params);
         throw new EmbedderException("Media track must contain video stream");
       }
       final EmbedderEngine engine =
         embedderEngineFactory.newEmbedderEngine();
       if (engine == null) {
         final String msg = "Embedder engine not available";
         logger.error(msg);
         incident().recordFailure(job, EMBEDDER_ENGINE_NOT_FOUND,
           list(tuple("embedder-engine-class",
                  embedderEngineFactory.getClass().getName())));
         throw new EmbedderException(msg);
       }
       Integer videoHeigth = null;
       for (Stream s : mediaTrack.getStreams()) {
         if (s instanceof VideoStream) {
           videoHeigth = ((VideoStream)s).getFrameHeight();
           break;
         }
       }
       final int subHeight;
       if (videoHeigth != null) {
         subHeight = videoHeigth > 8 * 60 ? videoHeigth / 8 : 60;
       } else {
         subHeight = 60;
       }
       final File mediaFile;
       try {
         mediaFile = workspace.get(mediaTrack.getURI());
       } catch (NotFoundException e) {
         incident().recordFailure(job, WORKSPACE_GET_NOT_FOUND, e,
           getWorkspaceMediapackageParams("source", Type.Track,
             mediaTrack.getURI()),
           NO_DETAILS);
         throw new EmbedderException("Could not find track: " + mediaTrack);
       }catch (IOException e) {
         incident().recordFailure(job, WORKSPACE_GET_IO_EXCEPTION, e,
           getWorkspaceMediapackageParams("source", Type.Track,
             mediaTrack.getURI()),
           NO_DETAILS);
         throw new EmbedderException("Error accessing track: " + mediaTrack);
       } 
       final File[] captionFiles = new File[captions.length];
       final String[] captionLanguages = new String[captions.length];
       for (int i = 0; i < captions.length; i++) {
         try {
           captionFiles[i] = workspace.get(captions[i].getURI());
         } catch (NotFoundException e) {
           incident().recordFailure(job, WORKSPACE_GET_NOT_FOUND, e,
             getWorkspaceMediapackageParams("caption", Type.Catalog,
               captions[i].getURI()),
             NO_DETAILS);
           throw new EmbedderException("Could not found captions at: " + captions[i]);
         }catch (IOException e) {
           incident().recordFailure(job, WORKSPACE_GET_IO_EXCEPTION, e,
             getWorkspaceMediapackageParams("caption", Type.Catalog,
               captions[i].getURI()),
             NO_DETAILS);
           throw new EmbedderException("Error accessing captions at: " + captions[i]);
         } 
         captionLanguages[i] = getLanguageFromTags(captions[i].getTags());
         if (captionLanguages[i] == null) {
           Map<String,String> params = new HashMap<String,String>();
           params.put("caption-id", captions[i].getIdentifier());
           params.put("caption-url", captions[i].getURI().toString());
           params.put("caption-tags",
             StringUtils.join(captions[i].getTags()));
           incident().recordFailure(job, CAPTION_NO_LANGUAGE, params);
           throw new EmbedderException("Missing caption language information for captions at: " + captions[i]);
         }
       }
       Map<String,String> properties = new HashMap<String,String>();
       properties.put("param.trackh", String.valueOf(subHeight));
       properties.put("param.offset", String.valueOf(subHeight / 2));
       properties.put("param.input.stream.count",
         String.valueOf(mediaTrack.getStreams().length));
       File output;
       try {
         output =
         engine.embed(mediaFile, captionFiles, captionLanguages, properties);
       } catch (EmbedderException e) {
         Map<String,String> params = new HashMap<String,String>();
         params.put("media", mediaTrack.getURI().toString());
         params.put("captions", StringUtils.join(captionFiles));
         params.put("languages", StringUtils.join(captionLanguages));
         params.put("properties", properties.toString());
         incident().recordFailure(job, CAPTION_EMBEDD_FAILED, e, params,
           list(tuple("embedder-engine-class", engine.getClass().getName())));
         throw e;
       } 
       if (!output.exists() || output.length() == 0) {
         logger.warn("Embedded captions output file {} is empty!", output);
         throw new NotFoundException("Embedded captions output file " + 
                 output.toString() + " is empty!");
       }
       URI workspaceURI =
         putToCollection(job, output, "caption catalog file");
       Job inspectionJob = inspect(job, workspaceURI);
       Track inspectedTrack =
         (Track)MediaPackageElementParser.getFromXml(inspectionJob.getPayload());
       inspectedTrack.setIdentifier(targetTrackId);
       return inspectedTrack;
     } catch (Exception e) {
       logger.warn("Error embedding captions into " + mediaTrack, e);
       if (e instanceof EncoderException) {
         throw (EmbedderException)e;
       } else {
         throw new EmbedderException(e);
       }
     } 
   }
   @Override
   public
   Job watermark(Track mediaTrack, String watermark, String profileId)
     throws EncoderException, MediaPackageException {
     try {
       return serviceRegistry.createJob(JOB_TYPE,
                Operation.Watermark.toString(),
                Arrays.asList(MediaPackageElementParser.getAsXml(mediaTrack),
                  watermark, profileId));
     } catch (ServiceRegistryException e) {
       throw new EncoderException("Unable to create a job", e);
     } 
   }
   protected
   Option<Track> watermark(Job job, Track mediaTrack, String watermark, 
                           String encodingProfile)
     throws EncoderException, MediaPackageException {
     logger.info("watermarking track {}.", mediaTrack.getIdentifier());
     File watermarkFile = new File(watermark);
     if (!watermarkFile.exists()) {
       logger.error("Watermark image {} not found.", watermark);
       Map<String,String> params = new HashMap<String,String>();
       params.put("watermark", watermarkFile.getAbsolutePath());
       incident().recordFailure(job, WATERMARK_NOT_FOUND, params);
       throw new EncoderException("Watermark image not found");
     }
     Map<String,String> watermarkProperties = new HashMap<String,String>();
     watermarkProperties.put("watermark", watermarkFile.getAbsolutePath());
     return encode(job, mediaTrack, null, encodingProfile,
              watermarkProperties);
   }
   @Override
   protected
   String process(Job job) throws Exception {
     Operation op = null;
     String operation = job.getOperation();
     List<String> arguments = job.getArguments();
     try {
       op = Operation.valueOf(operation);
       Track firstTrack = null;
       Track secondTrack = null;
       String encodingProfile = null;
       final String serialized;
       switch (op) {
         case Caption:
           firstTrack =
           (Track)MediaPackageElementParser.getFromXml(arguments.get(0));
           Catalog[] catalogs = new Catalog[arguments.size() - 1];
           for (int i = 1; i < arguments.size(); i++) {
             catalogs[i] =
             (Catalog)MediaPackageElementParser.getFromXml(arguments.get(i));
           }
           serialized =
           MediaPackageElementParser.getAsXml(captions(job, firstTrack,
                                                catalogs));
           break;
         case Encode:
           firstTrack =
           (Track)MediaPackageElementParser.getFromXml(arguments.get(0));
           encodingProfile = arguments.get(1);
           serialized =
           encode(job, firstTrack, null, encodingProfile, null).map(MediaPackageElementParser.<Track>getAsXml()).getOrElse("");
           break;
         case ParallelEncode:
           firstTrack =
           (Track)MediaPackageElementParser.getFromXml(arguments.get(0));
           encodingProfile = arguments.get(1);
           serialized =
           MediaPackageElementParser.getArrayAsXml(parralelEncode(job,
                                                     firstTrack,
                                                     encodingProfile, null));
           break;
         case Image:
           firstTrack =
           (Track)MediaPackageElementParser.getFromXml(arguments.get(0));
           encodingProfile = arguments.get(1);
           double[] times = new double[arguments.size() - 2];
           for (int i = 2; i < arguments.size(); i++) {
             times[i - 2] = Double.parseDouble(arguments.get(i));
           }
           List<Attachment> resultingElements =
             image(job, firstTrack, encodingProfile, times);
           serialized =
           MediaPackageElementParser.getArrayAsXml(resultingElements);
           break;
         case ImageConversion:
           Attachment sourceImage =
             (Attachment)MediaPackageElementParser.getFromXml(arguments.get(0));
           encodingProfile = arguments.get(1);
           serialized =
           convertImage(job, sourceImage, encodingProfile).map(MediaPackageElementParser.<Attachment>getAsXml()).getOrElse("");
           break;
         case Mux:
           firstTrack =
           (Track)MediaPackageElementParser.getFromXml(arguments.get(0));
           secondTrack =
           (Track)MediaPackageElementParser.getFromXml(arguments.get(1));
           encodingProfile = arguments.get(2);
           serialized =
           mux(job, firstTrack, secondTrack, encodingProfile).map(MediaPackageElementParser.<Track>getAsXml()).getOrElse("");
           break;
         case Trim:
           firstTrack =
           (Track)MediaPackageElementParser.getFromXml(arguments.get(0));
           encodingProfile = arguments.get(1);
           long start = Long.parseLong(arguments.get(2));
           long duration = Long.parseLong(arguments.get(3));
           serialized =
           trim(job, firstTrack, encodingProfile, start, duration).map(
             MediaPackageElementParser.<Track>getAsXml()).getOrElse("");
           break;
         case Watermark:
           firstTrack =
           (Track)MediaPackageElementParser.getFromXml(arguments.get(0));
           String watermark = arguments.get(1);
           encodingProfile = arguments.get(2);
           serialized =
           watermark(job, firstTrack, watermark, encodingProfile).map(
             MediaPackageElementParser.<Track>getAsXml()).getOrElse("");
           break;
         case Composite:
           Attachment watermarkAttachment = null;
           firstTrack =
           (Track)MediaPackageElementParser.getFromXml(arguments.get(0));
           Layout lowerLayout =
             Serializer.layout(JsonObj.jsonObj(arguments.get(1)));
           LaidOutElement<Track> lowerLaidOutElement =
             new LaidOutElement<Track>(firstTrack, lowerLayout);
           secondTrack =
           (Track)MediaPackageElementParser.getFromXml(arguments.get(2));
           Layout upperLayout =
             Serializer.layout(JsonObj.jsonObj(arguments.get(3)));
           LaidOutElement<Track> upperLaiedOutElement =
             new LaidOutElement<Track>(secondTrack, upperLayout);
           Dimension compositeTrackSize =
             Serializer.dimension(JsonObj.jsonObj(arguments.get(4)));
           encodingProfile = arguments.get(5);
           String backgroundColor = arguments.get(6);
           Option<LaidOutElement<Attachment>> watermarkOption =
             Option.none();
           if (arguments.size() == 9) {
             watermarkAttachment =
             (Attachment)MediaPackageElementParser.getFromXml(arguments.get(7));
             Layout watermarkLayout =
               Serializer.layout(JsonObj.jsonObj(arguments.get(8)));
             watermarkOption =
             Option.some(new LaidOutElement<Attachment>(watermarkAttachment,
                           watermarkLayout));
           }
           serialized =
           composite(job, compositeTrackSize, lowerLaidOutElement,
             upperLaiedOutElement, watermarkOption, encodingProfile,
             backgroundColor).map(MediaPackageElementParser.<Track>getAsXml()).getOrElse("");
           break;
         case Concat:
           encodingProfile = arguments.get(0);
           String dimensionString = arguments.get(1);
           Dimension outputDimension = null;
           if (StringUtils.isNotBlank(dimensionString))
             outputDimension =
             Serializer.dimension(JsonObj.jsonObj(dimensionString));
           List<Track> tracks = new ArrayList<Track>();
           for (int i = 2; i < arguments.size(); i++) {
             tracks.add(i - 2,
               (Track)MediaPackageElementParser.getFromXml(arguments.get(i)));
           }
           serialized =
           concat(job, tracks, encodingProfile, outputDimension).map(
             MediaPackageElementParser.<Track>getAsXml()).getOrElse("");
           break;
         case ImageToVideo:
           Attachment image =
             (Attachment)MediaPackageElementParser.getFromXml(arguments.get(0));
           encodingProfile = arguments.get(1);
           double time = Double.parseDouble(arguments.get(2));
           serialized =
           imageToVideo(job, image, encodingProfile, time).map(MediaPackageElementParser.<Track>getAsXml()).getOrElse("");
           break;
         default:
           throw new IllegalStateException("Don't know how to handle operation '" + operation + "'");
       }
       return serialized;
     } catch (IllegalArgumentException e) {
       throw new ServiceRegistryException("This service can't handle operations of type '" + op + "'",
               e);
     }catch (IndexOutOfBoundsException e) {
       throw new ServiceRegistryException("This argument list for operation '" + op + "' does not meet expectations",
               e);
     }catch (Exception e) {
       throw new ServiceRegistryException("Error handling operation '" + op + "'",
               e);
     } 
   }
   @Override
   public
   EncodingProfile[] listProfiles() {
     Collection<EncodingProfile> profiles =
       profileScanner.getProfiles().values();
     return profiles.toArray(new EncodingProfile[profiles.size()]);
   }
   @Override
   public
   EncodingProfile getProfile(String profileId) {
     return profileScanner.getProfiles().get(profileId);
   }
   protected
   Job inspect(Job job, URI workspaceURI) throws EncoderException {
     Job inspectionJob;
     try {
       inspectionJob = inspectionService.inspect(workspaceURI);
     } catch (MediaInspectionException e) {
       incident().recordJobCreationIncident(job, e);
       throw new EncoderException("Media inspection of " + workspaceURI + " failed",
               e);
     } 
     JobBarrier barrier =
       new JobBarrier(job, serviceRegistry, inspectionJob);
     if (!barrier.waitForJobs().isSuccess()) {
       throw new EncoderException("Media inspection of " + workspaceURI + " failed");
     }
     return inspectionJob;
   }
   protected
   String getLanguageFromTags(String[] tags) {
     for (String tag : tags) {
       if (tag.startsWith("lang:") && tag.length() > 5) {
         return tag.substring(5);
       }
     }
     return null;
   }
   protected
   void cleanup(File... encodingOutput) {
     for (File file : encodingOutput) {
       if (file != null && file.isFile()) {
         String path = file.getAbsolutePath();
         if (file.delete()) {
           logger.info("Deleted local copy of encoding file at {}", path);
         } else {
           logger.warn("Could not delete local copy of encoding file at {}",
             path);
         }
       }
     }
   }
   protected
   void cleanupWorkspace(URI... workspaceURIs) {
     for (URI url : workspaceURIs) {
       try {
         workspace.delete(url);
       } catch (Exception e) {
         logger.warn("Could not delete {} from workspace: {}", url,
           e.getMessage());
       } 
     }
   }
   @SuppressWarnings("unchecked")
   private
   EncoderEngine getEncoderEngine(Job job, final EncodingProfile profile)
     throws EncoderException {
     final EncoderEngine encoderEngine =
       encoderEngineFactory.newEncoderEngine(profile);
     if (encoderEngine == null) {
       final String msg =
         "No encoder engine available for profile '" + profile.getIdentifier() + "'";
       logger.error(msg);
       incident().recordFailure(job, ENCODER_ENGINE_NOT_FOUND,
         Collections.map(tuple("profile", profile.getIdentifier()),
           tuple("profile-name", profile.getName())));
       throw new EncoderException(msg);
     }
     return encoderEngine;
   }
   @SuppressWarnings("unchecked")
   private
   EncodingProfile getProfile(Job job, String profileId)
     throws EncoderException {
     final EncodingProfile profile = profileScanner.getProfile(profileId);
     if (profile == null) {
       final String msg = "Profile " + profileId + " is unknown";
       logger.error(msg);
       incident().recordFailure(job, PROFILE_NOT_FOUND,
         Collections.map(tuple("profile", profileId)));
       throw new EncoderException(msg);
     }
     return profile;
   }
   private
   Map<String,String> getWorkspaceMediapackageParams(String description, 
                                                     MediaPackageElement.Type type,
                                                     URI url) {
     Map<String,String> params = new HashMap<String,String>();
     params.put("description", description);
     params.put("type", type.toString());
     params.put("url", url.toString());
     return params;
   }
   private
   Map<String,String> getWorkspaceCollectionParams(String description, 
                                                   String collectionId, 
                                                   URI url) {
     Map<String,String> params = new HashMap<String,String>();
     params.put("description", description);
     params.put("collection", collectionId);
     params.put("url", url.toString());
     return params;
   }
   private
   String buildCompositeCommand(Dimension compositeTrackSize, 
                                LaidOutElement<Track> lowerLaidOutElement, 
                                LaidOutElement<Track> upperLaiedOutElement, 
                                Option<LaidOutElement<Attachment>> watermarkOption,
                                File upperVideoFile, File watermarkFile, 
                                String backgroundColor) {
     Layout lowerLayout = lowerLaidOutElement.getLayout();
     Layout upperLayout = upperLaiedOutElement.getLayout();
     String upperPosition =
       upperLayout.getOffset().getX() + ":" + upperLayout.getOffset().getY();
     String lowerPosition =
       lowerLayout.getOffset().getX() + ":" + lowerLayout.getOffset().getY();
     String scaleUpper =
       upperLayout.getDimension().getWidth() + ":" + upperLayout.getDimension().getHeight();
     String scaleLower =
       lowerLayout.getDimension().getWidth() + ":" + lowerLayout.getDimension().getHeight();
     StringBuilder sb =
       new StringBuilder().append("[in]scale=").append(scaleLower).append(",pad=").append(
         compositeTrackSize.getWidth()).append(":").append(compositeTrackSize.getHeight()).append(":").append(lowerPosition).append(":").append(backgroundColor).append("[lower];movie=").append(
         upperVideoFile.getAbsolutePath()).append(",scale=").append(scaleUpper).append("[upper];");
     if (watermarkOption.isSome()) {
       Layout watermarkLayout = watermarkOption.get().getLayout();
       String watermarkPosition =
         watermarkLayout.getOffset().getX() + ":" + watermarkLayout.getOffset().getY();
       String scaleWaterMark =
         watermarkLayout.getDimension().getWidth() + ":" + watermarkLayout.getDimension().getHeight();
       sb.append("movie=").append(watermarkFile.getAbsolutePath()).append("[watermark];[lower][upper]overlay=").append(upperPosition).append("[video];[video][watermark]overlay=main_w-overlay_w-").append(watermarkPosition).append("[out]");
     } else {
       sb.append("[lower][upper]overlay=").append(upperPosition).append("[out]");
     }
     return sb.toString();
   }
   private
   String buildConcatCommand(boolean onlyAudio, Dimension dimension, 
                             List<File> files, List<Track> tracks) {
     StringBuilder sb = new StringBuilder();
     for (File f : files) {
       sb.append("-i ").append(f.getAbsolutePath()).append(" ");
     }
     sb.append("-filter_complex ");
     boolean hasAudio = false;
     if (!onlyAudio) {
       int characterCount = 0;
       for (int i = 0; i < files.size(); i++) {
         if ((i % 25) == 0)
           characterCount++;
         sb.append("[").append(i).append(":v]scale=iw*min(").append(dimension.getWidth()).append("/iw\\,").append(
           dimension.getHeight()).append("/ih):ih*min(").append(dimension.getWidth()).append("/iw\\,").append(
           dimension.getHeight()).append("/ih),pad=").append(dimension.getWidth()).append(":").append(
           dimension.getHeight()).append(":(ow-iw)/2:(oh-ih)/2").append(",setdar=").append((float)
           dimension.getWidth() / (float)dimension.getHeight()).append("[");
         int character = ('a' + i + 1 - ((characterCount - 1) * 25));
         for (int y = 0; y < characterCount; y++) {
           sb.append((char)character);
         }
         sb.append("];");
         if (tracks.get(i).hasAudio())
           hasAudio = true;
       }
       if (hasAudio) {
         for (int i = 0; i < files.size(); i++) {
           if (!tracks.get(i).hasAudio())
             sb.append("aevalsrc=0::d=1[silent").append(i + 1).append("];");
         }
       }
     }
     int characterCount = 0;
     for (int i = 0; i < files.size(); i++) {
       if ((i % 25) == 0)
         characterCount++;
       int character = ('a' + i + 1 - ((characterCount - 1) * 25));
       if (!onlyAudio) {
         sb.append("[");
         for (int y = 0; y < characterCount; y++) {
           sb.append((char)character);
         }
         sb.append("]");
       }
       if (tracks.get(i).hasAudio()) {
         sb.append("[").append(i).append(":a]");
       } else if (hasAudio) {
         sb.append("[silent").append(i + 1).append("]");
       }
     }
     sb.append("concat=n=").append(files.size()).append(":v=");
     if (onlyAudio) {
       sb.append("0");
     } else {
       sb.append("1");
     }
     sb.append(":a=");
     if (!onlyAudio) {
       if (hasAudio) {
         sb.append("1[v][a] -map [v] -map [a] ");
       } else {
         sb.append("0[v] -map [v] ");
       }
     } else {
       sb.append("1[a] -map [a]");
     }
     return sb.toString();
   }
   private
   URI putToCollection(Job job, File output, String description)
     throws EncoderException {
     URI returnURL = null;
     InputStream in = null;
     try {
       in = new FileInputStream(output);
       returnURL =
       workspace.putInCollection(COLLECTION,
         job.getId() + "." + FilenameUtils.getExtension(output.getAbsolutePath()),
         in);
       logger.info("Copied the {} to the workspace at {}", description,
         returnURL);
       return returnURL;
     } catch (Exception e) {
       incident().recordFailure(job, WORKSPACE_PUT_COLLECTION_IO_EXCEPTION,
         e,
         getWorkspaceCollectionParams(description, COLLECTION,
           output.toURI()),
         NO_DETAILS);
       cleanupWorkspace(returnURL);
       throw new EncoderException("Unable to put the " + description + " into the workspace",
               e);
     } finally{
       cleanup(output);
       IOUtils.closeQuietly(in);
     } 
   }
   private
   static
   List<Tuple<String,String>> detailsFor(EncoderException ex, 
                                         EncoderEngine engine) {
     final List<Tuple<String,String>> d = Mutables.arrayList();
     d.add(tuple("encoder-engine-class", engine.getClass().getName()));
     if (ex instanceof CmdlineEncoderException) {
       d.add(tuple("encoder-commandline",
               ((CmdlineEncoderException)ex).getCommandLine()));
     }
     return d;
   }
   protected
   void setMediaInspectionService(MediaInspectionService mediaInspectionService) {
     this.inspectionService = mediaInspectionService;
   }
   protected
   void setEncoderEngineFactory(EncoderEngineFactory encoderEngineFactory) {
     this.encoderEngineFactory = encoderEngineFactory;
   }
   protected
   void setEmbedderEngineFactory(EmbedderEngineFactory embedderEngineFactory) {
     this.embedderEngineFactory = embedderEngineFactory;
   }
   protected
   void setWorkspace(Workspace workspace) {
     this.workspace = workspace;
   }
   protected
   void setServiceRegistry(ServiceRegistry serviceRegistry) {
     this.serviceRegistry = serviceRegistry;
   }
   @Override
   protected
   ServiceRegistry getServiceRegistry() {
     return serviceRegistry;
   }
   protected
   void setProfileScanner(EncodingProfileScanner scanner) {
     this.profileScanner = scanner;
   }
   public
   void setSecurityService(SecurityService securityService) {
     this.securityService = securityService;
   }
   public
   void setUserDirectoryService(UserDirectoryService userDirectoryService) {
     this.userDirectoryService = userDirectoryService;
   }
   public
   void setOrganizationDirectoryService(OrganizationDirectoryService organizationDirectory) {
     this.organizationDirectoryService = organizationDirectory;
   }
   @Override
   protected
   SecurityService getSecurityService() {
     return securityService;
   }
   @Override
   protected
   UserDirectoryService getUserDirectoryService() {
     return userDirectoryService;
   }
   @Override
   protected
   OrganizationDirectoryService getOrganizationDirectoryService() {
     return organizationDirectoryService;
   }
   @Override
   public
   void updated(Dictionary properties) throws ConfigurationException {
     captionJobLoad =
     LoadUtil.getConfiguredLoadValue(properties, CAPTION_JOB_LOAD_KEY,
       DEFAULT_CAPTION_JOB_LOAD, serviceRegistry);
   }
}