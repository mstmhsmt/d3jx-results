// generated by Diff/AST Java Unparser
package org.elasticsearch.index.query;
import org.apache.lucene.index.Term;
import org.apache.lucene.search.Query;
import org.apache.lucene.search.TermQuery;
import org.apache.lucene.util.BytesRef;
import org.elasticsearch.common.inject.Inject;
import org.elasticsearch.common.xcontent.XContentParser;
import org.elasticsearch.index.mapper.DocumentMapper;
import org.elasticsearch.index.mapper.internal.TypeFieldMapper;
import java.io.IOException;
public class TypeQueryParser implements QueryParser {
  public static final String NAME = "type";
  @Inject
  public TypeQueryParser() {}
  @Override
  public String[] names() {
    return new String[] {NAME};
  }
  @Override
  public Query parse(QueryParseContext parseContext)
      throws IOException, QueryParsingException {
    XContentParser parser = parseContext.parser();
    XContentParser.Token token = parser.nextToken();
    if (token != XContentParser.Token.FIELD_NAME) {
      throw new QueryParsingException(
          parseContext,
          "[type] filter should have a value field, and the type name");
    }
    String fieldName = parser.currentName();
    if (!fieldName.equals("value")) {
      throw new QueryParsingException(
          parseContext,
          "[type] filter should have a value field, and the type name");
    }
    token = parser.nextToken();
    if (token != XContentParser.Token.VALUE_STRING) {
      throw new QueryParsingException(
          parseContext,
          "[type] filter should have a value field, and the type name");
    }
    BytesRef type = parser.utf8Bytes();
    parser.nextToken();
    Query filter;
    DocumentMapper documentMapper =
        parseContext.mapperService().documentMapper(type.utf8ToString());
    if (documentMapper == null) {
      filter = new TermQuery(new Term(TypeFieldMapper.NAME, type));
    } else {
      filter = documentMapper.typeFilter();
    }
    return filter;
  }
}