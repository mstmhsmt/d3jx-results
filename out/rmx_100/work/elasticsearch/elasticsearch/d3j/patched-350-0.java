// generated by Diff/AST Java Unparser
package org.elasticsearch.index.query;
import org.apache.lucene.util.BytesRef;
import org.elasticsearch.common.ParsingException;
import org.elasticsearch.common.inject.Inject;
import org.elasticsearch.common.xcontent.XContentParser;
import java.io.IOException;
public class TypeQueryParser extends BaseQueryParser<TypeQueryBuilder> {
  @Override
  public String[] names() {
    return new String[] {TypeQueryBuilder.NAME};
  }
  @Override
  public TypeQueryBuilder fromXContent(QueryParseContext parseContext)
      throws IOException, ParsingException {
    XContentParser parser = parseContext.parser();
    BytesRef type = null;
    String queryName = null;
    float boost = AbstractQueryBuilder.DEFAULT_BOOST;
    String currentFieldName = null;
    XContentParser.Token token;
    while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
      if (token == XContentParser.Token.FIELD_NAME) {
        currentFieldName = parser.currentName();
      } else if (token.isValue()) {
        if ("_name".equals(currentFieldName)) {
          queryName = parser.text();
        } else if ("boost".equals(currentFieldName)) {
          boost = parser.floatValue();
        } else if ("value".equals(currentFieldName)) {
          type = parser.utf8Bytes();
        }
      } else {
        throw new ParsingException(parseContext,
                                   "[type] filter doesn't support [" +
                                       currentFieldName + "]");
      }
    }
    if (type == null) {
      throw new ParsingException(
          parseContext,
          "[type] filter needs to be provided with a value for the type");
    }
    return new TypeQueryBuilder(type).boost(boost).queryName(queryName);
  }
  @Override
  public TypeQueryBuilder getBuilderPrototype() {
    return TypeQueryBuilder.PROTOTYPE;
  }
}