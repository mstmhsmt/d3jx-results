// generated by Diff/AST Java Unparser
package io.realm;
import android.annotation.SuppressLint;
import android.annotation.TargetApi;
import android.content.Context;
import android.os.Build;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.util.JsonReader;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import java.io.Closeable;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.ref.WeakReference;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import io.realm.exceptions.RealmException;
import io.realm.exceptions.RealmIOException;
import io.realm.exceptions.RealmMigrationNeededException;
import io.realm.internal.ColumnIndices;
import io.realm.internal.ColumnType;
import io.realm.internal.ImplicitTransaction;
import io.realm.internal.RealmObjectProxy;
import io.realm.internal.RealmProxyMediator;
import io.realm.internal.Row;
import io.realm.internal.SharedGroup;
import io.realm.internal.Table;
import io.realm.internal.TableView;
import io.realm.internal.android.DebugAndroidLogger;
import io.realm.internal.android.ReleaseAndroidLogger;
import io.realm.internal.log.RealmLog;
import io.realm.internal.modules.FilterableMediator;
public final class Realm implements Closeable {
  public static final String DEFAULT_REALM_NAME = "default.realm";
  private static final String TABLE_PREFIX = "class_";
  protected static final ThreadLocal<Map<String, Realm>> realmsCache =
      new ThreadLocal<Map<String, Realm>>() {
        @SuppressLint("UseSparseArrays")
        @Override
        protected Map<String, Realm> initialValue() {
          return new HashMap<String, Realm>();
        }
      };
  private static final ThreadLocal<Map<String, Integer>> referenceCount =
      new ThreadLocal<Map<String, Integer>>() {
        @SuppressLint("UseSparseArrays")
        @Override
        protected Map<String, Integer> initialValue() {
          return new HashMap<String, Integer>();
        }
      };
  private static final int REALM_CHANGED = 14930352;
  protected static final Map<Handler, String> handlers =
      new ConcurrentHashMap<Handler, String>();
  private static RealmConfiguration defaultConfiguration;
  private static final Map<String, AtomicInteger> openRealms =
      new ConcurrentHashMap<String, AtomicInteger>();
  private static final String INCORRECT_THREAD_MESSAGE =
      "Realm access from incorrect thread. Realm objects can only be " +
      "accessed on the thread they where created.";
  private static final String CLOSED_REALM_MESSAGE =
      "This Realm instance has already been closed, making it unusable.";
  private static final String DIFFERENT_KEY_MESSAGE =
      "Wrong key used to decrypt Realm.";
  @SuppressWarnings("UnusedDeclaration")
  private static SharedGroup.Durability defaultDurability =
      SharedGroup.Durability.FULL;
  private boolean autoRefresh;
  private Handler handler;
  private final byte[] key;
  private final String canonicalPath;
  private SharedGroup sharedGroup;
  private final ImplicitTransaction transaction;
  private final Map<Class<?>, String> proxiedClassNames =
      new HashMap<Class<?>, String>();
  private final List<WeakReference<RealmChangeListener>> changeListeners =
      new ArrayList<WeakReference<RealmChangeListener>>();
  private static final long UNVERSIONED = -1;
  final ColumnIndices columnIndices = new ColumnIndices();
  static {
    RealmLog.add(BuildConfig.DEBUG ? new DebugAndroidLogger()
                                   : new ReleaseAndroidLogger());
  }
  protected void checkIfValid() {
    if (sharedGroup == null) {
      throw new IllegalStateException(CLOSED_REALM_MESSAGE);
    }
    Realm currentRealm = realmsCache.get().get(canonicalPath);
    if (currentRealm != this) {
      throw new IllegalStateException(INCORRECT_THREAD_MESSAGE);
    }
  }
  private Realm(String canonicalPath, byte[] key, boolean autoRefresh) {
    this.sharedGroup = new SharedGroup(canonicalPath, true, key);
    this.transaction = sharedGroup.beginImplicitTransaction();
    this.canonicalPath = canonicalPath;
    this.key = key;
    setAutoRefresh(autoRefresh);
  }
  @Override
  protected void finalize() throws Throwable {
    if (sharedGroup != null) {
      RealmLog.w("Remember to call close() on all Realm instances. "
                 + "Realm " + canonicalPath +
                 " is being finalized without being closed, "
                 + "this can lead to running out of native memory.");
    }
    super.finalize();
  }
  @Override
  public void close() {
    Map<String, Integer> localRefCount = referenceCount.get();
    Integer references = localRefCount.get(canonicalPath);
    if (references == null) {
      references = 0;
    }
    if (sharedGroup != null && references == 1) {
      realmsCache.get().remove(canonicalPath);
      sharedGroup.close();
      sharedGroup = null;
      AtomicInteger counter = openRealms.get(canonicalPath);
      if (counter.decrementAndGet() == 0) {
        openRealms.remove(canonicalPath);
      }
    }
    int refCount = references - 1;
    if (refCount < 0) {
      RealmLog.w("Calling close() on a Realm that is already closed: " +
                 canonicalPath);
    }
    localRefCount.put(canonicalPath, Math.max(0, refCount));
    if (handler != null && refCount <= 0) {
      removeHandler(handler);
    }
  }
  private void removeHandler(Handler handler) {
    handler.removeCallbacksAndMessages(null);
    handlers.remove(handler);
  }
  private static RealmProxyMediator getDefaultMediator() {
    Class<?> clazz;
    try {
      clazz = Class.forName("io.realm.DefaultRealmModuleMediator");
      Constructor<?> constructor = clazz.getDeclaredConstructors()[0];
      constructor.setAccessible(true);
      return (RealmProxyMediator)constructor.newInstance();
    } catch (ClassNotFoundException e) {
      throw new RealmException(
          "Could not find io.realm.DefaultRealmModuleMediator", e);
    } catch (InvocationTargetException e) {
      throw new RealmException(
          "Could not create an instance of io.realm.DefaultRealmModuleMediator",
          e);
    } catch (InstantiationException e) {
      throw new RealmException(
          "Could not create an instance of io.realm.DefaultRealmModuleMediator",
          e);
    } catch (IllegalAccessException e) {
      throw new RealmException(
          "Could not create an instance of io.realm.DefaultRealmModuleMediator",
          e);
    }
  }
  private class RealmCallback implements Handler.Callback {
    @Override
    public boolean handleMessage(Message message) {
      if (message.what == REALM_CHANGED) {
        transaction.advanceRead();
        sendNotifications();
      }
      return true;
    }
  }
  public boolean isAutoRefresh() { return autoRefresh; }
  public void setAutoRefresh(boolean autoRefresh) {
    if (autoRefresh && Looper.myLooper() == null) {
      throw new IllegalStateException(
          "Cannot set auto-refresh in a Thread without a Looper");
    }
    if (autoRefresh && !this.autoRefresh) {
      handler = new Handler(new RealmCallback());
      handlers.put(handler, canonicalPath);
    } else if (!autoRefresh && this.autoRefresh && handler != null) {
      removeHandler(handler);
    }
    this.autoRefresh = autoRefresh;
  }
  public Table getTable(Class<? extends RealmObject> clazz) {
    Class<?> superclass = clazz.getSuperclass();
    if (!superclass.equals(RealmObject.class)) {
      clazz = (Class<? extends RealmObject>)superclass;
    }
    return transaction.getTable(proxyMediator.getTableName(clazz));
  }
  @Deprecated
  public static Realm getInstance(Context context) {
    return Realm.getInstance(context, DEFAULT_REALM_NAME);
  }
  @Deprecated
  public static Realm getInstance(Context context, String fileName) {
    return Realm.getInstance(context, fileName, null);
  }
  @Deprecated
  public static Realm getInstance(Context context, byte[] key) {
    return Realm.getInstance(context, DEFAULT_REALM_NAME, key);
  }
  @Deprecated
  public static Realm getInstance(Context context, String fileName,
                                  byte[] key) {
    RealmConfiguration.Builder builder =
        new RealmConfiguration.Builder(context).name(fileName);
    if (key != null) {
      builder.encryptionKey(key);
    }
    return create(builder.build());
  }
  @Deprecated
  @SuppressWarnings("UnusedDeclaration")
  public static Realm getInstance(File writeableFolder) {
    return create(new RealmConfiguration.Builder(writeableFolder)
                      .name(DEFAULT_REALM_NAME)
                      .build());
  }
  @Deprecated
  @SuppressWarnings("UnusedDeclaration")
  public static Realm getInstance(File writeableFolder, String fileName) {
    return create(
        new RealmConfiguration.Builder(writeableFolder).name(fileName).build());
  }
  @Deprecated
  @SuppressWarnings("UnusedDeclaration")
  public static Realm getInstance(File writeableFolder, byte[] key) {
    return create(new RealmConfiguration.Builder(writeableFolder)
                      .name(DEFAULT_REALM_NAME)
                      .encryptionKey(key)
                      .build());
  }
  @Deprecated
  @SuppressWarnings("UnusedDeclaration")
  public static Realm getInstance(File writeableFolder, String fileName,
                                  byte[] key) {
    return create(new RealmConfiguration.Builder(writeableFolder)
                      .name(fileName)
                      .encryptionKey(key)
                      .build());
  }
  public static Realm getDefaultInstance() {
    if (defaultConfiguration == null) {
      throw new NullPointerException(
          "No default RealmConfiguration was found. Call " +
          "setDefaultConfiguration() first");
    }
    return create(defaultConfiguration);
  }
  public static Realm getInstance(RealmConfiguration configuration) {
    if (configuration == null) {
      throw new NullPointerException(
          "A non-null RealmConfiguration must be provided");
    }
    return create(configuration);
  }
  public static void setDefaultConfiguration(RealmConfiguration configuration) {
    if (configuration == null) {
      throw new NullPointerException(
          "A non-null RealmConfiguration must be provided");
    }
    defaultConfiguration = configuration;
  }
  private static Realm create(RealmConfiguration config) {
    boolean autoRefresh = Looper.myLooper() != null;
    try {
      return createAndValidate(config, true, autoRefresh);
    } catch (RealmMigrationNeededException e) {
      if (config.shouldDeleteRealmIfMigrationNeeded()) {
        deleteRealm(config);
      } else {
        migrateRealm(config);
      }
      return createAndValidate(config, true, autoRefresh);
    }
  }
  private static synchronized Realm createAndValidate(RealmConfiguration config,
                                                      boolean validateSchema,
                                                      boolean autoRefresh) {
    byte[] key = config.getEncryptionKey();
    String canonicalPath = config.getPath();
    Map<String, Integer> localRefCount = referenceCount.get();
    Integer references = localRefCount.get(canonicalPath);
    if (references == null) {
      references = 0;
    }
    Map<String, Realm> realms = realmsCache.get();
    Realm realm = realms.get(canonicalPath);
    if (realm != null) {
      if (!Arrays.equals(realm.key, key)) {
        throw new IllegalStateException(DIFFERENT_KEY_MESSAGE);
      }
      localRefCount.put(canonicalPath, references + 1);
      return realm;
    }
    realm = new Realm(canonicalPath, key, autoRefresh);
    realms.put(canonicalPath, realm);
    realmsCache.set(realms);
    localRefCount.put(canonicalPath, references + 1);
    long currentVersion = realm.getVersion();
    long requiredVersion = config.getSchemaVersion();
    if (currentVersion != UNVERSIONED && currentVersion < requiredVersion) {
      realm.close();
      throw new RealmMigrationNeededException(
          canonicalPath,
          String.format("Realm on disc need to migrate from v%s to v%s",
                        currentVersion, requiredVersion));
    }
    if (currentVersion != UNVERSIONED && requiredVersion < currentVersion) {
      realm.close();
      throw new IllegalArgumentException(String.format(
          canonicalPath,
          "Realm on disc is newer than the one specified: v%s vs. v%s",
          currentVersion, requiredVersion));
    }
    if (references == 0) {
      AtomicInteger counter = openRealms.get(canonicalPath);
      if (counter == null) {
        openRealms.put(canonicalPath, new AtomicInteger(1));
      } else {
        counter.incrementAndGet();
      }
    }
    if (validateSchema) {
      try {
        initializeRealm(realm, config);
      } catch (RuntimeException e) {
        realm.close();
        throw e;
      }
    }
    return realm;
  }
  @SuppressWarnings("unchecked")
  private static void initializeRealm(Realm realm, RealmConfiguration config) {
    Set<Class<? extends RealmObject>> customSpec = config.getSchema();
    if (customSpec.size() > 0) {
      proxyClasses = new ArrayList<String>();
      for (Class<? extends RealmObject> clazz : customSpec) {
        proxyClasses.add(clazz.getName());
      }
    }
    long version = realm.getVersion();
    boolean commitNeeded = false;
    try {
      realm.beginTransaction();
      if (version == UNVERSIONED) {
        commitNeeded = true;
        realm.setVersion(config.getSchemaVersion());
      }
      for (Class<? extends RealmObject> modelClass :
           proxyMediator.getModelClasses()) {
        String modelClassName = modelClass.getSimpleName();
        if (version == UNVERSIONED) {
          proxyMediator.createTable(modelClass, realm.transaction);
        }
        proxyMediator.validateTable(modelClass, realm.transaction);
        realm.columnIndices.addClass(
            modelClass, proxyMediator.getColumnIndices(modelClass));
      }
    } finally {
      if (commitNeeded) {
        realm.commitTransaction();
      } else {
        realm.cancelTransaction();
      }
    }
  }
  public <E extends RealmObject> void createAllFromJson(Class<E> clazz,
                                                        JSONArray json) {
    if (clazz == null || json == null) {
      return;
    }
    for (int i = 0; i < json.length(); i++) {
      try {
        proxyMediator.createOrUpdateUsingJsonObject(
            clazz, this, json.getJSONObject(i), false);
      } catch (Exception e) {
        throw new RealmException("Could not map Json", e);
      }
    }
  }
  public <E extends RealmObject> void
  createOrUpdateAllFromJson(Class<E> clazz, JSONArray json) {
    if (clazz == null || json == null) {
      return;
    }
    checkHasPrimaryKey(clazz);
    for (int i = 0; i < json.length(); i++) {
      try {
        proxyMediator.createOrUpdateUsingJsonObject(
            clazz, this, json.getJSONObject(i), true);
      } catch (Exception e) {
        throw new RealmException("Could not map Json", e);
      }
    }
  }
  public <E extends RealmObject> void createAllFromJson(Class<E> clazz,
                                                        String json) {
    if (clazz == null || json == null || json.length() == 0) {
      return;
    }
    JSONArray arr;
    try {
      arr = new JSONArray(json);
    } catch (Exception e) {
      throw new RealmException("Could not create JSON array from string", e);
    }
    createAllFromJson(clazz, arr);
  }
  public <E extends RealmObject> void createOrUpdateAllFromJson(Class<E> clazz,
                                                                String json) {
    if (clazz == null || json == null || json.length() == 0) {
      return;
    }
    checkHasPrimaryKey(clazz);
    JSONArray arr;
    try {
      arr = new JSONArray(json);
    } catch (JSONException e) {
      throw new RealmException("Could not create JSON array from string", e);
    }
    createOrUpdateAllFromJson(clazz, arr);
  }
  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
  public <E extends RealmObject> void createAllFromJson(Class<E> clazz,
                                                        InputStream inputStream)
      throws IOException {
    if (clazz == null || inputStream == null) {
      return;
    }
    JsonReader reader =
        new JsonReader(new InputStreamReader(inputStream, "UTF-8"));
    try {
      reader.beginArray();
      while (reader.hasNext()) {
        proxyMediator.createUsingJsonStream(clazz, this, reader);
      }
      reader.endArray();
    } finally {
      reader.close();
    }
  }
  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
  public <E extends RealmObject> void createOrUpdateAllFromJson(Class<E> clazz,
                                                                InputStream in)
      throws IOException {
    if (clazz == null || in == null) {
      return;
    }
    checkHasPrimaryKey(clazz);
    Scanner scanner = null;
    try {
      scanner = getFullStringScanner(in);
      JSONArray json = new JSONArray(scanner.next());
      for (int i = 0; i < json.length(); i++) {
        proxyMediator.createOrUpdateUsingJsonObject(
            clazz, this, json.getJSONObject(i), true);
      }
    } catch (JSONException e) {
      throw new RealmException("Failed to read JSON", e);
    } finally {
      if (scanner != null) {
        scanner.close();
      }
    }
  }
  public <E extends RealmObject> E createObjectFromJson(Class<E> clazz,
                                                        JSONObject json) {
    if (clazz == null || json == null) {
      return null;
    }
    try {
      return proxyMediator.createOrUpdateUsingJsonObject(clazz, this, json,
                                                         false);
    } catch (Exception e) {
      throw new RealmException("Could not map Json", e);
    }
  }
  public <E extends RealmObject>
      E createOrUpdateObjectFromJson(Class<E> clazz, JSONObject json) {
    if (clazz == null || json == null) {
      return null;
    }
    checkHasPrimaryKey(clazz);
    try {
      return proxyMediator.createOrUpdateUsingJsonObject(clazz, this, json,
                                                         true);
    } catch (JSONException e) {
      throw new RealmException("Could not map Json", e);
    }
  }
  public <E extends RealmObject> E createObjectFromJson(Class<E> clazz,
                                                        String json) {
    if (clazz == null || json == null || json.length() == 0) {
      return null;
    }
    JSONObject obj;
    try {
      obj = new JSONObject(json);
    } catch (Exception e) {
      throw new RealmException("Could not create Json object from string", e);
    }
    return createObjectFromJson(clazz, obj);
  }
  public <E extends RealmObject> E createOrUpdateObjectFromJson(Class<E> clazz,
                                                                String json) {
    if (clazz == null || json == null || json.length() == 0) {
      return null;
    }
    checkHasPrimaryKey(clazz);
    JSONObject obj;
    try {
      obj = new JSONObject(json);
    } catch (Exception e) {
      throw new RealmException("Could not create Json object from string", e);
    }
    return createOrUpdateObjectFromJson(clazz, obj);
  }
  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
  public <E extends RealmObject> E createObjectFromJson(Class<E> clazz,
                                                        InputStream inputStream)
      throws IOException {
    if (clazz == null || inputStream == null) {
      return null;
    }
    JsonReader reader =
        new JsonReader(new InputStreamReader(inputStream, "UTF-8"));
    try {
      return proxyMediator.createUsingJsonStream(clazz, this, reader);
    } finally {
      reader.close();
    }
  }
  @TargetApi(Build.VERSION_CODES.HONEYCOMB)
  public <E extends RealmObject> E createOrUpdateObjectFromJson(Class<E> clazz,
                                                                InputStream in)
      throws IOException {
    if (clazz == null || in == null) {
      return null;
    }
    checkHasPrimaryKey(clazz);
    Scanner scanner = null;
    try {
      scanner = getFullStringScanner(in);
      JSONObject json = new JSONObject(scanner.next());
      return proxyMediator.createOrUpdateUsingJsonObject(clazz, this, json,
                                                         true);
    } catch (JSONException e) {
      throw new RealmException("Failed to read JSON", e);
    } finally {
      if (scanner != null) {
        scanner.close();
      }
    }
  }
  private Scanner getFullStringScanner(InputStream in) {
    return new Scanner(in, "UTF-8").useDelimiter("\\A");
  }
  public void writeCopyTo(File destination) throws IOException {
    writeEncryptedCopyTo(destination, null);
  }
  public void writeEncryptedCopyTo(File destination, byte[] key)
      throws IOException {
    if (destination == null) {
      throw new IllegalArgumentException(
          "The destination argument cannot be null");
    }
    checkIfValid();
    transaction.writeToFile(destination, key);
  }
  public <E extends RealmObject> E createObject(Class<E> clazz) {
    Table table = getTable(clazz);
    long rowIndex = table.addEmptyRow();
    return get(clazz, rowIndex);
  }
  <E extends RealmObject> E createObject(Class<E> clazz,
                                         Object primaryKeyValue) {
    Table table = getTable(clazz);
    long rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue);
    return get(clazz, rowIndex);
  }
  void remove(Class<? extends RealmObject> clazz, long objectIndex) {
    getTable(clazz).moveLastOver(objectIndex);
  }
  <E extends RealmObject> E get(Class<E> clazz, long rowIndex) {
    Table table = getTable(clazz);
    Row row = table.getRow(rowIndex);
    E result = proxyMediator.newInstance(clazz);
    result.row = row;
    result.realm = this;
    return result;
  }
  public <E extends RealmObject> E copyToRealm(E object) {
    checkNotNullObject(object);
    return copyOrUpdate(object, false);
  }
  public <E extends RealmObject> E copyToRealmOrUpdate(E object) {
    checkNotNullObject(object);
    checkHasPrimaryKey(object.getClass());
    return copyOrUpdate(object, true);
  }
  public <E extends RealmObject> List<E> copyToRealm(Iterable<E> objects) {
    if (objects == null) {
      return new ArrayList<E>();
    }
    ArrayList<E> realmObjects = new ArrayList<E>();
    for (E object : objects) {
      realmObjects.add(copyToRealm(object));
    }
    return realmObjects;
  }
  public <E extends RealmObject> List<E>
  copyToRealmOrUpdate(Iterable<E> objects) {
    if (objects == null) {
      return new ArrayList<E>();
    }
    ArrayList<E> realmObjects = new ArrayList<E>();
    for (E object : objects) {
      realmObjects.add(copyToRealmOrUpdate(object));
    }
    return realmObjects;
  }
  private static String getProxyClassName(String simpleClassName) {
    return "io.realm." + simpleClassName + "RealmProxy";
  }
  boolean contains(Class<? extends RealmObject> clazz) {
    return proxyMediator.getModelClasses().contains(clazz);
  }
  public <E extends RealmObject> RealmQuery<E> where(Class<E> clazz) {
    checkIfValid();
    return new RealmQuery<E>(this, clazz);
  }
  public <E extends RealmObject> RealmResults<E> allObjects(Class<E> clazz) {
    return where(clazz).findAll();
  }
  public <E extends RealmObject> RealmResults<E>
  allObjectsSorted(Class<E> clazz, String fieldName, boolean sortAscending) {
    checkIfValid();
    Table table = getTable(clazz);
    TableView.Order order =
        sortAscending ? TableView.Order.ascending : TableView.Order.descending;
    long columnIndex = columnIndices.getColumnIndex(clazz, fieldName);
    if (columnIndex < 0) {
      throw new IllegalArgumentException(
          String.format("Field name '%s' does not exist.", fieldName));
    }
    TableView tableView = table.getSortedView(columnIndex, order);
    return new RealmResults<E>(this, tableView, clazz);
  }
  public <E extends RealmObject> RealmResults<E>
  allObjectsSorted(Class<E> clazz, String fieldName1, boolean sortAscending1,
                   String fieldName2, boolean sortAscending2) {
    return allObjectsSorted(clazz, new String[] {fieldName1, fieldName2},
                            new boolean[] {sortAscending1, sortAscending2});
  }
  public <E extends RealmObject> RealmResults<E>
  allObjectsSorted(Class<E> clazz, String fieldName1, boolean sortAscending1,
                   String fieldName2, boolean sortAscending2, String fieldName3,
                   boolean sortAscending3) {
    return allObjectsSorted(
        clazz, new String[] {fieldName1, fieldName2, fieldName3},
        new boolean[] {sortAscending1, sortAscending2, sortAscending3});
  }
  @SuppressWarnings("unchecked")
  public <E extends RealmObject> RealmResults<E>
  allObjectsSorted(Class<E> clazz, String fieldNames[],
                   boolean sortAscending[]) {
    if (fieldNames == null) {
      throw new IllegalArgumentException("fieldNames must be provided.");
    } else if (sortAscending == null) {
      throw new IllegalArgumentException("sortAscending must be provided.");
    }
    Table table = this.getTable(clazz);
    long columnIndices[] = new long[fieldNames.length];
    for (int i = 0; i < fieldNames.length; i++) {
      String fieldName = fieldNames[i];
      long columnIndex = table.getColumnIndex(fieldName);
      if (columnIndex == -1) {
        throw new IllegalArgumentException(
            String.format("Field name '%s' does not exist.", fieldName));
      }
      columnIndices[i] = columnIndex;
    }
    TableView tableView = table.getSortedView(columnIndices, sortAscending);
    return new RealmResults(this, tableView, clazz);
  }
  public void addChangeListener(RealmChangeListener listener) {
    checkIfValid();
    changeListeners.add(new WeakReference<RealmChangeListener>(listener));
  }
  public void removeChangeListener(RealmChangeListener listener) {
    checkIfValid();
    changeListeners.remove(new WeakReference<RealmChangeListener>(listener));
  }
  public void removeAllChangeListeners() {
    checkIfValid();
    changeListeners.clear();
  }
  void sendNotifications() {
    Iterator<WeakReference<RealmChangeListener>> iterator =
        changeListeners.iterator();
    while (iterator.hasNext()) {
      RealmChangeListener listener = iterator.next().get();
      if (listener == null) {
        iterator.remove();
      } else {
        listener.onChange();
      }
    }
  }
  @SuppressWarnings("UnusedDeclaration")
  boolean hasChanged() {
    return sharedGroup.hasChanged();
  }
  @SuppressWarnings("UnusedDeclaration")
  public void refresh() {
    checkIfValid();
    transaction.advanceRead();
  }
  public void beginTransaction() {
    checkIfValid();
    transaction.promoteToWrite();
  }
  public void commitTransaction() {
    checkIfValid();
    transaction.commitAndContinueAsRead();
    for (Map.Entry<Handler, String> handlerIntegerEntry : handlers.entrySet()) {
      Handler handler = handlerIntegerEntry.getKey();
      String realmPath = handlerIntegerEntry.getValue();
      if (realmPath.equals(canonicalPath) &&
          !handler.hasMessages(REALM_CHANGED) &&
          handler.getLooper().getThread().isAlive() &&
          !handler.equals(this.handler)) {
        handler.sendEmptyMessage(REALM_CHANGED);
      }
    }
    sendNotifications();
  }
  public void cancelTransaction() {
    checkIfValid();
    transaction.rollbackAndContinueAsRead();
  }
  public void executeTransaction(Transaction transaction) {
    if (transaction == null)
      return;
    beginTransaction();
    try {
      transaction.execute(this);
      commitTransaction();
    } catch (RuntimeException e) {
      cancelTransaction();
      throw new RealmException("Error during transaction.", e);
    } catch (Error e) {
      cancelTransaction();
      throw e;
    }
  }
  public void clear(Class<? extends RealmObject> clazz) {
    getTable(clazz).clear();
  }
  Handler getHandler() {
    for (Map.Entry<Handler, String> entry : handlers.entrySet()) {
      if (entry.getValue().equals(canonicalPath)) {
        return entry.getKey();
      }
    }
    return null;
  }
  long getVersion() {
    if (!transaction.hasTable("metadata")) {
      return UNVERSIONED;
    }
    Table metadataTable = transaction.getTable("metadata");
    return metadataTable.getLong(0, 0);
  }
  void setVersion(long version) {
    Table metadataTable = transaction.getTable("metadata");
    if (metadataTable.getColumnCount() == 0) {
      metadataTable.addColumn(ColumnType.INTEGER, "version");
      metadataTable.addEmptyRow();
    }
    metadataTable.setLong(0, 0, version);
  }
  @SuppressWarnings("unchecked")
  private <E extends RealmObject> Class<? extends RealmObject>
  getRealmClassFromObject(E object) {
    if (object.realm != null) {
      return (Class<? extends RealmObject>)object.getClass().getSuperclass();
    } else {
      return object.getClass();
    }
  }
  @SuppressWarnings("unchecked")
  private <E extends RealmObject> E copyOrUpdate(E object, boolean update) {
    return proxyMediator.copyOrUpdate(
        this, object, update, new HashMap<RealmObject, RealmObjectProxy>());
  }
  private <E extends RealmObject> void checkNotNullObject(E object) {
    if (object == null) {
      throw new IllegalArgumentException(
          "Null objects cannot be copied into Realm.");
    }
  }
  private <E extends RealmObject> void checkHasPrimaryKey(E object) {
    Class<? extends RealmObject> objectClass = object.getClass();
    if (!getTable(objectClass).hasPrimaryKey()) {
      throw new IllegalArgumentException(
          "RealmObject has no @PrimaryKey defined: " +
          objectClass.getSimpleName().toString());
    }
  }
  private void checkHasPrimaryKey(Class<? extends RealmObject> clazz) {
    if (!getTable(clazz).hasPrimaryKey()) {
      throw new IllegalArgumentException(
          "A RealmObject with no @PrimaryKey cannot be updated: " +
          clazz.toString());
    }
  }
  @Deprecated
  public static void migrateRealmAtPath(String realmPath,
                                        RealmMigration migration) {
    migrateRealmAtPath(realmPath, null, migration, true);
  }
  @Deprecated
  public static void migrateRealmAtPath(String realmPath, byte[] key,
                                        RealmMigration migration) {
    migrateRealmAtPath(realmPath, key, migration, true);
  }
  @Deprecated
  public static void migrateRealmAtPath(String realmPath,
                                        RealmMigration migration,
                                        boolean autoRefresh) {
    migrateRealmAtPath(realmPath, null, migration, autoRefresh);
  }
  @Deprecated
  public static synchronized void
  migrateRealmAtPath(String realmPath, byte[] key, RealmMigration migration,
                     boolean autoUpdate) {
    File file = new File(realmPath);
    RealmConfiguration.Builder configuration =
        new RealmConfiguration.Builder(file.getParentFile())
            .name(file.getName())
            .migration(migration);
    if (key != null) {
      configuration.encryptionKey(key);
    }
    migrateRealm(configuration.build());
  }
  public static synchronized void
  migrateRealm(RealmConfiguration configuration) {
    Realm realm = Realm.createAndValidate(configuration, false,
                                          Looper.myLooper() != null);
    realm.beginTransaction();
    realm.setVersion(
        configuration.getMigration().execute(realm, realm.getVersion()));
    realm.commitTransaction();
    realm.close();
    realmsCache.remove();
  }
  @Deprecated
  public static boolean deleteRealmFile(Context context) {
    return deleteRealmFile(context, DEFAULT_REALM_NAME);
  }
  @Deprecated
  public static boolean deleteRealmFile(Context context, String fileName) {
    return deleteRealm(
        new RealmConfiguration.Builder(context).name(fileName).build());
  }
  public static synchronized boolean
  deleteRealm(RealmConfiguration configuration) {
    boolean result = true;
    String id = configuration.getPath();
    AtomicInteger counter = openRealms.get(id);
    if (counter != null && counter.get() > 0) {
      throw new IllegalStateException(
          "It's not allowed to delete the file associated with an open Realm. "
          + "Remember to close() all the instances of the Realm before " +
            "deleting its file.");
    }
    List<File> filesToDelete =
        Arrays.asList(new File(configuration.getPath()),
                      new File(configuration.getRealmDir(),
                               configuration.getRealmFileName() + ".lock"),
                      new File(configuration.getRealmDir(),
                               configuration.getRealmFileName() + ".lock_a"),
                      new File(configuration.getRealmDir(),
                               configuration.getRealmFileName() + ".lock_b"),
                      new File(configuration.getRealmDir(),
                               configuration.getRealmFileName() + ".log"));
    for (File fileToDelete : filesToDelete) {
      if (fileToDelete.exists()) {
        boolean deleteResult = fileToDelete.delete();
        if (!deleteResult) {
          result = false;
          RealmLog.w("Could not delete the file " + fileToDelete);
        }
      }
    }
    return result;
  }
  @Deprecated
  public static synchronized boolean compactRealmFile(Context context,
                                                      String fileName) {
    return compactRealm(
        new RealmConfiguration.Builder(context).name(fileName).build());
  }
  @Deprecated
  public static boolean compactRealmFile(Context context) {
    return compactRealm(new RealmConfiguration.Builder(context).build());
  }
  public static boolean compactRealm(RealmConfiguration configuration) {
    if (configuration.getEncryptionKey() != null) {
      throw new IllegalArgumentException(
          "Cannot currently compact an encrypted Realm.");
    }
    File realmFile =
        new File(configuration.getRealmDir(), configuration.getRealmFileName());
    String canonicalPath = getCanonicalPath(realmFile);
    if (openRealms.get(canonicalPath).get() > 0) {
      throw new IllegalStateException("Cannot compact an open Realm");
    }
    SharedGroup sharedGroup = null;
    boolean result = false;
    try {
      sharedGroup = new SharedGroup(canonicalPath, false,
                                    configuration.getEncryptionKey());
      result = sharedGroup.compact();
    } finally {
      if (sharedGroup != null) {
        sharedGroup.close();
      }
    }
    return result;
  }
  public String getPath() { return canonicalPath; }
  static String getCanonicalPath(File realmFile) {
    try {
      return realmFile.getCanonicalPath();
    } catch (IOException e) {
      throw new RealmException(
          "Could not resolve the canonical path to the Realm file: " +
          realmFile.getAbsolutePath());
    }
  }
  public interface Transaction {
    public void execute(Realm realm);
  }
}