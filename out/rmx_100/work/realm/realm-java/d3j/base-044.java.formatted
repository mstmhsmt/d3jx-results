// generated by Diff/AST Java Unparser
package io.realm;
import android.annotation.SuppressLint;
import android.annotation.TargetApi;
import android.content.Context;
import android.os.Build;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.util.JsonReader;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import java.io.Closeable;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import io.realm.exceptions.RealmException;
import io.realm.exceptions.RealmIOException;
import io.realm.exceptions.RealmMigrationNeededException;
import io.realm.internal.ColumnIndices;
import io.realm.internal.ColumnType;
import io.realm.internal.ImplicitTransaction;
import io.realm.internal.RealmJson;
import io.realm.internal.Row;
import io.realm.internal.SharedGroup;
import io.realm.internal.Table;
import io.realm.internal.TableView;
import io.realm.internal.android.DebugAndroidLogger;
import io.realm.internal.android.ReleaseAndroidLogger;
import io.realm.internal.log.RealmLog;
public final class Realm implements Closeable
{
    public static final String DEFAULT_REALM_NAME = "default.realm";
    private static final String TAG = "REALM";
    private static final String TABLE_PREFIX = "class_";
    protected static final ThreadLocal<Map<String, Realm>> realmsCache = new ThreadLocal<Map<String, Realm>>() {
        @SuppressLint("UseSparseArrays") @Override protected Map<String, Realm> initialValue()
        {
            return new HashMap<String, Realm>();
        }
    };
    private static final ThreadLocal<Map<String, Integer>> referenceCount = new ThreadLocal<Map<String, Integer>>() {
        @SuppressLint("UseSparseArrays") @Override protected Map<String, Integer> initialValue()
        {
            return new HashMap<String, Integer>();
        }
    };
    private static final int REALM_CHANGED = 14930352;
    protected static final Map<Handler, String> handlers = new ConcurrentHashMap<Handler, String>();
    private static final Map<String, AtomicInteger> openRealms = new ConcurrentHashMap<String, AtomicInteger>();
    private static final String APT_NOT_EXECUTED_MESSAGE = "Annotation processor may not have been executed.";
    private static final String INCORRECT_THREAD_MESSAGE =
        "Realm access from incorrect thread. Realm objects can only be "
        + "accessed on the thread they where created.";
    private static final String CLOSED_REALM_MESSAGE =
        "This Realm instance has already been closed, making it unusable.";
    private static final String INVALID_KEY_MESSAGE = "The provided key is invalid. It should either be null or be 64"
                                                      + " bytes long.";
    private static final String DIFFERENT_KEY_MESSAGE = "Wrong key used to decrypt Realm.";
    @SuppressWarnings("UnusedDeclaration")
    private static SharedGroup.Durability defaultDurability = SharedGroup.Durability.FULL;
    private boolean autoRefresh;
    private Handler handler;
    private final byte[] key;
    private final String canonicalPath;
    private SharedGroup sharedGroup;
    private final ImplicitTransaction transaction;
    private final RealmJson realmJson = getRealmJson();
    private final Map<Class<?>, String> simpleClassNames = new HashMap<Class<?>, String>();
    private final Map<String, Class<?>> generatedClasses = new HashMap<String, Class<?>>();
    private final Map<Class<?>, Constructor> constructors = new HashMap<Class<?>, Constructor>();
    private final Map<Class<?>, Method> initTableMethods = new HashMap<Class<?>, Method>();
    private final Map<Class<?>, Method> insertOrUpdateMethods = new HashMap<Class<?>, Method>();
    private final Map<Class<?>, Constructor> generatedConstructors = new HashMap<Class<?>, Constructor>();
    private final Map<Class<?>, String> proxiedClassNames = new HashMap<Class<?>, String>();
    private final List<RealmChangeListener> changeListeners = new ArrayList<RealmChangeListener>();
    private final Map<Class<?>, Table> tables = new HashMap<Class<?>, Table>();
    private static final Set<Class<? extends RealmObject>> customSchema = new HashSet<Class<? extends RealmObject>>();
    private static final long UNVERSIONED = -1;
    final ColumnIndices columnIndices = new ColumnIndices();
    static
    {
        RealmLog.add(BuildConfig.DEBUG ? new DebugAndroidLogger() : new ReleaseAndroidLogger());
    }
    protected void checkIfValid()
    {
        if (sharedGroup == null)
        {
            throw new IllegalStateException(CLOSED_REALM_MESSAGE);
        }
        Realm currentRealm = realmsCache.get().get(canonicalPath);
        if (currentRealm != this)
        {
            throw new IllegalStateException(INCORRECT_THREAD_MESSAGE);
        }
    }
    private Realm(String canonicalPath, byte[] key, boolean autoRefresh)
    {
        if (key != null && key.length != 64)
        {
            throw new IllegalArgumentException(INVALID_KEY_MESSAGE);
        }
        this.sharedGroup = new SharedGroup(canonicalPath, true, key);
        this.transaction = sharedGroup.beginImplicitTransaction();
        this.canonicalPath = canonicalPath;
        this.key = key;
        setAutoRefresh(autoRefresh);
    }
    @Override protected void finalize() throws Throwable
    {
        if (sharedGroup != null)
        {
            RealmLog.w("Remember to call close() on all Realm instances. "
                       + "Realm " + canonicalPath + " is being finalized without being closed, "
                       + "this can lead to running out of native memory.");
        }
        super.finalize();
    }
    @Override public void close()
    {
        Map<String, Integer> localRefCount = referenceCount.get();
        Integer references = localRefCount.get(canonicalPath);
        if (references == null)
        {
            references = 0;
        }
        if (sharedGroup != null && references == 1)
        {
            realmsCache.get().remove(canonicalPath);
            sharedGroup.close();
            sharedGroup = null;
            AtomicInteger counter = openRealms.get(canonicalPath);
            counter.decrementAndGet();
        }
        int refCount = references - 1;
        if (refCount < 0)
        {
            RealmLog.w("Calling close() on a Realm that is already closed: " + canonicalPath);
        }
        localRefCount.put(canonicalPath, Math.max(0, refCount));
        if (handler != null && refCount <= 0)
        {
            removeHandler(handler);
        }
    }
    private void removeHandler(Handler handler)
    {
        handler.removeCallbacksAndMessages(null);
        handlers.remove(handler);
    }
    public RealmJson getRealmJson()
    {
        Class<?> clazz;
        try
        {
            clazz = Class.forName("io.realm.RealmJsonImpl");
            Constructor<?> constructor = clazz.getDeclaredConstructors()[0];
            constructor.setAccessible(true);
            return (RealmJson)constructor.newInstance();
        }
        catch (ClassNotFoundException e)
        {
            throw new RealmException("Could not find io.realm.RealmJsonImpl", e);
        }
        catch (InvocationTargetException e)
        {
            throw new RealmException("Could not create an instance of io.realm.RealmJsonImpl", e);
        }
        catch (InstantiationException e)
        {
            throw new RealmException("Could not create an instance of io.realm.RealmJsonImpl", e);
        }
        catch (IllegalAccessException e)
        {
            throw new RealmException("Could not create an instance of io.realm.RealmJsonImpl", e);
        }
    }
    private class RealmCallback implements Handler.Callback
    {
        @Override public boolean handleMessage(Message message)
        {
            if (message.what == REALM_CHANGED)
            {
                transaction.advanceRead();
                sendNotifications();
            }
            return true;
        }
    }
    public boolean isAutoRefresh()
    {
        return autoRefresh;
    }
    public void setAutoRefresh(boolean autoRefresh)
    {
        if (autoRefresh && Looper.myLooper() == null)
        {
            throw new IllegalStateException("Cannot set auto-refresh in a Thread without a Looper");
        }
        if (autoRefresh && !this.autoRefresh)
        {
            handler = new Handler(new RealmCallback());
            handlers.put(handler, canonicalPath);
        }
        else if (!autoRefresh && this.autoRefresh && handler != null)
        {
            removeHandler(handler);
        }
        this.autoRefresh = autoRefresh;
    }
    public Table getTable(Class<?> clazz)
    {
        final String proxySuffix = "RealmProxy";
        String proxiedClassName = proxiedClassNames.get(clazz);
        if (proxiedClassName == null)
        {
            String classSimpleName = clazz.getSimpleName();
            proxiedClassName = classSimpleName.replace(proxySuffix, "");
            proxiedClassNames.put(clazz, proxiedClassName);
        }
        return transaction.getTable(TABLE_PREFIX + proxiedClassName);
    }
    public static Realm getInstance(Context context)
    {
        return Realm.getInstance(context, DEFAULT_REALM_NAME);
    }
    @SuppressWarnings("UnusedDeclaration") public static Realm getInstance(Context context, String fileName)
    {
        return Realm.getInstance(context, fileName, null);
    }
    @SuppressWarnings("UnusedDeclaration") public static Realm getInstance(Context context, byte[] key)
    {
        return Realm.getInstance(context, DEFAULT_REALM_NAME, key);
    }
    @SuppressWarnings("UnusedDeclaration") public static Realm getInstance(Context context, String fileName, byte[] key)
    {
        return Realm.create(context.getFilesDir(), fileName, key);
    }
    @SuppressWarnings("UnusedDeclaration") public static Realm getInstance(File writeableFolder)
    {
        return Realm.create(writeableFolder, DEFAULT_REALM_NAME, null);
    }
    @SuppressWarnings("UnusedDeclaration") public static Realm getInstance(File writeableFolder, String fileName)
    {
        return Realm.create(writeableFolder, fileName, null);
    }
    @SuppressWarnings("UnusedDeclaration") public static Realm getInstance(File writeableFolder, byte[] key)
    {
        return Realm.create(writeableFolder, DEFAULT_REALM_NAME, key);
    }
    @SuppressWarnings("UnusedDeclaration")
    public static Realm getInstance(File writeableFolder, String fileName, byte[] key)
    {
        return Realm.create(writeableFolder, fileName, key);
    }
    private static Realm create(File writableFolder, String filename, byte[] key)
    {
        checkValidRealmPath(writableFolder, filename);
        String canonicalPath = getCanonicalPath(new File(writableFolder, filename));
        if (Looper.myLooper() != null)
        {
            return createAndValidate(canonicalPath, key, true, true);
        }
        else
        {
            return createAndValidate(canonicalPath, key, true, false);
        }
    }
    private static synchronized Realm createAndValidate(String canonicalPath, byte[] key, boolean validateSchema,
                                                        boolean autoRefresh)
    {
        String id = canonicalPath;
        Map<String, Integer> localRefCount = referenceCount.get();
        Integer references = localRefCount.get(id);
        if (references == null)
        {
            references = 0;
        }
        Map<String, Realm> realms = realmsCache.get();
        Realm realm = realms.get(id);
        if (realm != null)
        {
            if (!Arrays.equals(realm.key, key))
            {
                throw new IllegalStateException(DIFFERENT_KEY_MESSAGE);
            }
            localRefCount.put(id, references + 1);
            return realm;
        }
        realm = new Realm(canonicalPath, key, autoRefresh);
        realms.put(id, realm);
        realmsCache.set(realms);
        localRefCount.put(id, references + 1);
        if (references == 0)
        {
            AtomicInteger counter = openRealms.get(id);
            if (counter == null)
            {
                openRealms.put(id, new AtomicInteger(1));
            }
            else
            {
                counter.incrementAndGet();
            }
        }
        if (validateSchema)
        {
            try
            {
                initializeRealm(realm);
            }
            catch (RuntimeException e)
            {
                realm.close();
                throw e;
            }
        }
        return realm;
    }
    private static void checkValidRealmPath(File writableFolder, String filename)
    {
        if (filename == null || filename.isEmpty())
        {
            throw new IllegalArgumentException("Non-empty filename must be provided");
        }
        if (writableFolder == null || !writableFolder.isDirectory())
        {
            throw new IllegalArgumentException(("An existing folder must be provided. Yours was " +
                                                (writableFolder != null ? writableFolder.getAbsolutePath() : "null")));
        }
    }
    @SuppressWarnings("unchecked") private static void initializeRealm(Realm realm)
    {
        Class<?> validationClass;
        try
        {
            validationClass = Class.forName("io.realm.ValidationList");
        }
        catch (ClassNotFoundException e)
        {
            throw new RealmException("Could not find the generated ValidationList class: " + APT_NOT_EXECUTED_MESSAGE);
        }
        Method getProxyClassesMethod;
        try
        {
            getProxyClassesMethod = validationClass.getMethod("getProxyClasses");
        }
        catch (NoSuchMethodException e)
        {
            throw new RealmException("Could not find the getProxyClasses method in "
                                     + "the ValidationList class: " + APT_NOT_EXECUTED_MESSAGE);
        }
        List<String> proxyClasses;
        try
        {
            proxyClasses = (List<String>)getProxyClassesMethod.invoke(null);
        }
        catch (IllegalAccessException e)
        {
            throw new RealmException("Could not execute the getProxyClasses method "
                                     + "in the ValidationList class: " + APT_NOT_EXECUTED_MESSAGE);
        }
        catch (InvocationTargetException e)
        {
            throw new RealmException("An exception was thrown in the getProxyClasses method in the "
                                     + "ValidationList class: " + APT_NOT_EXECUTED_MESSAGE);
        }
        if (customSchema.size() > 0)
        {
            proxyClasses = new ArrayList<String>();
            for (Class<? extends RealmObject> clazz : customSchema)
            {
                proxyClasses.add(clazz.getName());
            }
        }
        long version = realm.getVersion();
        boolean commitNeeded = false;
        try
        {
            realm.beginTransaction();
            if (version == UNVERSIONED)
            {
                realm.setVersion(0);
                commitNeeded = true;
            }
            for (String className : proxyClasses)
            {
                String[] splitted = className.split("\\.");
                String modelClassName = splitted[splitted.length - 1];
                String generatedClassName = getProxyClassName(modelClassName);
                Class<?> generatedClass;
                try
                {
                    generatedClass = Class.forName(generatedClassName);
                }
                catch (ClassNotFoundException e)
                {
                    throw new RealmException("Could not find the generated " + generatedClassName +
                                             " class: " + APT_NOT_EXECUTED_MESSAGE);
                }
                if (version == UNVERSIONED)
                {
                    Method initTableMethod;
                    try
                    {
                        initTableMethod =
                            generatedClass.getMethod("initTable", new Class[] {ImplicitTransaction.class});
                    }
                    catch (NoSuchMethodException e)
                    {
                        throw new RealmException("Could not find the initTable method in the generated " +
                                                 generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
                    }
                    try
                    {
                        initTableMethod.invoke(null, realm.transaction);
                        commitNeeded = true;
                    }
                    catch (IllegalAccessException e)
                    {
                        throw new RealmException("Could not execute the initTable method in the " + generatedClassName +
                                                 " class: " + APT_NOT_EXECUTED_MESSAGE);
                    }
                    catch (InvocationTargetException e)
                    {
                        throw new RealmException("An exception was thrown in the initTable method in the " +
                                                 generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
                    }
                }
                Method validateMethod;
                try
                {
                    validateMethod = generatedClass.getMethod("validateTable", new Class[] {ImplicitTransaction.class});
                }
                catch (NoSuchMethodException e)
                {
                    throw new RealmException("Could not find the validateTable method in the generated " +
                                             generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
                }
                try
                {
                    validateMethod.invoke(null, realm.transaction);
                }
                catch (IllegalAccessException e)
                {
                    throw new RealmException("Could not execute the validateTable method in the " + generatedClassName +
                                             " class: " + APT_NOT_EXECUTED_MESSAGE);
                }
                catch (InvocationTargetException e)
                {
                    throw new RealmMigrationNeededException(realm.getPath(), e.getMessage(), e);
                }
                Method columnIndiciesMethod;
                try
                {
                    columnIndiciesMethod = generatedClass.getMethod("getColumnIndices");
                }
                catch (NoSuchMethodException e)
                {
                    throw new RealmException("Could not find the getColumnIndices method in the generated " +
                                             generatedClassName + " class: " + APT_NOT_EXECUTED_MESSAGE);
                }
                Map<String, Long> indices;
                try
                {
                    indices = (Map<String, Long>)columnIndiciesMethod.invoke(null);
                }
                catch (IllegalAccessException e)
                {
                    throw new RealmException("Could not execute the getColumnIndices "
                                                 + "method in the generated " + generatedClassName + " class",
                                             e);
                }
                catch (InvocationTargetException e)
                {
                    throw new RealmException("An exception was thrown in the "
                                                 + "getColumnIndices method in the generated " + generatedClassName +
                                                 " class",
                                             e);
                }
                realm.columnIndices.addClass((Class<? extends RealmObject>)generatedClass.getSuperclass(), indices);
            }
        }
        finally
        {
            if (commitNeeded)
            {
                realm.commitTransaction();
            }
            else
            {
                realm.cancelTransaction();
            }
        }
    }
    public <E extends RealmObject> void createAllFromJson(Class<E> clazz, JSONArray json)
    {
        if (clazz == null || json == null)
        {
            return;
        }
        for (int i = 0; i < json.length(); i++)
        {
            try
            {
                realmJson.createOrUpdateUsingJsonObject(clazz, this, json.getJSONObject(i), false);
            }
            catch (Exception e)
            {
                throw new RealmException("Could not map Json", e);
            }
        }
    }
    public <E extends RealmObject> void createOrUpdateAllFromJson(Class<E> clazz, JSONArray json)
    {
        if (clazz == null || json == null)
        {
            return;
        }
        checkHasPrimaryKey(clazz);
        for (int i = 0; i < json.length(); i++)
        {
            try
            {
                realmJson.createOrUpdateUsingJsonObject(clazz, this, json.getJSONObject(i), true);
            }
            catch (Exception e)
            {
                throw new RealmException("Could not map Json", e);
            }
        }
    }
    public <E extends RealmObject> void createAllFromJson(Class<E> clazz, String json)
    {
        if (clazz == null || json == null || json.length() == 0)
        {
            return;
        }
        JSONArray arr;
        try
        {
            arr = new JSONArray(json);
        }
        catch (Exception e)
        {
            throw new RealmException("Could not create JSON array from string", e);
        }
        createAllFromJson(clazz, arr);
    }
    public <E extends RealmObject> void createOrUpdateAllFromJson(Class<E> clazz, String json)
    {
        if (clazz == null || json == null || json.length() == 0)
        {
            return;
        }
        checkHasPrimaryKey(clazz);
        JSONArray arr;
        try
        {
            arr = new JSONArray(json);
        }
        catch (JSONException e)
        {
            throw new RealmException("Could not create JSON array from string", e);
        }
        createOrUpdateAllFromJson(clazz, arr);
    }
    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
    public <E extends RealmObject> void createAllFromJson(Class<E> clazz, InputStream inputStream) throws IOException
    {
        if (clazz == null || inputStream == null)
        {
            return;
        }
        JsonReader reader = new JsonReader(new InputStreamReader(inputStream, "UTF-8"));
        try
        {
            reader.beginArray();
            while (reader.hasNext())
            {
                realmJson.createUsingJsonStream(clazz, this, reader);
            }
            reader.endArray();
        }
        finally
        {
            reader.close();
        }
    }
    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
    public <E extends RealmObject> void createOrUpdateAllFromJson(Class<E> clazz, InputStream in) throws IOException
    {
        if (clazz == null || in == null)
        {
            return;
        }
        checkHasPrimaryKey(clazz);
        Scanner scanner = null;
        try
        {
            scanner = getFullStringScanner(in);
            JSONArray json = new JSONArray(scanner.next());
            for (int i = 0; i < json.length(); i++)
            {
                realmJson.createOrUpdateUsingJsonObject(clazz, this, json.getJSONObject(i), true);
            }
        }
        catch (JSONException e)
        {
            throw new RealmException("Failed to read JSON", e);
        }
        finally
        {
            if (scanner != null)
            {
                scanner.close();
            }
        }
    }
    public <E extends RealmObject> E createObjectFromJson(Class<E> clazz, JSONObject json)
    {
        if (clazz == null || json == null)
        {
            return null;
        }
        try
        {
            return realmJson.createOrUpdateUsingJsonObject(clazz, this, json, false);
        }
        catch (Exception e)
        {
            throw new RealmException("Could not map Json", e);
        }
    }
    public <E extends RealmObject> E createOrUpdateObjectFromJson(Class<E> clazz, JSONObject json)
    {
        if (clazz == null || json == null)
        {
            return null;
        }
        checkHasPrimaryKey(clazz);
        try
        {
            return realmJson.createOrUpdateUsingJsonObject(clazz, this, json, true);
        }
        catch (JSONException e)
        {
            throw new RealmException("Could not map Json", e);
        }
    }
    public <E extends RealmObject> E createObjectFromJson(Class<E> clazz, String json)
    {
        if (clazz == null || json == null || json.length() == 0)
        {
            return null;
        }
        JSONObject obj;
        try
        {
            obj = new JSONObject(json);
        }
        catch (Exception e)
        {
            throw new RealmException("Could not create Json object from string", e);
        }
        return createObjectFromJson(clazz, obj);
    }
    public <E extends RealmObject> E createOrUpdateObjectFromJson(Class<E> clazz, String json)
    {
        if (clazz == null || json == null || json.length() == 0)
        {
            return null;
        }
        checkHasPrimaryKey(clazz);
        JSONObject obj;
        try
        {
            obj = new JSONObject(json);
        }
        catch (Exception e)
        {
            throw new RealmException("Could not create Json object from string", e);
        }
        return createOrUpdateObjectFromJson(clazz, obj);
    }
    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
    public <E extends RealmObject> E createObjectFromJson(Class<E> clazz, InputStream inputStream) throws IOException
    {
        if (clazz == null || inputStream == null)
        {
            return null;
        }
        JsonReader reader = new JsonReader(new InputStreamReader(inputStream, "UTF-8"));
        try
        {
            return realmJson.createUsingJsonStream(clazz, this, reader);
        }
        finally
        {
            reader.close();
        }
    }
    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
    public <E extends RealmObject> E createOrUpdateObjectFromJson(Class<E> clazz, InputStream in) throws IOException
    {
        if (clazz == null || in == null)
        {
            return null;
        }
        checkHasPrimaryKey(clazz);
        Scanner scanner = null;
        try
        {
            scanner = getFullStringScanner(in);
            JSONObject json = new JSONObject(scanner.next());
            return realmJson.createOrUpdateUsingJsonObject(clazz, this, json, true);
        }
        catch (JSONException e)
        {
            throw new RealmException("Failed to read JSON", e);
        }
        finally
        {
            if (scanner != null)
            {
                scanner.close();
            }
        }
    }
    private Scanner getFullStringScanner(InputStream in)
    {
        return new Scanner(in, "UTF-8").useDelimiter("\\A");
    }
    public void writeCopyTo(File destination) throws IOException
    {
        writeEncryptedCopyTo(destination, null);
    }
    public void writeEncryptedCopyTo(File destination, byte[] key) throws IOException
    {
        if (destination == null)
        {
            throw new IllegalArgumentException("The destination argument cannot be null");
        }
        checkIfValid();
        transaction.writeToFile(destination, key);
    }
    public <E extends RealmObject> E createObject(Class<E> clazz)
    {
        Table table = initTable(clazz);
        long rowIndex = table.addEmptyRow();
        return get(clazz, rowIndex);
    }
    <E extends RealmObject> E createObject(Class<E> clazz, Object primaryKeyValue)
    {
        Table table = initTable(clazz);
        long rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue);
        return get(clazz, rowIndex);
    }
    private <E extends RealmObject> Table initTable(Class<E> clazz)
    {
        Table table = tables.get(clazz);
        if (table == null)
        {
            Class<?> generatedClass = getProxyClass(clazz);
            Method method = initTableMethods.get(generatedClass);
            if (method == null)
            {
                try
                {
                    method = generatedClass.getMethod("initTable", new Class[] {ImplicitTransaction.class});
                }
                catch (NoSuchMethodException e)
                {
                    throw new RealmException("Could not find the initTable() method in "
                                             + "generated proxy class: " + APT_NOT_EXECUTED_MESSAGE);
                }
                initTableMethods.put(generatedClass, method);
            }
            try
            {
                table = (Table)method.invoke(null, transaction);
                tables.put(clazz, table);
            }
            catch (IllegalAccessException e)
            {
                throw new RealmException("Could not launch the initTable method: " + APT_NOT_EXECUTED_MESSAGE);
            }
            catch (InvocationTargetException e)
            {
                e.printStackTrace();
                throw new RealmException("An exception occurred while running the initTable method: " +
                                         APT_NOT_EXECUTED_MESSAGE);
            }
        }
        return table;
    }
    private Class<?> getProxyClass(Class<?> clazz)
    {
        String simpleClassName = getClassSimpleName(clazz);
        String generatedClassName = getProxyClassName(simpleClassName);
        Class<?> generatedClass = generatedClasses.get(generatedClassName);
        if (generatedClass == null)
        {
            try
            {
                generatedClass = Class.forName(generatedClassName);
            }
            catch (ClassNotFoundException e)
            {
                throw new RealmException("Could not find the generated proxy class: " + APT_NOT_EXECUTED_MESSAGE);
            }
            generatedClasses.put(generatedClassName, generatedClass);
        }
        return generatedClass;
    }
    <E> void remove(Class<E> clazz, long objectIndex)
    {
        getTable(clazz).moveLastOver(objectIndex);
    }
    @SuppressWarnings("unchecked")<E extends RealmObject> E get(Class<E> clazz, long rowIndex)
    {
        E result;
        Table table = tables.get(clazz);
        if (table == null)
        {
            String simpleClassName = getClassSimpleName(clazz);
            table = transaction.getTable(TABLE_PREFIX + simpleClassName);
            tables.put(clazz, table);
        }
        Row row = table.getRow(rowIndex);
        Constructor constructor = generatedConstructors.get(clazz);
        if (constructor == null)
        {
            String simpleClassName = getClassSimpleName(clazz);
            String generatedClassName = getProxyClassName(simpleClassName);
            Class<?> generatedClass = generatedClasses.get(generatedClassName);
            if (generatedClass == null)
            {
                try
                {
                    generatedClass = Class.forName(generatedClassName);
                }
                catch (ClassNotFoundException e)
                {
                    throw new RealmException("Could not find the generated proxy class: " + APT_NOT_EXECUTED_MESSAGE);
                }
                generatedClasses.put(generatedClassName, generatedClass);
            }
            constructor = constructors.get(generatedClass);
            if (constructor == null)
            {
                try
                {
                    constructor = generatedClass.getConstructor();
                }
                catch (NoSuchMethodException e)
                {
                    throw new RealmException("Could not find the constructor in generated proxy class: " +
                                             APT_NOT_EXECUTED_MESSAGE);
                }
                constructors.put(generatedClass, constructor);
                generatedConstructors.put(clazz, constructor);
            }
        }
        try
        {
            result = (E)constructor.newInstance();
        }
        catch (InstantiationException e)
        {
            throw new RealmException("Could not instantiate the proxy class");
        }
        catch (IllegalAccessException e)
        {
            throw new RealmException("Could not run the constructor of the proxy class");
        }
        catch (InvocationTargetException e)
        {
            e.printStackTrace();
            throw new RealmException("An exception occurred while instantiating the proxy class");
        }
        result.row = row;
        result.realm = this;
        return result;
    }
    public <E extends RealmObject> E copyToRealm(E object)
    {
        checkNotNullObject(object);
        return copyOrUpdate(object, false);
    }
    public <E extends RealmObject> E copyToRealmOrUpdate(E object)
    {
        checkNotNullObject(object);
        checkHasPrimaryKey(object);
        return copyOrUpdate(object, true);
    }
    public <E extends RealmObject> List<E> copyToRealm(Iterable<E> objects)
    {
        if (objects == null)
        {
            return new ArrayList<E>();
        }
        ArrayList<E> realmObjects = new ArrayList<E>();
        for (E object : objects)
        {
            realmObjects.add(copyToRealm(object));
        }
        return realmObjects;
    }
    public <E extends RealmObject> List<E> copyToRealmOrUpdate(Iterable<E> objects)
    {
        if (objects == null)
        {
            return new ArrayList<E>();
        }
        ArrayList<E> realmObjects = new ArrayList<E>();
        for (E object : objects)
        {
            realmObjects.add(copyToRealmOrUpdate(object));
        }
        return realmObjects;
    }
    private static String getProxyClassName(String simpleClassName)
    {
        return "io.realm." + simpleClassName + "RealmProxy";
    }
    boolean contains(Class<?> clazz)
    {
        return transaction.hasTable(TABLE_PREFIX + getClassSimpleName(clazz));
    }
    public <E extends RealmObject> RealmQuery<E> where(Class<E> clazz)
    {
        checkIfValid();
        return new RealmQuery<E>(this, clazz);
    }
    public <E extends RealmObject> RealmResults<E> allObjects(Class<E> clazz)
    {
        return where(clazz).findAll();
    }
    public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName,
                                                                    boolean sortAscending)
    {
        checkIfValid();
        Table table = getTable(clazz);
        TableView.Order order = sortAscending ? TableView.Order.ascending : TableView.Order.descending;
        long columnIndex = columnIndices.getColumnIndex(clazz, fieldName);
        if (columnIndex < 0)
        {
            throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
        }
        TableView tableView = table.getSortedView(columnIndex, order);
        return new RealmResults<E>(this, tableView, clazz);
    }
    public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName1,
                                                                    boolean sortAscending1, String fieldName2,
                                                                    boolean sortAscending2)
    {
        return allObjectsSorted(clazz, new String[] {fieldName1, fieldName2},
                                new boolean[] {sortAscending1, sortAscending2});
    }
    public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldName1,
                                                                    boolean sortAscending1, String fieldName2,
                                                                    boolean sortAscending2, String fieldName3,
                                                                    boolean sortAscending3)
    {
        return allObjectsSorted(clazz, new String[] {fieldName1, fieldName2, fieldName3},
                                new boolean[] {sortAscending1, sortAscending2, sortAscending3});
    }
    @SuppressWarnings("unchecked")
    public <E extends RealmObject> RealmResults<E> allObjectsSorted(Class<E> clazz, String fieldNames[],
                                                                    boolean sortAscending[])
    {
        if (fieldNames == null)
        {
            throw new IllegalArgumentException("fieldNames must be provided.");
        }
        else if (sortAscending == null)
        {
            throw new IllegalArgumentException("sortAscending must be provided.");
        }
        Table table = this.getTable(clazz);
        long columnIndices[] = new long[fieldNames.length];
        for (int i = 0; i < fieldNames.length; i++)
        {
            String fieldName = fieldNames[i];
            long columnIndex = table.getColumnIndex(fieldName);
            if (columnIndex == -1)
            {
                throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
            }
            columnIndices[i] = columnIndex;
        }
        TableView tableView = table.getSortedView(columnIndices, sortAscending);
        return new RealmResults(this, tableView, clazz);
    }
    public void addChangeListener(RealmChangeListener listener)
    {
        checkIfValid();
        changeListeners.add(listener);
    }
    public void removeChangeListener(RealmChangeListener listener)
    {
        checkIfValid();
        changeListeners.remove(listener);
    }
    public void removeAllChangeListeners()
    {
        checkIfValid();
        changeListeners.clear();
    }
    void sendNotifications()
    {
        List<RealmChangeListener> defensiveCopy = new ArrayList<RealmChangeListener>(changeListeners);
        for (RealmChangeListener listener : defensiveCopy)
        {
            listener.onChange();
        }
    }
    @SuppressWarnings("UnusedDeclaration") boolean hasChanged()
    {
        return sharedGroup.hasChanged();
    }
    @SuppressWarnings("UnusedDeclaration") public void refresh()
    {
        checkIfValid();
        transaction.advanceRead();
    }
    public void beginTransaction()
    {
        checkIfValid();
        transaction.promoteToWrite();
    }
    public void commitTransaction()
    {
        checkIfValid();
        transaction.commitAndContinueAsRead();
        for (Map.Entry<Handler, String> handlerIntegerEntry : handlers.entrySet())
        {
            Handler handler = handlerIntegerEntry.getKey();
            String realmPath = handlerIntegerEntry.getValue();
            if (realmPath.equals(canonicalPath) && !handler.hasMessages(REALM_CHANGED) &&
                handler.getLooper().getThread().isAlive() && !handler.equals(this.handler))
            {
                handler.sendEmptyMessage(REALM_CHANGED);
            }
        }
        sendNotifications();
    }
    public void cancelTransaction()
    {
        checkIfValid();
        transaction.rollbackAndContinueAsRead();
    }
    public void executeTransaction(Transaction transaction)
    {
        if (transaction == null)
            return;
        beginTransaction();
        try
        {
            transaction.execute(this);
            commitTransaction();
        }
        catch (RuntimeException e)
        {
            cancelTransaction();
            throw new RealmException("Error during transaction.", e);
        }
        catch (Error e)
        {
            cancelTransaction();
            throw e;
        }
    }
    public void clear(Class<?> classSpec)
    {
        getTable(classSpec).clear();
    }
    Handler getHandler()
    {
        for (Map.Entry<Handler, String> entry : handlers.entrySet())
        {
            if (entry.getValue().equals(canonicalPath))
            {
                return entry.getKey();
            }
        }
        return null;
    }
    long getVersion()
    {
        if (!transaction.hasTable("metadata"))
        {
            return UNVERSIONED;
        }
        Table metadataTable = transaction.getTable("metadata");
        return metadataTable.getLong(0, 0);
    }
    void setVersion(long version)
    {
        Table metadataTable = transaction.getTable("metadata");
        if (metadataTable.getColumnCount() == 0)
        {
            metadataTable.addColumn(ColumnType.INTEGER, "version");
            metadataTable.addEmptyRow();
        }
        metadataTable.setLong(0, 0, version);
    }
    @SuppressWarnings("unchecked")
    private <E extends RealmObject> Class<? extends RealmObject> getRealmClassFromObject(E object)
    {
        if (object.realm != null)
        {
            return (Class<? extends RealmObject>)object.getClass().getSuperclass();
        }
        else
        {
            return object.getClass();
        }
    }
    @SuppressWarnings("unchecked") private <E extends RealmObject> E copyOrUpdate(E object, boolean update)
    {
        Class<? extends RealmObject> realmClass = getRealmClassFromObject(object);
        Class<?> proxyClass = getProxyClass(realmClass);
        Method method = insertOrUpdateMethods.get(realmClass);
        if (method == null)
        {
            try
            {
                method = proxyClass.getMethod("copyOrUpdate",
                                              new Class[] {Realm.class, realmClass, boolean.class, Map.class});
            }
            catch (NoSuchMethodException e)
            {
                throw new RealmException("Could not find the copyOrUpdate() method "
                                             + "in generated proxy class for " + proxyClass.getName() + ": " +
                                             APT_NOT_EXECUTED_MESSAGE,
                                         e);
            }
            insertOrUpdateMethods.put(proxyClass, method);
        }
        try
        {
            Object result = method.invoke(null, this, object, update, new HashMap<RealmObject, RealmObject>());
            return (E)result;
        }
        catch (IllegalAccessException e)
        {
            throw new RealmException("Could not execute the copyToRealm method : " + APT_NOT_EXECUTED_MESSAGE, e);
        }
        catch (InvocationTargetException e)
        {
            throw new RealmException("An exception was thrown in the copyToRealm "
                                         + "method in the proxy class " + proxyClass.getName(),
                                     e);
        }
    }
    private <E extends RealmObject> void checkNotNullObject(E object)
    {
        if (object == null)
        {
            throw new IllegalArgumentException("Null objects cannot be copied into Realm.");
        }
    }
    private <E extends RealmObject> void checkHasPrimaryKey(E object)
    {
        Class<? extends RealmObject> objectClass = object.getClass();
        if (!getTable(objectClass).hasPrimaryKey())
        {
            throw new IllegalArgumentException("RealmObject has no @PrimaryKey defined: " +
                                               getClassSimpleName(objectClass));
        }
    }
    private <E extends RealmObject> void checkHasPrimaryKey(Class<E> clazz)
    {
        if (!getTable(clazz).hasPrimaryKey())
        {
            throw new IllegalArgumentException("A RealmObject with no @PrimaryKey cannot be updated: " +
                                               clazz.toString());
        }
    }
    @SuppressWarnings("UnusedDeclaration")
    public static void migrateRealmAtPath(String realmPath, RealmMigration migration)
    {
        migrateRealmAtPath(realmPath, null, migration, true);
    }
    public static void migrateRealmAtPath(String realmPath, byte[] key, RealmMigration migration)
    {
        migrateRealmAtPath(realmPath, key, migration, true);
    }
    public static void migrateRealmAtPath(String realmPath, RealmMigration migration, boolean autoRefresh)
    {
        migrateRealmAtPath(realmPath, null, migration, autoRefresh);
    }
    public static synchronized void migrateRealmAtPath(String realmPath, byte[] key, RealmMigration migration,
                                                       boolean autoUpdate)
    {
        Realm realm = Realm.createAndValidate(realmPath, key, false, autoUpdate);
        realm.beginTransaction();
        realm.setVersion(migration.execute(realm, realm.getVersion()));
        realm.commitTransaction();
        realm.close();
        realmsCache.remove();
    }
    public static boolean deleteRealmFile(Context context)
    {
        return deleteRealmFile(context, DEFAULT_REALM_NAME);
    }
    public static boolean deleteRealmFile(Context context, String fileName)
    {
        return deleteRealmFile(new File(context.getFilesDir(), fileName));
    }
    public static synchronized boolean deleteRealmFile(File realmFile)
    {
        boolean result = true;
        File realmFolder = realmFile.getParentFile();
        String fileName = realmFile.getName();
        String id = getCanonicalPath(realmFile);
        AtomicInteger counter = openRealms.get(id);
        if (counter != null && counter.get() > 0)
        {
            throw new IllegalStateException("It's not allowed to delete the file associated with an open Realm. "
                                            + "Remember to close() all the instances of the Realm before "
                                            + "deleting its file.");
        }
        List<File> filesToDelete = Arrays.asList(
            realmFile, new File(realmFolder, fileName + ".lock"), new File(realmFolder, fileName + ".lock_a"),
            new File(realmFolder, fileName + ".lock_b"), new File(realmFolder, fileName + ".log"));
        for (File fileToDelete : filesToDelete)
        {
            if (fileToDelete.exists())
            {
                boolean deleteResult = fileToDelete.delete();
                if (!deleteResult)
                {
                    result = false;
                    RealmLog.w("Could not delete the file " + fileToDelete);
                }
            }
        }
        return result;
    }
    public static synchronized boolean compactRealmFile(Context context, String fileName, byte[] key)
    {
        if (key != null)
        {
            throw new IllegalArgumentException("Cannot currently compact an encrypted Realm.");
        }
        File realmFile = new File(context.getFilesDir(), fileName);
        String canonicalPath = getCanonicalPath(realmFile);
        if (openRealms.get(canonicalPath).get() > 0)
        {
            throw new IllegalStateException("Cannot compact an open Realm");
        }
        SharedGroup sharedGroup = null;
        boolean result = false;
        try
        {
            sharedGroup = new SharedGroup(canonicalPath, false, key);
            result = sharedGroup.compact();
        }
        finally
        {
            if (sharedGroup != null)
            {
                sharedGroup.close();
            }
        }
        return result;
    }
    public static boolean compactRealmFile(Context context)
    {
        return compactRealmFile(context, DEFAULT_REALM_NAME, null);
    }
    public static synchronized boolean compactRealmFile(Context context, String fileName)
    {
        return compactRealmFile(context, fileName, null);
    }
    public String getPath()
    {
        return canonicalPath;
    }
    @SafeVarargs static void setSchema(Class<? extends RealmObject>... schemaClass)
    {
        customSchema.clear();
        if (schemaClass != null)
        {
            Collections.addAll(customSchema, schemaClass);
        }
    }
    static String getCanonicalPath(File realmFile)
    {
        try
        {
            return realmFile.getCanonicalPath();
        }
        catch (IOException e)
        {
            throw new RealmException("Could not resolve the canonical path to the Realm file: " +
                                     realmFile.getAbsolutePath());
        }
    }
    public interface Transaction
    {
        public void execute(Realm realm);
    }
    private String getClassSimpleName(Class<?> clazz)
    {
        String simpleName = simpleClassNames.get(clazz);
        if (simpleName == null)
        {
            simpleName = clazz.getSimpleName();
            simpleClassNames.put(clazz, simpleName);
        }
        return simpleName;
    }
}