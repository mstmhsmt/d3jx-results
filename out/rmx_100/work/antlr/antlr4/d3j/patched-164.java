// generated by Diff/AST Java Unparser
package org.antlr.v4.runtime.tree;
import org.antlr.v4.runtime.RuleContext;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.misc.Interval;
public
interface ParseTree<Symbol>  extends SyntaxTree
{
   public
   interface RuleNode<Symbol>  extends ParseTree<Symbol>
   {
      RuleContext<Symbol> getRuleContext();
      @Override
      RuleNode<Symbol> getParent();
   }
   public
   interface TerminalNode<Symbol>  extends ParseTree<Symbol>
   {
      Symbol getSymbol();
      @Override
      RuleNode<Symbol> getParent();
   }
   public
   static
   class TerminalNodeImpl<Symbol> implements TerminalNode<Symbol>
   {
      public Symbol symbol;
      public RuleNode<Symbol> parent;
      public int s;
      public
      TerminalNodeImpl(Symbol symbol) {
        this.symbol = symbol;
      }
      @Override
      public
      ParseTree<Symbol> getChild(int i) {
        return null;
      }
      @Override
      public
      Symbol getSymbol() {
        return symbol;
      }
      @Override
      public
      RuleNode<Symbol> getParent() {
        return parent;
      }
      @Override
      public
      Symbol getPayload() {
        return symbol;
      }
      @Override
      public
      Interval getSourceInterval() {
        if (!(symbol instanceof Token))
          return Interval.INVALID;
        return new Interval(((Token)symbol).getStartIndex(),
                 ((Token)symbol).getStopIndex());
      }
      @Override
      public
      int getChildCount() {
        return 0;
      }
      public
      boolean isErrorNode() {
        return this instanceof ErrorNodeImpl;
      }
      @Override
      public
      String toString() {
        if (symbol instanceof Token) {
          if (((Token)symbol).getType() == Token.EOF)
            return "<EOF>";
          return ((Token)symbol).getText();
        } else {
          return symbol != null ? symbol.toString() : "<null>";
        }
      }
      @Override
      public
      String toStringTree() {
        return toString();
      }
   }
   public
   interface ErrorNode<Symbol extends Token>  extends TerminalNode<Symbol>{}
   public
   static
   class ErrorNodeImpl<Symbol> extends TerminalNodeImpl<Symbol>
     implements ErrorNode<Symbol>
   {
      public
      ErrorNodeImpl(Symbol token) {
        super(token);
      }
   }
   @Override
   ParseTree<Symbol> getParent();
   @Override
   ParseTree<Symbol> getChild(int i);
}