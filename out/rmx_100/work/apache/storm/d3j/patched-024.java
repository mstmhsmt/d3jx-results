// generated by Diff/AST Java Unparser
package backtype.storm.messaging.netty;
import org.jboss.netty.util.HashedWheelTimer;
import org.jboss.netty.util.Timeout;
import org.jboss.netty.util.TimerTask;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import static com.google.common.base.Preconditions.checkState;
import org.jboss.netty.bootstrap.ClientBootstrap;
import org.jboss.netty.channel.Channel;
import org.jboss.netty.channel.ChannelFactory;
import org.jboss.netty.channel.ChannelFuture;
import org.jboss.netty.channel.ChannelFutureListener;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import backtype.storm.Config;
import backtype.storm.messaging.ConnectionWithStatus;
import backtype.storm.metric.api.IStatefulObject;
import backtype.storm.messaging.TaskMessage;
import backtype.storm.utils.StormBoundedExponentialBackoffRetry;
import backtype.storm.utils.Utils;
public
class Client extends ConnectionWithStatus implements IStatefulObject
{
   private static final Logger LOG = LoggerFactory.getLogger(Client.class);
   private static final String PREFIX = "Netty-Client-";
   private static final long NO_DELAY_MS = 0L;
   private static final long PENDING_MESSAGES_FLUSH_TIMEOUT_MS = 600000L;
   private static final long PENDING_MESSAGES_FLUSH_INTERVAL_MS = 1000L;
   private final StormBoundedExponentialBackoffRetry retryPolicy;
   private final ClientBootstrap bootstrap;
   private final InetSocketAddress dstAddress;
   protected final String dstAddressPrefixedName;
   private final AtomicReference<Channel> channelRef =
     new AtomicReference<Channel>();
   private final int maxReconnectionAttempts;
   private final AtomicInteger totalConnectionAttempts =
     new AtomicInteger(0);
   private final AtomicInteger connectionAttempts = new AtomicInteger(0);
   private final AtomicInteger messagesSent = new AtomicInteger(0);
   private final AtomicInteger messagesLost = new AtomicInteger(0);
   private final AtomicLong pendingMessages = new AtomicLong(0);
   private volatile boolean closing = false;
   private final HashedWheelTimer scheduler;
   private final MessageBuffer batcher;
   private final Map stormConf;
   @SuppressWarnings("rawtypes")
   Client(Map stormConf, ChannelFactory factory, HashedWheelTimer scheduler, 
          String host, int port) {
     this.stormConf = stormConf;
     closing = false;
     this.scheduler = scheduler;
     int bufferSize =
       Utils.getInt(stormConf.get(Config.STORM_MESSAGING_NETTY_BUFFER_SIZE));
     LOG.info("creating Netty Client, connecting to {}:{}, bufferSize: {}",
       host, port, bufferSize);
     int messageBatchSize =
       Utils.getInt(stormConf.get(Config.STORM_NETTY_MESSAGE_BATCH_SIZE),
         262144);
     maxReconnectionAttempts =
     Utils.getInt(stormConf.get(Config.STORM_MESSAGING_NETTY_MAX_RETRIES));
     int minWaitMs =
       Utils.getInt(stormConf.get(Config.STORM_MESSAGING_NETTY_MIN_SLEEP_MS));
     int maxWaitMs =
       Utils.getInt(stormConf.get(Config.STORM_MESSAGING_NETTY_MAX_SLEEP_MS));
     retryPolicy =
     new StormBoundedExponentialBackoffRetry(minWaitMs, maxWaitMs,
       maxReconnectionAttempts);
     bootstrap = createClientBootstrap(factory, bufferSize);
     dstAddress = new InetSocketAddress(host, port);
     dstAddressPrefixedName = prefixedName(dstAddress);
     scheduleConnect(NO_DELAY_MS);
     batcher = new MessageBuffer(messageBatchSize);
   }
   private
   ClientBootstrap createClientBootstrap(ChannelFactory factory, 
                                         int bufferSize) {
     ClientBootstrap bootstrap = new ClientBootstrap(factory);
     bootstrap.setOption("tcpNoDelay", true);
     bootstrap.setOption("sendBufferSize", bufferSize);
     bootstrap.setOption("keepAlive", true);
     bootstrap.setPipelineFactory(new StormClientPipelineFactory(this));
     return bootstrap;
   }
   private
   String prefixedName(InetSocketAddress dstAddress) {
     if (null != dstAddress) {
       return PREFIX + dstAddress.toString();
     }
     return "";
   }
   private
   void scheduleConnect(long delayMs) {
     scheduler.newTimeout(new Connect(dstAddress), delayMs,
       TimeUnit.MILLISECONDS);
   }
   private
   boolean reconnectingAllowed() {
     return !closing && connectionAttempts.get() <= (maxReconnectionAttempts + 1);
   }
   private
   boolean connectionEstablished(Channel channel) {
     return channel != null && channel.isConnected();
   }
   @Override
   public
   Status status() {
     if (closing) {
       return Status.Closed;
     } else if (!connectionEstablished(channelRef.get())) {
       return Status.Connecting;
     } else {
       return Status.Ready;
     }
   }
   @Override
   public
   Iterator<TaskMessage> recv(int flags, int clientId) {
     throw new UnsupportedOperationException("Client connection should not receive any messages");
   }
   @Override
   public
   void send(int taskId, byte[] payload) {
     TaskMessage msg = new TaskMessage(taskId, payload);
     List<TaskMessage> wrapper = new ArrayList<TaskMessage>(1);
     wrapper.add(msg);
     send(wrapper.iterator());
   }
   @Override
   public
   void send(Iterator<TaskMessage> msgs) {
     if (closing) {
       int numMessages = iteratorSize(msgs);
       LOG.error("discarding {} messages because the Netty client to {} is being closed",
         numMessages, dstAddressPrefixedName);
       return;
     }
     if (!hasMessages(msgs)) {
       return;
     }
     Channel channel = getConnectedChannel();
     if (channel == null) {
       dropMessages(msgs);
       return;
     }
     while (msgs.hasNext()) {
       TaskMessage message = msgs.next();
       MessageBatch full = batcher.add(message);
       if (full != null) {
         flushMessages(channel, full);
       }
     }
     if (channel.isWritable()) {
       MessageBatch batch = batcher.drain();
       if (batch != null) {
         flushMessages(channel, batch);
       }
     } else {}
   }
   private
   Channel getConnectedChannel() {
     Channel channel = channelRef.get();
     if (connectionEstablished(channel)) {
       return channel;
     } else {
       boolean reconnectScheduled = closeChannelAndReconnect(channel);
       if (reconnectScheduled) {
         LOG.error("connection to {} is unavailable", dstAddressPrefixedName);
       }
       return null;
     }
   }
   private
   boolean hasMessages(Iterator<TaskMessage> msgs) {
     return msgs != null && msgs.hasNext();
   }
   private
   void dropMessages(Iterator<TaskMessage> msgs) {
     int msgCount = iteratorSize(msgs);
     messagesLost.getAndAdd(msgCount);
   }
   private
   int iteratorSize(Iterator<TaskMessage> msgs) {
     int size = 0;
     if (msgs != null) {
       while (msgs.hasNext()) {
         size++;
         msgs.next();
       }
     }
     return size;
   }
   private
   void flushMessages(Channel channel, MessageBatch batch) {
     if (batch.isEmpty()) {
       return;
     }
     final int numMessages = batch.size();
     LOG.debug("writing {} messages to channel {}", batch.size(),
       channel.toString());
     pendingMessages.addAndGet(numMessages);
     ChannelFuture future = channel.write(batch);
     future.addListener(new ChannelFutureListener()
                        {
                           public
                           void operationComplete(ChannelFuture future)
                             throws Exception {
                             pendingMessages.addAndGet(0 - numMessages);
                             if (future.isSuccess()) {
                               LOG.debug("sent {} messages to {}",
                                 numMessages, dstAddressPrefixedName);
                               messagesSent.getAndAdd(numMessages);
                             } else {
                               LOG.error("failed to send {} messages to {}: {}",
                                 numMessages, dstAddressPrefixedName,
                                 future.getCause());
                               closeChannelAndReconnect(future.getChannel());
                               messagesLost.getAndAdd(numMessages);
                             }
                           }
                        });
   }
   private
   boolean closeChannelAndReconnect(Channel channel) {
     if (channel != null) {
       channel.close();
       if (channelRef.compareAndSet(channel, null)) {
         scheduleConnect(NO_DELAY_MS);
         return true;
       }
     }
     return false;
   }
   @Override
   public
   void close() {
     if (!closing) {
       LOG.info("closing Netty Client {}", dstAddressPrefixedName);
       closing = true;
       waitForPendingMessagesToBeSent();
       closeChannel();
     }
   }
   private
   void waitForPendingMessagesToBeSent() {
     LOG.info("waiting up to {} ms to send {} pending messages to {}",
       PENDING_MESSAGES_FLUSH_TIMEOUT_MS, pendingMessages.get(),
       dstAddressPrefixedName);
     long totalPendingMsgs = pendingMessages.get();
     long startMs = System.currentTimeMillis();
     while (pendingMessages.get() != 0) {
       try {
         long deltaMs = System.currentTimeMillis() - startMs;
         if (deltaMs > PENDING_MESSAGES_FLUSH_TIMEOUT_MS) {
           LOG.error("failed to send all pending messages to {} within timeout, {} of {} messages were not " + "sent",
             dstAddressPrefixedName, pendingMessages.get(), totalPendingMsgs);
           break;
         }
         Thread.sleep(PENDING_MESSAGES_FLUSH_INTERVAL_MS);
       } catch (InterruptedException e) {
         break;
       } 
     }
   }
   private
   void closeChannel() {
     Channel channel = channelRef.get();
     if (channel != null) {
       channel.close();
       LOG.debug("channel to {} closed", dstAddressPrefixedName);
     }
   }
   @Override
   public
   Object getState() {
     LOG.info("Getting metrics for client connection to {}",
       dstAddressPrefixedName);
     HashMap<String,Object> ret = new HashMap<String,Object>();
     ret.put("reconnects", totalConnectionAttempts.getAndSet(0));
     ret.put("sent", messagesSent.getAndSet(0));
     ret.put("pending", pendingMessages.get());
     ret.put("lostOnSend", messagesLost.getAndSet(0));
     ret.put("dest", dstAddress.toString());
     String src = srcAddressName();
     if (src != null) {
       ret.put("src", src);
     }
     return ret;
   }
   public
   Map getStormConf() {
     return stormConf;
   }
   private
   String srcAddressName() {
     String name = null;
     Channel channel = channelRef.get();
     if (channel != null) {
       SocketAddress address = channel.getLocalAddress();
       if (address != null) {
         name = address.toString();
       }
     }
     return name;
   }
   @Override
   public
   String toString() {
     return String.format("Netty client for connecting to %s",
              dstAddressPrefixedName);
   }
   public
   void notifyInterestChanged(Channel channel) {
     if (channel.isWritable()) {
       MessageBatch pending = batcher.drain();
       flushMessages(channel, pending);
     }
   }
   private
   class Connect implements TimerTask
   {
      private final InetSocketAddress address;
      public
      Connect(InetSocketAddress address) {
        this.address = address;
      }
      private
      void reschedule(Throwable t) {
        String baseMsg =
          String.format("connection attempt %s to %s failed",
            connectionAttempts, dstAddressPrefixedName);
        String failureMsg =
          (t == null) ? baseMsg : baseMsg + ": " + t.toString();
        LOG.error(failureMsg);
        long nextDelayMs =
          retryPolicy.getSleepTimeMs(connectionAttempts.get(), 0);
        scheduleConnect(nextDelayMs);
      }
      @Override
      public
      void run(Timeout timeout) throws Exception {
        if (reconnectingAllowed()) {
          final int connectionAttempt = connectionAttempts.getAndIncrement();
          totalConnectionAttempts.getAndIncrement();
          LOG.debug("connecting to {} [attempt {}]", address.toString(),
            connectionAttempt);
          ChannelFuture future = bootstrap.connect(address);
          future.addListener(new ChannelFutureListener()
                             {
                                @Override
                                public
                                void operationComplete(ChannelFuture future)
                                  throws Exception {
                                  Channel newChannel = future.getChannel();
                                  if (future.isSuccess() && connectionEstablished(newChannel)) {
                                    boolean setChannel =
                                      channelRef.compareAndSet(null,
                                        newChannel);
                                    checkState(setChannel);
                                    LOG.debug("successfully connected to {}, {} [attempt {}]",
                                      address.toString(),
                                      newChannel.toString(),
                                      connectionAttempt);
                                    if (messagesLost.get() > 0) {
                                      LOG.warn("Re-connection to {} was successful but {} messages has been lost so far",
                                        address.toString(),
                                        messagesLost.get());
                                    }
                                  } else {
                                    Throwable cause = future.getCause();
                                    reschedule(cause);
                                    if (newChannel != null) {
                                      newChannel.close();
                                    }
                                  }
                                }
                             });
        } else {
          close();
          throw new RuntimeException("Giving up to scheduleConnect to " + dstAddressPrefixedName + " after " + connectionAttempts + " failed attempts. " + 
                  messagesLost.get() + " messages were lost");
        }
      }
   }
}