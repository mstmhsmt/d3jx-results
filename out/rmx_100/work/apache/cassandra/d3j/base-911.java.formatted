// generated by Diff/AST Java Unparser
package org.apache.cassandra.net;
import java.io.BufferedOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.Socket;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.atomic.AtomicLong;
import org.apache.commons.lang.ArrayUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.service.StorageService;
import org.apache.cassandra.utils.FBUtilities;
public class OutboundTcpConnection extends Thread
{
    private static final Logger logger = LoggerFactory.getLogger(OutboundTcpConnection.class);
    private static final Message CLOSE_SENTINEL =
        new Message(FBUtilities.getBroadcastAddress(), StorageService.Verb.INTERNAL_RESPONSE,
                    ArrayUtils.EMPTY_BYTE_ARRAY, MessagingService.version_);
    private volatile boolean isStopped = false;
    private static final int OPEN_RETRY_DELAY = 100;
    private volatile BlockingQueue<Entry> backlog = new LinkedBlockingQueue<Entry>();
    private volatile BlockingQueue<Entry> active = new LinkedBlockingQueue<Entry>();
    private final OutboundTcpConnectionPool poolReference;
    private DataOutputStream out;
    private Socket socket;
    private volatile long completed;
    private final AtomicLong dropped = new AtomicLong();
    public OutboundTcpConnection(OutboundTcpConnectionPool pool)
    {
        super("WRITE-" + pool.endPoint());
        this.poolReference = pool;
    }
    public void enqueue(Message message, String id)
    {
        expireMessages();
        try
        {
            backlog.put(new Entry(message, id, System.currentTimeMillis()));
        }
        catch (InterruptedException e)
        {
            throw new AssertionError(e);
        }
    }
    void closeSocket(boolean destroyThread)
    {
        active.clear();
        backlog.clear();
        isStopped = destroyThread;
        enqueue(CLOSE_SENTINEL, null);
    }
    void softCloseSocket()
    {
        enqueue(CLOSE_SENTINEL, null);
    }
    public void run()
    {
        while (true)
        {
            Entry entry = active.poll();
            if (entry == null)
            {
                try
                {
                    entry = backlog.take();
                }
                catch (InterruptedException e)
                {
                    throw new AssertionError(e);
                }
                BlockingQueue<Entry> tmp = backlog;
                backlog = active;
                active = tmp;
            }
            Message m = entry.message;
            String id = entry.id;
            if (m == CLOSE_SENTINEL)
            {
                disconnect();
                if (isStopped)
                    break;
                continue;
            }
            if (entry.timestamp < System.currentTimeMillis() - DatabaseDescriptor.getRpcTimeout())
                dropped.incrementAndGet();
            else if (socket != null || connect())
                writeConnected(m, id);
            else
                active.clear();
        }
    }
    public int getPendingMessages()
    {
        return active.size() + backlog.size();
    }
    public long getCompletedMesssages()
    {
        return completed;
    }
    public long getDroppedMessages()
    {
        return dropped.get();
    }
    private void writeConnected(Message message, String id)
    {
        try
        {
            write(message, id, out);
            completed++;
            if (active.peek() == null)
            {
                out.flush();
            }
        }
        catch (Exception e)
        {
            if (!(e instanceof IOException))
                logger.error("error writing to " + poolReference.endPoint(), e);
            else if (logger.isDebugEnabled())
                logger.debug("error writing to " + poolReference.endPoint(), e);
            disconnect();
        }
    }
    public static void write(Message message, String id, DataOutputStream out) throws IOException
    {
        int header = 0;
        header |= MessagingService.serializerType_.ordinal();
        if (false)
            header |= 4;
        header |= (message.getVersion() << 8);
        out.writeInt(MessagingService.PROTOCOL_MAGIC);
        out.writeInt(header);
        byte[] bytes = message.getMessageBody();
        int total = messageLength(message.header_, id, bytes);
        out.writeInt(total);
        out.writeUTF(id);
        Header.serializer().serialize(message.header_, out, message.getVersion());
        out.writeInt(bytes.length);
        out.write(bytes);
    }
    public static int messageLength(Header header, String id, byte[] bytes)
    {
        return 2 + FBUtilities.encodedUTF8Length(id) + header.serializedSize() + 4 + bytes.length;
    }
    private void disconnect()
    {
        if (socket != null)
        {
            try
            {
                socket.close();
            }
            catch (IOException e)
            {
                if (logger.isDebugEnabled())
                    logger.debug("exception closing connection to " + poolReference.endPoint(), e);
            }
            out = null;
            socket = null;
        }
    }
    private boolean connect()
    {
        if (logger.isDebugEnabled())
            logger.debug("attempting to connect to " + poolReference.endPoint());
        long start = System.currentTimeMillis();
        while (System.currentTimeMillis() < start + DatabaseDescriptor.getRpcTimeout())
        {
            try
            {
                socket = poolReference.newSocket();
                socket.setKeepAlive(true);
                socket.setTcpNoDelay(true);
                out = new DataOutputStream(new BufferedOutputStream(socket.getOutputStream(), 4096));
                return true;
            }
            catch (IOException e)
            {
                socket = null;
                if (logger.isTraceEnabled())
                    logger.trace("unable to connect to " + poolReference.endPoint(), e);
                try
                {
                    Thread.sleep(OPEN_RETRY_DELAY);
                }
                catch (InterruptedException e1)
                {
                    throw new AssertionError(e1);
                }
            }
        }
        return false;
    }
    private void expireMessages()
    {
        while (true)
        {
            Entry entry = backlog.peek();
            if (entry == null || entry.timestamp >= System.currentTimeMillis() - DatabaseDescriptor.getRpcTimeout())
                break;
            Entry entry2 = backlog.poll();
            if (entry2 != entry)
            {
                if (entry2 != null)
                    active.add(entry2);
                break;
            }
            dropped.incrementAndGet();
        }
    }
    private static class Entry
    {
        final Message message;
        final String id;
        final long timestamp;
        Entry(Message message, String id, long timestamp)
        {
            this.message = message;
            this.id = id;
            this.timestamp = timestamp;
        }
    }
}