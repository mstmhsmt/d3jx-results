// generated by Diff/AST Java Unparser
package org.apache.cassandra.utils.btree;
import java.util.Comparator;
import static org.apache.cassandra.utils.btree.BTree.getBranchKeyEnd;
import static org.apache.cassandra.utils.btree.BTree.getKeyEnd;
import static org.apache.cassandra.utils.btree.BTree.getLeafKeyEnd;
import static org.apache.cassandra.utils.btree.BTree.isLeaf;
class Path {
  static enum Op { CEIL, FLOOR, HIGHER, LOWER }
  Object[][] path;
  byte[] indexes;
  byte depth = -1;
  Path() {}
  Path(int depth) {
    this.path = new Object[depth][];
    this.indexes = new byte[depth];
  }
  void ensureDepth(Object[] btree) {
    int depth = BTree.depth(btree);
    if (path == null || path.length < depth) {
      path = new Object[depth][];
      indexes = new byte[depth];
    }
  }
  <V> void find(Object[] node, Comparator<V> comparator, Object target, Op mode,
                boolean forwards) {
    depth = -1;
    while (true) {
      int keyEnd = getKeyEnd(node);
      int i = BTree.find(comparator, target, node, 0, keyEnd);
      if (i >= 0) {
        push(node, i);
        switch (mode) {
        case HIGHER:
          successor();
          break;
        case LOWER:
          predecessor();
        }
        return;
      }
      if (!isLeaf(node)) {
        i = -i - 1;
        push(node, forwards ? i - 1 : i);
        node = (Object[])node[keyEnd + i];
        continue;
      }
      i = -i - 1;
      switch (mode) {
      case FLOOR:
      case LOWER:
        i--;
      }
      if (i < 0) {
        push(node, 0);
        predecessor();
      } else if (i >= keyEnd) {
        push(node, keyEnd - 1);
        successor();
      } else {
        push(node, i);
      }
      return;
    }
  }
  private boolean isRoot() { return depth == 0; }
  private void pop() { depth--; }
  Object[] currentNode() { return path[depth]; }
  byte currentIndex() { return indexes[depth]; }
  private void push(Object[] node, int index) {
    path[++depth] = node;
    indexes[depth] = (byte)index;
  }
  void setIndex(int index) { indexes[depth] = (byte)index; }
  void successor() {
    Object[] node = currentNode();
    int i = currentIndex();
    if (!isLeaf(node)) {
      node = (Object[])node[getBranchKeyEnd(node) + i + 1];
      while (!isLeaf(node)) {
        push(node, -1);
        node = (Object[])node[getBranchKeyEnd(node)];
      }
      push(node, 0);
      return;
    }
    i += 1;
    if (i < getLeafKeyEnd(node)) {
      setIndex(i);
      return;
    }
    while (!isRoot()) {
      pop();
      i = currentIndex() + 1;
      node = currentNode();
      if (i < getKeyEnd(node)) {
        setIndex(i);
        return;
      }
    }
    setIndex(getKeyEnd(node));
  }
  void predecessor() {
    Object[] node = currentNode();
    int i = currentIndex();
    if (!isLeaf(node)) {
      node = (Object[])node[getBranchKeyEnd(node) + i];
      while (!isLeaf(node)) {
        i = getBranchKeyEnd(node);
        push(node, i);
        node = (Object[])node[i * 2];
      }
      push(node, getLeafKeyEnd(node) - 1);
      return;
    }
    i -= 1;
    if (i >= 0) {
      setIndex(i);
      return;
    }
    while (!isRoot()) {
      pop();
      i = currentIndex() - 1;
      if (i >= 0) {
        setIndex(i);
        return;
      }
    }
    setIndex(-1);
  }
  Object currentKey() { return currentNode()[currentIndex()]; }
  int compareTo(Path that, boolean forwards) {
    int d = Math.min(this.depth, that.depth);
    for (int i = 0; i <= d; i++) {
      int c = this.indexes[i] - that.indexes[i];
      if (c != 0)
        return c;
    }
    d = this.depth - that.depth;
    return forwards ? d : -d;
  }
}