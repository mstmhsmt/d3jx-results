// generated by Diff/AST Java Unparser
package org.apache.cassandra.utils.memory;
import java.lang.ref.PhantomReference;
import java.lang.ref.ReferenceQueue;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.Queue;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicLongFieldUpdater;
import com.google.common.annotations.VisibleForTesting;
import org.apache.cassandra.concurrent.InfiniteLoopExecutor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import io.netty.util.concurrent.FastThreadLocal;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.io.compress.BufferType;
import org.apache.cassandra.io.util.FileUtils;
import org.apache.cassandra.metrics.BufferPoolMetrics;
import org.apache.cassandra.utils.FBUtilities;
import org.apache.cassandra.utils.NoSpamLogger;
import org.apache.cassandra.utils.concurrent.Ref;
import static org.apache.cassandra.utils.ExecutorUtils.awaitTermination;
import static org.apache.cassandra.utils.ExecutorUtils.shutdownNow;
public class BufferPool {
  public static final int CHUNK_SIZE = 64 << 10;
  @VisibleForTesting
  public static long MEMORY_USAGE_THRESHOLD =
      DatabaseDescriptor.getFileCacheSizeInMB() * 1024L * 1024L;
  @VisibleForTesting
  public static boolean ALLOCATE_ON_HEAP_WHEN_EXAHUSTED =
      DatabaseDescriptor.getBufferPoolUseHeapIfExhausted();
  @VisibleForTesting
  public static boolean DISABLED = Boolean.parseBoolean(
      System.getProperty("cassandra.test.disable_buffer_pool", "false"));
  @VisibleForTesting public static boolean DEBUG = false;
  private static final Logger logger =
      LoggerFactory.getLogger(BufferPool.class);
  private static final NoSpamLogger noSpamLogger =
      NoSpamLogger.getLogger(logger, 15L, TimeUnit.MINUTES);
  private static final ByteBuffer EMPTY_BUFFER = ByteBuffer.allocateDirect(0);
  private static final GlobalPool globalPool = new GlobalPool();
  private static final FastThreadLocal<LocalPool> localPool =
      new FastThreadLocal<LocalPool>() {
        @Override
        protected LocalPool initialValue() {
          return new LocalPool();
        }
      };
  public static ByteBuffer get(int size) {
    if (DISABLED)
      return allocate(size, ALLOCATE_ON_HEAP_WHEN_EXAHUSTED);
    else
      return takeFromPool(size, ALLOCATE_ON_HEAP_WHEN_EXAHUSTED);
  }
  public static ByteBuffer get(int size, BufferType bufferType) {
    boolean direct = bufferType == BufferType.OFF_HEAP;
    if (DISABLED || !direct)
      return allocate(size, !direct);
    else
      return takeFromPool(size, !direct);
  }
  public static ByteBuffer tryGet(int size) {
    if (DISABLED)
      return allocate(size, ALLOCATE_ON_HEAP_WHEN_EXAHUSTED);
    else
      return maybeTakeFromPool(size, ALLOCATE_ON_HEAP_WHEN_EXAHUSTED);
  }
  private static ByteBuffer allocate(int size, boolean onHeap) {
    return onHeap ? ByteBuffer.allocate(size) : ByteBuffer.allocateDirect(size);
  }
  private static ByteBuffer takeFromPool(int size,
                                         boolean allocateOnHeapWhenExhausted) {
    ByteBuffer ret = maybeTakeFromPool(size, allocateOnHeapWhenExhausted);
    if (ret != null)
      return ret;
    if (logger.isTraceEnabled())
      logger.trace("Requested buffer size {} has been allocated directly due " +
                   "to lack of capacity",
                   FBUtilities.prettyPrintMemory(size));
    return localPool.get().allocate(size, allocateOnHeapWhenExhausted);
  }
  private static ByteBuffer
  maybeTakeFromPool(int size, boolean allocateOnHeapWhenExhausted) {
    if (size < 0)
      throw new IllegalArgumentException("Size must be positive (" + size +
                                         ")");
    if (size == 0)
      return EMPTY_BUFFER;
    if (size > CHUNK_SIZE) {
      if (logger.isTraceEnabled())
        logger.trace(
            "Requested buffer size {} is bigger than {}, allocating directly",
            FBUtilities.prettyPrintMemory(size),
            FBUtilities.prettyPrintMemory(CHUNK_SIZE));
      return localPool.get().allocate(size, allocateOnHeapWhenExhausted);
    }
    return localPool.get().get(size);
  }
  public static void put(ByteBuffer buffer) {
    if (!(DISABLED || buffer.hasArray()))
      localPool.get().put(buffer);
  }
  @VisibleForTesting
  static void reset() {
    localPool.get().reset();
    globalPool.reset();
  }
  @VisibleForTesting
  static Chunk currentChunk() {
    return localPool.get().chunks[0];
  }
  @VisibleForTesting
  static int numChunks() {
    int ret = 0;
    for (Chunk chunk : localPool.get().chunks) {
      if (chunk != null)
        ret++;
    }
    return ret;
  }
  @VisibleForTesting
  static void assertAllRecycled() {
    globalPool.debug.check();
  }
  public static long sizeInBytes() { return globalPool.sizeInBytes(); }
  static final class Debug {
    long recycleRound = 1;
    final Queue<Chunk> allChunks = new ConcurrentLinkedQueue<>();
    void register(Chunk chunk) { allChunks.add(chunk); }
    void recycle(Chunk chunk) { chunk.lastRecycled = recycleRound; }
    void check() {
      for (Chunk chunk : allChunks)
        assert chunk.lastRecycled == recycleRound;
      recycleRound++;
    }
  }
  static final class GlobalPool {
    static final int MACRO_CHUNK_SIZE = 1 << 20;
    static {
      assert Integer.bitCount(CHUNK_SIZE) == 1;
      assert Integer.bitCount(MACRO_CHUNK_SIZE) == 1;
      assert MACRO_CHUNK_SIZE % CHUNK_SIZE == 0;
      if (DISABLED)
        logger.info("Global buffer pool is disabled, allocating {}",
                    ALLOCATE_ON_HEAP_WHEN_EXAHUSTED ? "on heap" : "off heap");
      else
        logger.info("Global buffer pool is enabled, when pool is exhausted " +
                    "(max is {}) it will allocate {}",
                    FBUtilities.prettyPrintMemory(MEMORY_USAGE_THRESHOLD),
                    ALLOCATE_ON_HEAP_WHEN_EXAHUSTED ? "on heap" : "off heap");
    }
    private final Debug debug = new Debug();
    private final Queue<Chunk> macroChunks = new ConcurrentLinkedQueue<>();
    private final Queue<Chunk> chunks = new ConcurrentLinkedQueue<>();
    private final AtomicLong memoryUsage = new AtomicLong();
    public Chunk get() {
      while (true) {
        Chunk chunk = chunks.poll();
        if (chunk != null)
          return chunk;
        if (!allocateMoreChunks())
          return chunks.poll();
      }
    }
    private boolean allocateMoreChunks() {
      while (true) {
        long cur = memoryUsage.get();
        if (cur + MACRO_CHUNK_SIZE > MEMORY_USAGE_THRESHOLD) {
          noSpamLogger.info(
              "Maximum memory usage reached ({}), cannot allocate chunk of {}",
              MEMORY_USAGE_THRESHOLD, MACRO_CHUNK_SIZE);
          return false;
        }
        if (memoryUsage.compareAndSet(cur, cur + MACRO_CHUNK_SIZE))
          break;
      }
      Chunk chunk;
      try {
        chunk = new Chunk(allocateDirectAligned(MACRO_CHUNK_SIZE));
      } catch (OutOfMemoryError oom) {
        noSpamLogger.error(
            "Buffer pool failed to allocate chunk of {}, current size {} ({}). "
                + "Attempting to continue; buffers will be allocated in " +
                  "on-heap memory which can degrade performance. "
                + "Make sure direct memory size (-XX:MaxDirectMemorySize) is " +
                  "large enough to accommodate off-heap memtables and caches.",
            MACRO_CHUNK_SIZE, sizeInBytes(), oom.toString());
        return false;
      }
      chunk.acquire(null);
      macroChunks.add(chunk);
      for (int i = 0; i < MACRO_CHUNK_SIZE; i += CHUNK_SIZE) {
        Chunk add = new Chunk(chunk.get(CHUNK_SIZE));
        chunks.add(add);
        if (DEBUG)
          debug.register(add);
      }
      return true;
    }
    public void recycle(Chunk chunk) { chunks.add(chunk); }
    public long sizeInBytes() { return memoryUsage.get(); }
    @VisibleForTesting
    void reset() {
      while (!chunks.isEmpty())
        chunks.poll().reset();
      while (!macroChunks.isEmpty())
        macroChunks.poll().reset();
      memoryUsage.set(0);
    }
  }
  static final class LocalPool {
    private final static BufferPoolMetrics metrics = new BufferPoolMetrics();
    private final Chunk[] chunks = new Chunk[3];
    private byte chunkCount = 0;
    public LocalPool() {
      localPoolReferences.add(new LocalPoolRef(this, localPoolRefQueue));
    }
    private Chunk addChunkFromGlobalPool() {
      Chunk chunk = globalPool.get();
      if (chunk == null)
        return null;
      addChunk(chunk);
      return chunk;
    }
    private void addChunk(Chunk chunk) {
      chunk.acquire(this);
      if (chunkCount < 3) {
        chunks[chunkCount++] = chunk;
        return;
      }
      int smallestChunkIdx = 0;
      if (chunks[1].free() < chunks[0].free())
        smallestChunkIdx = 1;
      if (chunks[2].free() < chunks[smallestChunkIdx].free())
        smallestChunkIdx = 2;
      chunks[smallestChunkIdx].release();
      if (smallestChunkIdx != 2)
        chunks[smallestChunkIdx] = chunks[2];
      chunks[2] = chunk;
    }
    public ByteBuffer get(int size) {
      for (Chunk chunk : chunks) {
        if (chunk == null)
          break;
        ByteBuffer buffer = chunk.get(size);
        if (buffer != null)
          return buffer;
      }
      Chunk chunk = addChunkFromGlobalPool();
      if (chunk != null)
        return chunk.get(size);
      return null;
    }
    private ByteBuffer allocate(int size, boolean onHeap) {
      metrics.misses.mark();
      return BufferPool.allocate(size, onHeap);
    }
    public void put(ByteBuffer buffer) {
      Chunk chunk = Chunk.getParentChunk(buffer);
      if (chunk == null) {
        FileUtils.clean(buffer);
        return;
      }
      LocalPool owner = chunk.owner;
      long free = chunk.free(buffer, owner == null | owner == this);
      if (free == 0L) {
        chunk.recycle();
        if (owner == this)
          removeFromLocalQueue(chunk);
      } else if (((free == -1L) && owner != this) && chunk.owner == null) {
        chunk.tryRecycle();
      }
    }
    private void removeFromLocalQueue(Chunk chunk) {
      if (chunks[0] == chunk) {
        chunks[0] = chunks[1];
        chunks[1] = chunks[2];
      } else if (chunks[1] == chunk) {
        chunks[1] = chunks[2];
      } else
        assert chunks[2] == chunk;
      chunks[2] = null;
      chunkCount--;
    }
    @VisibleForTesting
    void reset() {
      chunkCount = 0;
      for (int i = 0; i < chunks.length; i++) {
        if (chunks[i] != null) {
          chunks[i].owner = null;
          chunks[i].freeSlots = 0L;
          chunks[i].recycle();
          chunks[i] = null;
        }
      }
    }
  }
  private static final class LocalPoolRef extends PhantomReference<LocalPool> {
    private final Chunk[] chunks;
    public LocalPoolRef(LocalPool localPool,
                        ReferenceQueue<? super LocalPool> q) {
      super(localPool, q);
      chunks = localPool.chunks;
    }
    public void release() {
      for (int i = 0; i < chunks.length; i++) {
        if (chunks[i] != null) {
          chunks[i].release();
          chunks[i] = null;
        }
      }
    }
  }
  private static final ConcurrentLinkedQueue<LocalPoolRef> localPoolReferences =
      new ConcurrentLinkedQueue<>();
  private static final ReferenceQueue<Object> localPoolRefQueue =
      new ReferenceQueue<>();
  private static final InfiniteLoopExecutor EXEC =
      new InfiniteLoopExecutor("LocalPool-Cleaner",
                               BufferPool::cleanupOneReference)
          .start();
  private static void cleanupOneReference() throws InterruptedException {
    Object obj = localPoolRefQueue.remove(100);
    if (obj instanceof LocalPoolRef) {
      ((LocalPoolRef)obj).release();
      localPoolReferences.remove(obj);
    }
  }
  private static ByteBuffer allocateDirectAligned(int capacity) {
    int align = MemoryUtil.pageSize();
    if (Integer.bitCount(align) != 1)
      throw new IllegalArgumentException("Alignment must be a power of 2");
    ByteBuffer buffer = ByteBuffer.allocateDirect(capacity + align);
    long address = MemoryUtil.getAddress(buffer);
    long offset = address & (align - 1);
    if (offset == 0) {
      buffer.limit(capacity);
    } else {
      int pos = (int)(align - offset);
      buffer.position(pos);
      buffer.limit(pos + capacity);
    }
    return buffer.slice();
  }
  final static class Chunk {
    private final ByteBuffer slab;
    private final long baseAddress;
    private final int shift;
    private volatile long freeSlots;
    private static final AtomicLongFieldUpdater<Chunk> freeSlotsUpdater =
        AtomicLongFieldUpdater.newUpdater(Chunk.class, "freeSlots");
    private volatile LocalPool owner;
    private long lastRecycled;
    private final Chunk original;
    Chunk(Chunk recycle) {
      assert recycle.freeSlots == 0L;
      this.slab = recycle.slab;
      this.baseAddress = recycle.baseAddress;
      this.shift = recycle.shift;
      this.freeSlots = -1L;
      this.original = recycle.original;
      if (DEBUG)
        globalPool.debug.recycle(original);
    }
    Chunk(ByteBuffer slab) {
      assert !slab.hasArray();
      this.slab = slab;
      this.baseAddress = MemoryUtil.getAddress(slab);
      this.shift = 31 & (Integer.numberOfTrailingZeros(slab.capacity() / 64));
      this.freeSlots = slab.capacity() == 0 ? 0L : -1L;
      this.original = DEBUG ? this : null;
    }
    void acquire(LocalPool owner) {
      assert this.owner == null;
      this.owner = owner;
    }
    void release() {
      this.owner = null;
      tryRecycle();
    }
    void tryRecycle() {
      assert owner == null;
      if (isFree() && freeSlotsUpdater.compareAndSet(this, -1L, 0L))
        recycle();
    }
    void recycle() {
      assert freeSlots == 0L;
      globalPool.recycle(new Chunk(this));
    }
    static Chunk getParentChunk(ByteBuffer buffer) {
      Object attachment = MemoryUtil.getAttachment(buffer);
      if (attachment instanceof Chunk)
        return (Chunk)attachment;
      if (attachment instanceof Ref)
        return ((Ref<Chunk>)attachment).get();
      return null;
    }
    ByteBuffer setAttachment(ByteBuffer buffer) {
      if (Ref.DEBUG_ENABLED)
        MemoryUtil.setAttachment(buffer, new Ref<>(this, null));
      else
        MemoryUtil.setAttachment(buffer, this);
      return buffer;
    }
    boolean releaseAttachment(ByteBuffer buffer) {
      Object attachment = MemoryUtil.getAttachment(buffer);
      if (attachment == null)
        return false;
      if (attachment instanceof Ref)
        ((Ref<Chunk>)attachment).release();
      return true;
    }
    @VisibleForTesting
    void reset() {
      Chunk parent = getParentChunk(slab);
      if (parent != null)
        parent.free(slab, false);
      else
        FileUtils.clean(slab);
    }
    @VisibleForTesting
    long setFreeSlots(long val) {
      long ret = freeSlots;
      freeSlots = val;
      return ret;
    }
    int capacity() { return 64 << shift; }
    final int unit() { return 1 << shift; }
    final boolean isFree() { return freeSlots == -1L; }
    int free() { return Long.bitCount(freeSlots) * unit(); }
    ByteBuffer get(int size) {
      int slotCount = (size - 1 + unit()) >>> shift;
      if (slotCount > 64)
        return null;
      long slotBits = -1L >>> (64 - slotCount);
      long searchMask = 0x1111111111111111L;
      searchMask *= 15L >>> ((slotCount - 1) & 3);
      searchMask &= -1L >>> (slotCount - 1);
      while (true) {
        long cur = freeSlots;
        int index = Long.numberOfTrailingZeros(cur & searchMask);
        if (index == 64)
          return null;
        searchMask ^= 1L << index;
        long candidate = slotBits << index;
        if ((candidate & cur) == candidate) {
          while (true) {
            if (freeSlotsUpdater.compareAndSet(this, cur, cur & ~candidate))
              break;
            cur = freeSlots;
            assert ((candidate & cur) == candidate);
          }
          return get(index << shift, size);
        }
      }
    }
    private ByteBuffer get(int offset, int size) {
      slab.limit(offset + size);
      slab.position(offset);
      return setAttachment(slab.slice());
    }
    int roundUp(int v) { return BufferPool.roundUp(v, unit()); }
    long free(ByteBuffer buffer, boolean tryRelease) {
      if (!releaseAttachment(buffer))
        return 1L;
      long address = MemoryUtil.getAddress(buffer);
      assert (address >= baseAddress) & (address <= baseAddress + capacity());
      int position = (int)(address - baseAddress);
      int size = roundUp(buffer.capacity());
      position >>= shift;
      int slotCount = size >> shift;
      long slotBits = (1L << slotCount) - 1;
      long shiftedSlotBits = (slotBits << position);
      if (slotCount == 64) {
        assert size == capacity();
        assert position == 0;
        shiftedSlotBits = -1L;
      }
      long next;
      while (true) {
        long cur = freeSlots;
        next = cur | shiftedSlotBits;
        assert next == (cur ^ shiftedSlotBits);
        if (tryRelease && (next == -1L))
          next = 0L;
        if (freeSlotsUpdater.compareAndSet(this, cur, next))
          return next;
      }
    }
    @Override
    public String toString() {
      return String.format("[slab %s, slots bitmap %s, capacity %d, free %d]",
                           slab, Long.toBinaryString(freeSlots), capacity(),
                           free());
    }
  }
  @VisibleForTesting
  public static int roundUpNormal(int size) {
    return roundUp(size, CHUNK_SIZE / 64);
  }
  private static int roundUp(int size, int unit) {
    int mask = unit - 1;
    return (size + mask) & ~mask;
  }
  @VisibleForTesting
  public static void shutdownLocalCleaner(long timeout, TimeUnit unit)
      throws InterruptedException, TimeoutException {
    shutdownNow(Arrays.asList(EXEC));
    awaitTermination(timeout, unit, Arrays.asList(EXEC));
  }
}