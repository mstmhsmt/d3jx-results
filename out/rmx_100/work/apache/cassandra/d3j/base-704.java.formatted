// generated by Diff/AST Java Unparser
package org.apache.cassandra.db.compaction;
import java.io.File;
import java.io.IOException;
import java.lang.management.ManagementFactory;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.TimeUnit;
import javax.management.MBeanServer;
import javax.management.ObjectName;
import javax.management.openmbean.OpenDataException;
import javax.management.openmbean.TabularData;
import com.google.common.base.Predicate;
import com.google.common.base.Throwables;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ConcurrentHashMultiset;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import com.google.common.collect.Multimap;
import com.google.common.collect.Multiset;
import com.google.common.collect.Sets;
import com.google.common.util.concurrent.RateLimiter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.apache.cassandra.cache.AutoSavingCache;
import org.apache.cassandra.concurrent.DebuggableThreadPoolExecutor;
import org.apache.cassandra.concurrent.JMXEnabledThreadPoolExecutor;
import org.apache.cassandra.concurrent.NamedThreadFactory;
import org.apache.cassandra.config.CFMetaData;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.config.Schema;
import org.apache.cassandra.db.Cell;
import org.apache.cassandra.db.ColumnFamilyStore;
import org.apache.cassandra.db.DecoratedKey;
import org.apache.cassandra.db.Keyspace;
import org.apache.cassandra.db.OnDiskAtom;
import org.apache.cassandra.db.SystemKeyspace;
import org.apache.cassandra.db.compaction.CompactionInfo.Holder;
import org.apache.cassandra.db.index.SecondaryIndexBuilder;
import org.apache.cassandra.dht.Bounds;
import org.apache.cassandra.dht.Range;
import org.apache.cassandra.dht.Token;
import org.apache.cassandra.io.sstable.Descriptor;
import org.apache.cassandra.io.sstable.SSTableIdentityIterator;
import org.apache.cassandra.io.sstable.SSTableReader;
import org.apache.cassandra.io.sstable.SSTableRewriter;
import org.apache.cassandra.io.sstable.SSTableWriter;
import org.apache.cassandra.io.sstable.metadata.MetadataCollector;
import org.apache.cassandra.io.util.FileUtils;
import org.apache.cassandra.metrics.CompactionMetrics;
import org.apache.cassandra.repair.Validator;
import org.apache.cassandra.service.ActiveRepairService;
import org.apache.cassandra.service.StorageService;
import org.apache.cassandra.utils.concurrent.OpOrder;
import org.apache.cassandra.utils.*;
public class CompactionManager implements CompactionManagerMBean
{
    public static final String MBEAN_OBJECT_NAME = "org.apache.cassandra.db:type=CompactionManager";
    private static final Logger logger = LoggerFactory.getLogger(CompactionManager.class);
    public static final CompactionManager instance;
    public static final int NO_GC = Integer.MIN_VALUE;
    public static final int GC_ALL = Integer.MAX_VALUE;
    public static final ThreadLocal<Boolean> isCompactionManager = new ThreadLocal<Boolean>() {
        @Override protected Boolean initialValue()
        {
            return false;
        }
    };
    static
    {
        instance = new CompactionManager();
        MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
        try
        {
            mbs.registerMBean(instance, new ObjectName(MBEAN_OBJECT_NAME));
        }
        catch (Exception e)
        {
            throw new RuntimeException(e);
        }
    }
    private final CompactionExecutor executor = new CompactionExecutor();
    private final CompactionExecutor validationExecutor = new ValidationExecutor();
    private final static CompactionExecutor cacheCleanupExecutor = new CacheCleanupExecutor();
    private final CompactionMetrics metrics = new CompactionMetrics(executor, validationExecutor);
    private final Multiset<ColumnFamilyStore> compactingCF = ConcurrentHashMultiset.create();
    private final RateLimiter compactionRateLimiter = RateLimiter.create(Double.MAX_VALUE);
    public RateLimiter getRateLimiter()
    {
        double currentThroughput = DatabaseDescriptor.getCompactionThroughputMbPerSec() * 1024.0 * 1024.0;
        if (currentThroughput == 0 || StorageService.instance.isBootstrapMode())
            currentThroughput = Double.MAX_VALUE;
        if (compactionRateLimiter.getRate() != currentThroughput)
            compactionRateLimiter.setRate(currentThroughput);
        return compactionRateLimiter;
    }
    public List<Future<?>> submitBackground(final ColumnFamilyStore cfs)
    {
        if (cfs.isAutoCompactionDisabled())
        {
            logger.debug("Autocompaction is disabled");
            return Collections.emptyList();
        }
        int count = compactingCF.count(cfs);
        if (count > 0 && executor.getActiveCount() >= executor.getMaximumPoolSize())
        {
            logger.debug("Background compaction is still running for {}.{} ({} "
                             + "remaining). Skipping",
                         cfs.keyspace.getName(), cfs.name, count);
            return Collections.emptyList();
        }
        logger.debug("Scheduling a background task check for {}.{} with {}", cfs.keyspace.getName(), cfs.name,
                     cfs.getCompactionStrategy().getClass().getSimpleName());
        List<Future<?>> futures = new ArrayList<Future<?>>();
        do
        {
            compactingCF.add(cfs);
            futures.add(executor.submit(new BackgroundCompactionTask(cfs)));
        } while (executor.getActiveCount() + futures.size() < executor.getMaximumPoolSize());
        return futures;
    }
    public boolean isCompacting(Iterable<ColumnFamilyStore> cfses)
    {
        for (ColumnFamilyStore cfs : cfses)
            if (!cfs.getDataTracker().getCompacting().isEmpty())
                return true;
        return false;
    }
    class BackgroundCompactionTask implements Runnable
    {
        private final ColumnFamilyStore cfs;
        BackgroundCompactionTask(ColumnFamilyStore cfs)
        {
            this.cfs = cfs;
        }
        public void run()
        {
            try
            {
                logger.debug("Checking {}.{}", cfs.keyspace.getName(), cfs.name);
                if (!cfs.isValid())
                {
                    logger.debug("Aborting compaction for dropped CF");
                    return;
                }
                AbstractCompactionStrategy strategy = cfs.getCompactionStrategy();
                AbstractCompactionTask task = strategy.getNextBackgroundTask(getDefaultGcBefore(cfs));
                if (task == null)
                {
                    logger.debug("No tasks available");
                    return;
                }
                task.execute(metrics);
            }
            finally
            {
                compactingCF.remove(cfs);
            }
            submitBackground(cfs);
        }
    }
    private AllSSTableOpStatus parallelAllSSTableOperation(final ColumnFamilyStore cfs,

                                                           final OneSSTableOperation operation)
        throws ExecutionException, InterruptedException
    {
        Iterable<SSTableReader> compactingSSTables = cfs.markAllCompacting();
        if (compactingSSTables == null)
        {
            logger.info("Aborting operation on {}.{} after failing to interrupt "
                            + "other compaction operations",
                        cfs.keyspace.getName(), cfs.name);
            return AllSSTableOpStatus.ABORTED;
        }
        if (Iterables.isEmpty(compactingSSTables))
        {
            logger.info("No sstables for {}.{}", cfs.keyspace.getName(), cfs.name);
            return AllSSTableOpStatus.SUCCESSFUL;
        }
        try
        {
            Iterable<SSTableReader> sstables = operation.filterSSTables(compactingSSTables);
            List<Future<Object>> futures = new ArrayList<>();
            for (final SSTableReader sstable : sstables)
            {
                futures.add(executor.submit(new Callable<Object>() {
                    @Override public Object call() throws Exception
                    {
                        operation.execute(sstable);
                        return this;
                    }
                }));
            }
            for (Future<Object> f : futures)
                f.get();
        }
        finally
        {
            cfs.getDataTracker().unmarkCompacting(compactingSSTables);
        }
        return AllSSTableOpStatus.SUCCESSFUL;
    }
    private static interface OneSSTableOperation {
        Iterable<SSTableReader> filterSSTables(Iterable<SSTableReader> input);
        void execute(SSTableReader input) throws IOException;
    }
    public enum AllSSTableOpStatus
    {
        ABORTED(1),
        SUCCESSFUL(0);
        public final int statusCode;
        AllSSTableOpStatus(int statusCode)
        {
            this.statusCode = statusCode;
        }
    }
    public AllSSTableOpStatus performScrub(final ColumnFamilyStore cfs, final boolean skipCorrupted)
        throws InterruptedException, ExecutionException
    {
        assert !cfs.isIndex();
        return parallelAllSSTableOperation(cfs, new OneSSTableOperation() {
            @Override public Iterable<SSTableReader> filterSSTables(Iterable<SSTableReader> input)
            {
                return input;
            }
            @Override public void execute(SSTableReader input) throws IOException
            {
                scrubOne(cfs, input, skipCorrupted);
            }
        });
    }
    public AllSSTableOpStatus performSSTableRewrite(final ColumnFamilyStore cfs, final boolean excludeCurrentVersion)
        throws InterruptedException, ExecutionException
    {
        return parallelAllSSTableOperation(cfs, new OneSSTableOperation() {
            @Override public Iterable<SSTableReader> filterSSTables(Iterable<SSTableReader> input)
            {
                return Iterables.filter(input, new Predicate<SSTableReader>() {
                    @Override public boolean apply(SSTableReader sstable)
                    {
                        return !(excludeCurrentVersion &&
                                 sstable.descriptor.version.equals(Descriptor.Version.CURRENT));
                    }
                });
            }
            @Override public void execute(SSTableReader input) throws IOException
            {
                AbstractCompactionTask task =
                    cfs.getCompactionStrategy().getCompactionTask(Collections.singleton(input), NO_GC, Long.MAX_VALUE);
                task.setUserDefined(true);
                task.setCompactionType(OperationType.UPGRADE_SSTABLES);
                task.execute(metrics);
            }
        });
    }
    public AllSSTableOpStatus performCleanup(final ColumnFamilyStore cfStore)
        throws InterruptedException, ExecutionException
    {
        assert !cfStore.isIndex();
        Keyspace keyspace = cfStore.keyspace;
        final Collection<Range<Token>> ranges = StorageService.instance.getLocalRanges(keyspace.getName());
        if (ranges.isEmpty())
        {
            logger.info("Cleanup cannot run before a node has joined the ring");
            return AllSSTableOpStatus.ABORTED;
        }
        final boolean hasIndexes = cfStore.indexManager.hasIndexes();
        final CleanupStrategy cleanupStrategy = CleanupStrategy.get(cfStore, ranges);
        return parallelAllSSTableOperation(cfStore, new OneSSTableOperation() {
            @Override public Iterable<SSTableReader> filterSSTables(Iterable<SSTableReader> input)
            {
                List<SSTableReader> sortedSSTables = Lists.newArrayList(input);
                Collections.sort(sortedSSTables, new SSTableReader.SizeComparator());
                return sortedSSTables;
            }
            @Override public void execute(SSTableReader input) throws IOException
            {
                doCleanupOne(cfStore, input, cleanupStrategy, ranges, hasIndexes);
            }
        });
    }
    public Future<?> submitAntiCompaction(final ColumnFamilyStore cfs, final Collection<Range<Token>> ranges,
                                          final Collection<SSTableReader> validatedForRepair, final long repairedAt)
    {
        Runnable runnable = new WrappedRunnable() {
            @Override public void runMayThrow() throws Exception
            {
                performAnticompaction(cfs, ranges, validatedForRepair, repairedAt);
            }
        };
        return executor.submit(runnable);
    }
    public void performAnticompaction(ColumnFamilyStore cfs, Collection<Range<Token>> ranges,
                                      Collection<SSTableReader> validatedForRepair, long repairedAt)
        throws InterruptedException, ExecutionException, IOException
    {
        logger.info("Starting anticompaction");
        logger.debug("Starting anticompaction for ranges {}", ranges);
        Set<SSTableReader> sstables = new HashSet<>(validatedForRepair);
        Set<SSTableReader> mutatedRepairStatuses = new HashSet<>();
        Set<SSTableReader> nonAnticompacting = new HashSet<>();
        Iterator<SSTableReader> sstableIterator = sstables.iterator();
        while (sstableIterator.hasNext())
        {
            SSTableReader sstable = sstableIterator.next();
            for (Range<Token> r : Range.normalize(ranges))
            {
                Range<Token> sstableRange =
                    new Range<>(sstable.first.getToken(), sstable.last.getToken(), sstable.partitioner);
                if (r.contains(sstableRange))
                {
                    logger.info("SSTable {} fully contained in range {}, mutating "
                                    + "repairedAt instead of anticompacting",
                                sstable, r);
                    sstable.descriptor.getMetadataSerializer().mutateRepairedAt(sstable.descriptor, repairedAt);
                    sstable.reloadSSTableMetadata();
                    mutatedRepairStatuses.add(sstable);
                    sstableIterator.remove();
                    break;
                }
                else if (!sstableRange.intersects(r))
                {
                    logger.info("SSTable {} ({}) does not intersect repaired range {}, "
                                    + "not touching repairedAt.",
                                sstable, sstableRange, r);
                    nonAnticompacting.add(sstable);
                    sstableIterator.remove();
                    break;
                }
                else
                {
                    logger.info("SSTable {} ({}) will be anticompacted on range {}", sstable, sstableRange, r);
                }
            }
        }
        cfs.getDataTracker().notifySSTableRepairedStatusChanged(mutatedRepairStatuses);
        cfs.getDataTracker().unmarkCompacting(Sets.union(nonAnticompacting, mutatedRepairStatuses));
        if (!sstables.isEmpty())
            doAntiCompaction(cfs, ranges, sstables, repairedAt);
        SSTableReader.releaseReferences(sstables);
        cfs.getDataTracker().unmarkCompacting(sstables);
        logger.info(String.format("Completed anticompaction successfully"));
    }
    public void performMaximal(final ColumnFamilyStore cfStore) throws InterruptedException, ExecutionException
    {
        submitMaximal(cfStore, getDefaultGcBefore(cfStore)).get();
    }
    public Future<?> submitMaximal(final ColumnFamilyStore cfStore, final int gcBefore)
    {
        final Collection<AbstractCompactionTask> tasks = cfStore.getCompactionStrategy().getMaximalTask(gcBefore);
        Runnable runnable = new WrappedRunnable() {
            protected void runMayThrow() throws IOException
            {
                if (tasks == null)
                    return;
                for (AbstractCompactionTask task : tasks)
                    task.execute(metrics);
            }
        };
        return executor.submit(runnable);
    }
    public void forceUserDefinedCompaction(String dataFiles)
    {
        String[] filenames = dataFiles.split(",");
        Multimap<ColumnFamilyStore, Descriptor> descriptors = ArrayListMultimap.create();
        for (String filename : filenames)
        {
            Descriptor desc = Descriptor.fromFilename(filename.trim());
            if (Schema.instance.getCFMetaData(desc) == null)
            {
                logger.warn("Schema does not exist for file {}. Skipping.", filename);
                continue;
            }
            ColumnFamilyStore cfs = Keyspace.open(desc.ksname).getColumnFamilyStore(desc.cfname);
            descriptors.put(cfs, cfs.directories.find(filename.trim()));
        }
        List<Future<?>> futures = new ArrayList<>();
        for (ColumnFamilyStore cfs : descriptors.keySet())
            futures.add(submitUserDefined(cfs, descriptors.get(cfs), getDefaultGcBefore(cfs)));
        FBUtilities.waitOnFutures(futures);
    }
    public Future<?> submitUserDefined(final ColumnFamilyStore cfs, final Collection<Descriptor> dataFiles,
                                       final int gcBefore)
    {
        Runnable runnable = new WrappedRunnable() {
            protected void runMayThrow() throws IOException
            {
                Collection<SSTableReader> sstables = new ArrayList<SSTableReader>(dataFiles.size());
                for (Descriptor desc : dataFiles)
                {
                    SSTableReader sstable = lookupSSTable(cfs, desc);
                    if (sstable == null)
                    {
                        logger.info("Will not compact {}: it is not an active sstable", desc);
                    }
                    else
                    {
                        sstables.add(sstable);
                    }
                }
                if (sstables.isEmpty())
                {
                    logger.info("No files to compact for user defined compaction");
                }
                else
                {
                    AbstractCompactionTask task = cfs.getCompactionStrategy().getUserDefinedTask(sstables, gcBefore);
                    if (task != null)
                        task.execute(metrics);
                }
            }
        };
        return executor.submit(runnable);
    }
    private SSTableReader lookupSSTable(final ColumnFamilyStore cfs, Descriptor descriptor)
    {
        for (SSTableReader sstable : cfs.getSSTables())
        {
            if (sstable.descriptor.equals(descriptor))
                return sstable;
        }
        return null;
    }
    public Future<Object> submitValidation(final ColumnFamilyStore cfStore, final Validator validator)
    {
        Callable<Object> callable = new Callable<Object>() {
            public Object call() throws IOException
            {
                try
                {
                    doValidationCompaction(cfStore, validator);
                }
                catch (Throwable e)
                {
                    validator.fail();
                    throw e;
                }
                return this;
            }
        };
        return validationExecutor.submit(callable);
    }
    public void disableAutoCompaction()
    {
        for (String ksname : Schema.instance.getNonSystemKeyspaces())
        {
            for (ColumnFamilyStore cfs : Keyspace.open(ksname).getColumnFamilyStores())
                cfs.disableAutoCompaction();
        }
    }
    private void scrubOne(ColumnFamilyStore cfs, SSTableReader sstable, boolean skipCorrupted) throws IOException
    {
        Scrubber scrubber = new Scrubber(cfs, sstable, skipCorrupted, false);
        CompactionInfo.Holder scrubInfo = scrubber.getScrubInfo();
        metrics.beginCompaction(scrubInfo);
        try
        {
            scrubber.scrub();
        }
        finally
        {
            scrubber.close();
            metrics.finishCompaction(scrubInfo);
        }
    }
    static boolean needsCleanup(SSTableReader sstable, Collection<Range<Token>> ownedRanges)
    {
        assert !ownedRanges.isEmpty();
        List<Range<Token>> sortedRanges = Range.normalize(ownedRanges);
        Range<Token> firstRange = sortedRanges.get(0);
        if (sstable.first.getToken().compareTo(firstRange.left) <= 0)
            return true;
        for (int i = 0; i < sortedRanges.size(); i++)
        {
            Range<Token> range = sortedRanges.get(i);
            if (range.right.isMinimum())
            {
                return false;
            }
            DecoratedKey firstBeyondRange = sstable.firstKeyBeyond(range.right.maxKeyBound());
            if (firstBeyondRange == null)
            {
                return false;
            }
            if (i == (sortedRanges.size() - 1))
            {
                return true;
            }
            Range<Token> nextRange = sortedRanges.get(i + 1);
            if (!nextRange.contains(firstBeyondRange.getToken()))
            {
                return true;
            }
        }
        return false;
    }
    private void doCleanupOne(final ColumnFamilyStore cfs, SSTableReader sstable, CleanupStrategy cleanupStrategy,
                              Collection<Range<Token>> ranges, boolean hasIndexes) throws IOException
    {
        assert !cfs.isIndex();
        if (!hasIndexes && !new Bounds<>(sstable.first.getToken(), sstable.last.getToken()).intersects(ranges))
        {
            cfs.getDataTracker().markCompactedSSTablesReplaced(
                Arrays.asList(sstable), Collections.<SSTableReader>emptyList(), OperationType.CLEANUP);
            return;
        }
        if (!needsCleanup(sstable, ranges))
        {
            logger.debug("Skipping {} for cleanup; all rows should be kept", sstable);
            return;
        }
        long start = System.nanoTime();
        long totalkeysWritten = 0;
        int expectedBloomFilterSize = Math.max(cfs.metadata.getMinIndexInterval(),
                                               (int)(SSTableReader.getApproximateKeyCount(Arrays.asList(sstable))));
        if (logger.isDebugEnabled())
            logger.debug("Expected bloom filter size : {}", expectedBloomFilterSize);
        logger.info("Cleaning up {}", sstable);
        File compactionFileLocation = cfs.directories.getDirectoryForNewSSTables();
        if (compactionFileLocation == null)
            throw new IOException("disk full");
        ICompactionScanner scanner = cleanupStrategy.getScanner(sstable, getRateLimiter());
        CleanupInfo ci = new CleanupInfo(sstable, scanner);
        metrics.beginCompaction(ci);
        Set<SSTableReader> oldSSTable = Sets.newHashSet(sstable);
        SSTableRewriter writer = new SSTableRewriter(cfs, oldSSTable, sstable.maxDataAge, false);
        List<SSTableReader> finished;
        try (CompactionController controller =
                 new CompactionController(cfs, Collections.singleton(sstable), getDefaultGcBefore(cfs)))
        {
            writer.switchWriter(createWriter(cfs, compactionFileLocation, expectedBloomFilterSize,
                                             sstable.getSSTableMetadata().repairedAt, sstable));
            while (scanner.hasNext())
            {
                if (ci.isStopRequested())
                    throw new CompactionInterruptedException(ci.getCompactionInfo());
                SSTableIdentityIterator row = (SSTableIdentityIterator)scanner.next();
                row = cleanupStrategy.cleanup(row);
                if (row == null)
                    continue;
                AbstractCompactedRow compactedRow = new LazilyCompactedRow(controller, Collections.singletonList(row));
                if (writer.append(compactedRow) != null)
                    totalkeysWritten++;
            }
            cfs.indexManager.flushIndexesBlocking();
            finished = writer.finish();
            cfs.getDataTracker().markCompactedSSTablesReplaced(oldSSTable, finished, OperationType.CLEANUP);
        }
        catch (Throwable e)
        {
            writer.abort();
            throw Throwables.propagate(e);
        }
        finally
        {
            scanner.close();
            metrics.finishCompaction(ci);
        }
        if (!finished.isEmpty())
        {
            String format = "Cleaned up to %s.  %,d to %,d (~%d%% of original) "
                            + "bytes for %,d keys.  Time: %,dms.";
            long dTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);
            long startsize = sstable.onDiskLength();
            long endsize = 0;
            for (SSTableReader newSstable : finished)
                endsize += newSstable.onDiskLength();
            double ratio = (double)endsize / (double)startsize;
            logger.info(String.format(format, finished.get(0).getFilename(), startsize, endsize, (int)(ratio * 100),
                                      totalkeysWritten, dTime));
        }
    }
    private static abstract class CleanupStrategy
    {
        public static CleanupStrategy get(ColumnFamilyStore cfs, Collection<Range<Token>> ranges)
        {
            return cfs.indexManager.hasIndexes() ? new Full(cfs, ranges) : new Bounded(cfs, ranges);
        }
        public abstract ICompactionScanner getScanner(SSTableReader sstable, RateLimiter limiter);
        public abstract SSTableIdentityIterator cleanup(SSTableIdentityIterator row);
        private static final class Bounded extends CleanupStrategy
        {
            private final Collection<Range<Token>> ranges;
            public Bounded(final ColumnFamilyStore cfs, Collection<Range<Token>> ranges)
            {
                this.ranges = ranges;
                cacheCleanupExecutor.submit(new Runnable() {
                    @Override public void run()
                    {
                        cfs.cleanupCache();
                    }
                });
            }
            @Override public ICompactionScanner getScanner(SSTableReader sstable, RateLimiter limiter)
            {
                return sstable.getScanner(ranges, limiter);
            }
            @Override public SSTableIdentityIterator cleanup(SSTableIdentityIterator row)
            {
                return row;
            }
        }
        private static final class Full extends CleanupStrategy
        {
            private final Collection<Range<Token>> ranges;
            private final ColumnFamilyStore cfs;
            private List<Cell> indexedColumnsInRow;
            public Full(ColumnFamilyStore cfs, Collection<Range<Token>> ranges)
            {
                this.cfs = cfs;
                this.ranges = ranges;
                this.indexedColumnsInRow = null;
            }
            @Override public ICompactionScanner getScanner(SSTableReader sstable, RateLimiter limiter)
            {
                return sstable.getScanner(limiter);
            }
            @Override public SSTableIdentityIterator cleanup(SSTableIdentityIterator row)
            {
                if (Range.isInRanges(row.getKey().getToken(), ranges))
                    return row;
                cfs.invalidateCachedRow(row.getKey());
                if (indexedColumnsInRow != null)
                    indexedColumnsInRow.clear();
                while (row.hasNext())
                {
                    OnDiskAtom column = row.next();
                    if (column instanceof Cell && cfs.indexManager.indexes((Cell)column))
                    {
                        if (indexedColumnsInRow == null)
                            indexedColumnsInRow = new ArrayList<>();
                        indexedColumnsInRow.add((Cell)column);
                    }
                }
                if (indexedColumnsInRow != null && !indexedColumnsInRow.isEmpty())
                {
                    try (OpOrder.Group opGroup = cfs.keyspace.writeOrder.start())
                    {
                        cfs.indexManager.deleteFromIndexes(row.getKey(), indexedColumnsInRow, opGroup);
                    }
                }
                return null;
            }
        }
    }
    public static SSTableWriter createWriter(ColumnFamilyStore cfs, File compactionFileLocation,
                                             int expectedBloomFilterSize, long repairedAt, SSTableReader sstable)
    {
        FileUtils.createDirectory(compactionFileLocation);
        return new SSTableWriter(
            cfs.getTempSSTablePath(compactionFileLocation), expectedBloomFilterSize, repairedAt, cfs.metadata,
            cfs.partitioner,
            new MetadataCollector(Collections.singleton(sstable), cfs.metadata.comparator, sstable.getSSTableLevel()));
    }
    private void doValidationCompaction(ColumnFamilyStore cfs, Validator validator) throws IOException
    {
        if (!cfs.isValid())
            return;
        Collection<SSTableReader> sstables = null;
        try
        {
            String snapshotName = validator.desc.sessionId.toString();
            int gcBefore;
            boolean isSnapshotValidation = cfs.snapshotExists(snapshotName);
            if (isSnapshotValidation)
            {
                sstables = cfs.getSnapshotSSTableReader(snapshotName);
                gcBefore = cfs.gcBefore(cfs.getSnapshotCreationTime(snapshotName));
            }
            else
            {
                StorageService.instance.forceKeyspaceFlush(cfs.keyspace.getName(), cfs.name);
                if (validator.desc.parentSessionId == null ||
                    ActiveRepairService.instance.getParentRepairSession(validator.desc.parentSessionId) == null)
                    sstables = cfs.markCurrentSSTablesReferenced();
                else
                    sstables = ActiveRepairService.instance.getParentRepairSession(validator.desc.parentSessionId)
                                   .getAndReferenceSSTables(cfs.metadata.cfId);
                if (validator.gcBefore > 0)
                    gcBefore = validator.gcBefore;
                else
                    gcBefore = getDefaultGcBefore(cfs);
            }
            long numPartitions = 0;
            for (SSTableReader sstable : sstables)
            {
                numPartitions += sstable.estimatedKeysForRanges(Collections.singleton(validator.desc.range));
            }
            int depth = numPartitions > 0 ? (int)Math.min(Math.floor(Math.log(numPartitions)), 20) : 0;
            MerkleTree tree = new MerkleTree(cfs.partitioner, validator.desc.range, MerkleTree.RECOMMENDED_DEPTH,
                                             (int)Math.pow(2, depth));
            long start = System.nanoTime();
            try (AbstractCompactionStrategy.ScannerList scanners =
                     cfs.getCompactionStrategy().getScanners(sstables, validator.desc.range))
            {
                CompactionIterable ci = new ValidationCompactionIterable(cfs, scanners.scanners, gcBefore);
                Iterator<AbstractCompactedRow> iter = ci.iterator();
                metrics.beginCompaction(ci);
                try
                {
                    validator.prepare(cfs, tree);
                    while (iter.hasNext())
                    {
                        if (ci.isStopRequested())
                            throw new CompactionInterruptedException(ci.getCompactionInfo());
                        AbstractCompactedRow row = iter.next();
                        validator.add(row);
                    }
                    validator.complete();
                }
                finally
                {
                    if (isSnapshotValidation)
                    {
                        cfs.clearSnapshot(snapshotName);
                    }
                    metrics.finishCompaction(ci);
                }
            }
            if (logger.isDebugEnabled())
            {
                long duration = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);
                logger.debug("Validation finished in {} msec, depth {} for {} keys, "
                                 + "serialized size {} bytes for {}",
                             duration, depth, numPartitions, MerkleTree.serializer.serializedSize(tree, 0),
                             validator.desc);
            }
        }
        finally
        {
            if (sstables != null)
                SSTableReader.releaseReferences(sstables);
        }
    }
    private Collection<SSTableReader> doAntiCompaction(ColumnFamilyStore cfs, Collection<Range<Token>> ranges,

                                                       Collection<SSTableReader> repairedSSTables, long repairedAt)
    {
        List<SSTableReader> anticompactedSSTables = new ArrayList<>();
        int repairedKeyCount = 0;
        int unrepairedKeyCount = 0;
        int expectedBloomFilterSize =
            Math.max(cfs.metadata.getMinIndexInterval(), (int)(SSTableReader.getApproximateKeyCount(repairedSSTables)));
        logger.info("Performing anticompaction on {} sstables", repairedSSTables.size());
        for (SSTableReader sstable : repairedSSTables)
        {
            if (!new File(sstable.getFilename()).exists())
            {
                logger.info("Skipping anticompaction for {}, required sstable was "
                                + "compacted and is no longer available.",
                            sstable);
                continue;
            }
            logger.info("Anticompacting {}", sstable);
            Set<SSTableReader> sstableAsSet = new HashSet<>();
            sstableAsSet.add(sstable);
            File destination = cfs.directories.getDirectoryForNewSSTables();
            SSTableRewriter repairedSSTableWriter = new SSTableRewriter(cfs, sstableAsSet, sstable.maxDataAge, false);
            SSTableRewriter unRepairedSSTableWriter = new SSTableRewriter(cfs, sstableAsSet, sstable.maxDataAge, false);
            AbstractCompactionStrategy strategy = cfs.getCompactionStrategy();
            try (AbstractCompactionStrategy.ScannerList scanners =
                     strategy.getScanners(new HashSet<>(Collections.singleton(sstable)));
                 CompactionController controller =
                     new CompactionController(cfs, sstableAsSet, CFMetaData.DEFAULT_GC_GRACE_SECONDS))
            {
                repairedSSTableWriter.switchWriter(
                    CompactionManager.createWriter(cfs, destination, expectedBloomFilterSize, repairedAt, sstable));
                unRepairedSSTableWriter.switchWriter(CompactionManager.createWriter(
                    cfs, destination, expectedBloomFilterSize, ActiveRepairService.UNREPAIRED_SSTABLE, sstable));
                CompactionIterable ci =
                    new CompactionIterable(OperationType.ANTICOMPACTION, scanners.scanners, controller);
                Iterator<AbstractCompactedRow> iter = ci.iterator();
                while (iter.hasNext())
                {
                    AbstractCompactedRow row = iter.next();
                    if (Range.isInRanges(row.key.getToken(), ranges))
                    {
                        repairedSSTableWriter.append(row);
                        repairedKeyCount++;
                    }
                    else
                    {
                        unRepairedSSTableWriter.append(row);
                        unrepairedKeyCount++;
                    }
                }
                anticompactedSSTables.addAll(repairedSSTableWriter.finish(repairedAt));
                anticompactedSSTables.addAll(unRepairedSSTableWriter.finish(ActiveRepairService.UNREPAIRED_SSTABLE));
                cfs.getDataTracker().markCompactedSSTablesReplaced(sstableAsSet, anticompactedSSTables,
                                                                   OperationType.ANTICOMPACTION);
            }
            catch (Throwable e)
            {
                JVMStabilityInspector.inspectThrowable(e);
                logger.error("Error anticompacting " + sstable, e);
                repairedSSTableWriter.abort();
                unRepairedSSTableWriter.abort();
            }
        }
        String format = "Repaired {} keys of {} for {}/{}";
        logger.debug(format, repairedKeyCount, (repairedKeyCount + unrepairedKeyCount), cfs.keyspace,
                     cfs.getColumnFamilyName());
        String format2 = "Anticompaction completed successfully, anticompacted "
                         + "from {} to {} sstable(s).";
        logger.info(format2, repairedSSTables.size(), anticompactedSSTables.size());
        return anticompactedSSTables;
    }
    public Future<?> submitIndexBuild(final SecondaryIndexBuilder builder)
    {
        Runnable runnable = new Runnable() {
            public void run()
            {
                metrics.beginCompaction(builder);
                try
                {
                    builder.build();
                }
                finally
                {
                    metrics.finishCompaction(builder);
                }
            }
        };
        return executor.submit(runnable);
    }
    public Future<?> submitCacheWrite(final AutoSavingCache.Writer writer)
    {
        Runnable runnable = new Runnable() {
            public void run()
            {
                if (!AutoSavingCache.flushInProgress.add(writer.cacheType()))
                {
                    logger.debug("Cache flushing was already in progress: skipping {}", writer.getCompactionInfo());
                    return;
                }
                try
                {
                    metrics.beginCompaction(writer);
                    try
                    {
                        writer.saveCache();
                    }
                    finally
                    {
                        metrics.finishCompaction(writer);
                    }
                }
                finally
                {
                    AutoSavingCache.flushInProgress.remove(writer.cacheType());
                }
            }
        };
        return executor.submit(runnable);
    }
    static int getDefaultGcBefore(ColumnFamilyStore cfs)
    {
        return cfs.isIndex() ? (int)(System.currentTimeMillis() / 1000) : cfs.gcBefore(System.currentTimeMillis());
    }
    private static class ValidationCompactionIterable extends CompactionIterable
    {
        public ValidationCompactionIterable(ColumnFamilyStore cfs, List<ICompactionScanner> scanners, int gcBefore)
        {
            super(OperationType.VALIDATION, scanners, new ValidationCompactionController(cfs, gcBefore));
        }
    }
    private static class ValidationCompactionController extends CompactionController
    {
        public ValidationCompactionController(ColumnFamilyStore cfs, int gcBefore)
        {
            super(cfs, gcBefore);
        }
        @Override public long maxPurgeableTimestamp(DecoratedKey key)
        {
            return Long.MAX_VALUE;
        }
    }
    public int getActiveCompactions()
    {
        return CompactionMetrics.getCompactions().size();
    }
    private static class CompactionExecutor extends JMXEnabledThreadPoolExecutor
    {
        protected CompactionExecutor(int minThreads, int maxThreads, String name, BlockingQueue<Runnable> queue)
        {
            super(minThreads, maxThreads, 60, TimeUnit.SECONDS, queue,
                  new NamedThreadFactory(name, Thread.MIN_PRIORITY), "internal");
        }
        private CompactionExecutor(int threadCount, String name)
        {
            this(threadCount, threadCount, name, new LinkedBlockingQueue<Runnable>());
        }
        public CompactionExecutor()
        {
            this(Math.max(1, DatabaseDescriptor.getConcurrentCompactors()), "CompactionExecutor");
        }
        protected void beforeExecute(Thread t, Runnable r)
        {
            isCompactionManager.set(true);
            super.beforeExecute(t, r);
        }
        @Override public void afterExecute(Runnable r, Throwable t)
        {
            DebuggableThreadPoolExecutor.maybeResetTraceSessionWrapper(r);
            if (t == null)
                t = DebuggableThreadPoolExecutor.extractThrowable(r);
            if (t != null)
            {
                if (t instanceof CompactionInterruptedException)
                {
                    logger.info(t.getMessage());
                    logger.debug("Full interruption stack trace:", t);
                }
                else
                {
                    DebuggableThreadPoolExecutor.handleOrLog(t);
                }
            }
        }
    }
    private static class ValidationExecutor extends CompactionExecutor
    {
        public ValidationExecutor()
        {
            super(1, Integer.MAX_VALUE, "ValidationExecutor", new SynchronousQueue<Runnable>());
        }
    }
    private static class CacheCleanupExecutor extends CompactionExecutor
    {
        public CacheCleanupExecutor()
        {
            super(1, "CacheCleanupExecutor");
        }
    }
    public interface CompactionExecutorStatsCollector
    {
        void beginCompaction(CompactionInfo.Holder ci);
        void finishCompaction(CompactionInfo.Holder ci);
    }
    public List<Map<String, String>> getCompactions()
    {
        List<Holder> compactionHolders = CompactionMetrics.getCompactions();
        List<Map<String, String>> out = new ArrayList<Map<String, String>>(compactionHolders.size());
        for (CompactionInfo.Holder ci : compactionHolders)
            out.add(ci.getCompactionInfo().asMap());
        return out;
    }
    public List<String> getCompactionSummary()
    {
        List<Holder> compactionHolders = CompactionMetrics.getCompactions();
        List<String> out = new ArrayList<String>(compactionHolders.size());
        for (CompactionInfo.Holder ci : compactionHolders)
            out.add(ci.getCompactionInfo().toString());
        return out;
    }
    public TabularData getCompactionHistory()
    {
        try
        {
            return SystemKeyspace.getCompactionHistory();
        }
        catch (OpenDataException e)
        {
            throw new RuntimeException(e);
        }
    }
    public long getTotalBytesCompacted()
    {
        return metrics.bytesCompacted.count();
    }
    public long getTotalCompactionsCompleted()
    {
        return metrics.totalCompactionsCompleted.count();
    }
    public int getPendingTasks()
    {
        return metrics.pendingTasks.value();
    }
    public long getCompletedTasks()
    {
        return metrics.completedTasks.value();
    }
    private static class CleanupInfo extends CompactionInfo.Holder
    {
        private final SSTableReader sstable;
        private final ICompactionScanner scanner;
        public CleanupInfo(SSTableReader sstable, ICompactionScanner scanner)
        {
            this.sstable = sstable;
            this.scanner = scanner;
        }
        public CompactionInfo getCompactionInfo()
        {
            try
            {
                return new CompactionInfo(sstable.metadata, OperationType.CLEANUP, scanner.getCurrentPosition(),
                                          scanner.getLengthInBytes());
            }
            catch (Exception e)
            {
                throw new RuntimeException();
            }
        }
    }
    public void stopCompaction(String type)
    {
        OperationType operation = OperationType.valueOf(type);
        for (Holder holder : CompactionMetrics.getCompactions())
        {
            if (holder.getCompactionInfo().getTaskType() == operation)
                holder.stop();
        }
    }
    public int getCoreCompactorThreads()
    {
        return executor.getCorePoolSize();
    }
    public void setCoreCompactorThreads(int number)
    {
        executor.setCorePoolSize(number);
    }
    public int getMaximumCompactorThreads()
    {
        return executor.getMaximumPoolSize();
    }
    public void setMaximumCompactorThreads(int number)
    {
        executor.setMaximumPoolSize(number);
    }
    public int getCoreValidationThreads()
    {
        return validationExecutor.getCorePoolSize();
    }
    public void setCoreValidationThreads(int number)
    {
        validationExecutor.setCorePoolSize(number);
    }
    public int getMaximumValidatorThreads()
    {
        return validationExecutor.getMaximumPoolSize();
    }
    public void setMaximumValidatorThreads(int number)
    {
        validationExecutor.setMaximumPoolSize(number);
    }
    public void interruptCompactionFor(Iterable<CFMetaData> columnFamilies, boolean interruptValidation)
    {
        assert columnFamilies != null;
        for (Holder compactionHolder : CompactionMetrics.getCompactions())
        {
            CompactionInfo info = compactionHolder.getCompactionInfo();
            if ((info.getTaskType() == OperationType.VALIDATION) && !interruptValidation)
                continue;
            if (Iterables.contains(columnFamilies, info.getCFMetaData()))
                compactionHolder.stop();
        }
    }
}