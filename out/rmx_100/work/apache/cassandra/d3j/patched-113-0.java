// generated by Diff/AST Java Unparser
package org.apache.cassandra.utils.memory;
import java.lang.ref.PhantomReference;
import java.lang.ref.ReferenceQueue;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayDeque;
import java.util.Collections;
import java.util.Queue;
import java.util.Set;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicLongFieldUpdater;
import java.util.concurrent.atomic.LongAdder;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
import java.util.function.BiPredicate;
import java.util.function.Consumer;
import java.util.function.Supplier;
import com.google.common.annotations.VisibleForTesting;
import net.nicoulaj.compilecommand.annotations.Inline;
import org.apache.cassandra.concurrent.InfiniteLoopExecutor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import io.netty.util.concurrent.FastThreadLocal;
import org.apache.cassandra.io.compress.BufferType;
import org.apache.cassandra.io.util.FileUtils;
import org.apache.cassandra.metrics.BufferPoolMetrics;
import org.apache.cassandra.utils.NoSpamLogger;
import org.apache.cassandra.utils.concurrent.Ref;
import static com.google.common.collect.ImmutableList.of;
import static org.apache.cassandra.utils.ExecutorUtils.*;
import static org.apache.cassandra.utils.FBUtilities.prettyPrintMemory;
import static org.apache.cassandra.utils.memory.MemoryUtil.isExactlyDirect;
public class BufferPool {
  public static final int NORMAL_CHUNK_SIZE = 128 << 10;
  public static final int NORMAL_ALLOCATION_UNIT = NORMAL_CHUNK_SIZE / 64;
  public static final int TINY_CHUNK_SIZE = NORMAL_ALLOCATION_UNIT;
  public static final int TINY_ALLOCATION_UNIT = TINY_CHUNK_SIZE / 64;
  public static final int TINY_ALLOCATION_LIMIT = TINY_CHUNK_SIZE / 2;
  private static final Logger logger =
      LoggerFactory.getLogger(BufferPool.class);
  private static final NoSpamLogger noSpamLogger =
      NoSpamLogger.getLogger(logger, 15L, TimeUnit.MINUTES);
  private static final ByteBuffer EMPTY_BUFFER = ByteBuffer.allocateDirect(0);
  private volatile Debug debug = Debug.NO_OP;
  protected final String name;
  protected final BufferPoolMetrics metrics;
  private final long memoryUsageThreshold;
  private final String readableMemoryUsageThreshold;
  private final LongAdder overflowMemoryUsage = new LongAdder();
  private final LongAdder memoryInUse = new LongAdder();
  private final AtomicLong memoryAllocated = new AtomicLong();
  private final GlobalPool globalPool;
  private final boolean recyclePartially;
  private final FastThreadLocal<LocalPool> localPool =
      new FastThreadLocal<LocalPool>() {
        @Override
        protected LocalPool initialValue() {
          return new LocalPool();
        }
        protected void onRemoval(LocalPool value) { value.release(); }
      };
  private final Set<LocalPoolRef> localPoolReferences =
      Collections.newSetFromMap(new ConcurrentHashMap<>());
  private final ReferenceQueue<Object> localPoolRefQueue =
      new ReferenceQueue<>();
  private final InfiniteLoopExecutor localPoolCleaner;
  public BufferPool(String name, long memoryUsageThreshold,
                    boolean recyclePartially) {
    this.name = name;
    this.memoryUsageThreshold = memoryUsageThreshold;
    this.readableMemoryUsageThreshold = prettyPrintMemory(memoryUsageThreshold);
    this.globalPool = new GlobalPool();
    this.metrics = new BufferPoolMetrics(name, this);
    this.recyclePartially = recyclePartially;
    this.localPoolCleaner =
        new InfiniteLoopExecutor("LocalPool-Cleaner-" + name,
                                 this::cleanupOneReference)
            .start();
  }
  public LocalPool create() { return new LocalPool(); }
  public ByteBuffer get(int size, BufferType bufferType) {
    if (bufferType == BufferType.ON_HEAP)
      return allocate(size, bufferType);
    else
      return localPool.get().get(size);
  }
  public ByteBuffer getAtLeast(int size, BufferType bufferType) {
    if (bufferType == BufferType.ON_HEAP)
      return allocate(size, bufferType);
    else
      return localPool.get().getAtLeast(size);
  }
  public ByteBuffer tryGet(int size) {
    return localPool.get().tryGet(size, false);
  }
  public ByteBuffer tryGetAtLeast(int size) {
    return localPool.get().tryGet(size, true);
  }
  private ByteBuffer allocate(int size, BufferType bufferType) {
    updateOverflowMemoryUsage(size);
    return bufferType == BufferType.ON_HEAP ? ByteBuffer.allocate(size)
                                            : ByteBuffer.allocateDirect(size);
  }
  public void put(ByteBuffer buffer) {
    if (isExactlyDirect(buffer))
      localPool.get().put(buffer);
    else
      updateOverflowMemoryUsage(-buffer.capacity());
  }
  public void putUnusedPortion(ByteBuffer buffer) {
    if (isExactlyDirect(buffer)) {
      LocalPool pool = localPool.get();
      if (buffer.limit() > 0)
        pool.putUnusedPortion(buffer);
      else
        pool.put(buffer);
    }
  }
  private void updateOverflowMemoryUsage(int size) {
    overflowMemoryUsage.add(size);
  }
  public void setRecycleWhenFreeForCurrentThread(boolean recycleWhenFree) {
    localPool.get().recycleWhenFree(recycleWhenFree);
  }
  public long sizeInBytes() {
    return memoryAllocated.get() + overflowMemoryUsage.longValue();
  }
  public long usedSizeInBytes() {
    return memoryInUse.longValue() + overflowMemoryUsage.longValue();
  }
  public long overflowMemoryInBytes() {
    return overflowMemoryUsage.longValue();
  }
  public long memoryUsageThreshold() { return memoryUsageThreshold; }
  @VisibleForTesting
  public GlobalPool globalPool() {
    return globalPool;
  }
  @VisibleForTesting
  static void releaseLocal() {
    localPool.get().release();
  }
  interface Debug {
    public static Debug NO_OP = new Debug() {
      @Override
      public void registerNormal(Chunk chunk) {}
      @Override
      public void recycleNormal(Chunk oldVersion, Chunk newVersion) {}
      @Override
      public void recyclePartial(Chunk chunk) {}
    };
    void registerNormal(Chunk chunk);
    void recycleNormal(Chunk oldVersion, Chunk newVersion);
    void recyclePartial(Chunk chunk);
  }
  public void debug(Debug setDebug) {
    assert setDebug != null;
    this.debug = setDebug;
  }
  interface Recycler {
    void recycle(Chunk chunk);
    boolean canRecyclePartially();
    void recyclePartially(Chunk chunk);
  }
  final class GlobalPool implements Supplier<Chunk>, Recycler {
    static final int MACRO_CHUNK_SIZE = 64 * NORMAL_CHUNK_SIZE;
    private final String READABLE_MACRO_CHUNK_SIZE =
        prettyPrintMemory(MACRO_CHUNK_SIZE);
    private final Queue<Chunk> macroChunks = new ConcurrentLinkedQueue<>();
    private final Queue<Chunk> chunks = new ConcurrentLinkedQueue<>();
    private final Queue<Chunk> partiallyFreedChunks =
        new ConcurrentLinkedQueue<>();
    private final Object readableMemoryUsage = new Object() {
      @Override
      public String toString() {
        return prettyPrintMemory(sizeInBytes());
      }
    };
    public GlobalPool() {
      assert Integer.bitCount(NORMAL_CHUNK_SIZE) == 1;
      assert Integer.bitCount(MACRO_CHUNK_SIZE) == 1;
      assert MACRO_CHUNK_SIZE % NORMAL_CHUNK_SIZE == 0;
    }
    public Chunk get() {
      Chunk chunk = chunks.poll();
      if (chunk != null)
        return chunk;
      chunk = allocateMoreChunks();
      if (chunk != null)
        return chunk;
      chunk = chunks.poll();
      return chunk == null ? partiallyFreedChunks.poll() : chunk;
    }
    private Chunk allocateMoreChunks() {
      while (true) {
        long cur = memoryAllocated.get();
        if (cur + MACRO_CHUNK_SIZE > memoryUsageThreshold) {
          if (memoryUsageThreshold > 0) {
            noSpamLogger.info("Maximum memory usage reached ({}), cannot " +
                              "allocate chunk of {}",
                              readableMemoryUsageThreshold,
                              READABLE_MACRO_CHUNK_SIZE);
          }
          return null;
        }
        if (memoryAllocated.compareAndSet(cur, cur + MACRO_CHUNK_SIZE))
          break;
      }
      Chunk chunk;
      try {
        chunk = new Chunk(null, allocateDirectAligned(MACRO_CHUNK_SIZE));
      } catch (OutOfMemoryError oom) {
        noSpamLogger.error(
            "{} buffer pool failed to allocate chunk of {}, current size {} " +
            "({}). "
                + "Attempting to continue; buffers will be allocated in " +
                  "on-heap memory which can degrade performance. "
                + "Make sure direct memory size (-XX:MaxDirectMemorySize) is " +
                  "large enough to accommodate off-heap memtables and caches.",
            name, READABLE_MACRO_CHUNK_SIZE, readableMemoryUsage,
            oom.getClass().getName());
        return null;
      }
      chunk.acquire(null);
      macroChunks.add(chunk);
      final Chunk callerChunk = new Chunk(this, chunk.get(NORMAL_CHUNK_SIZE));
      debug.registerNormal(callerChunk);
      for (int i = NORMAL_CHUNK_SIZE; i < MACRO_CHUNK_SIZE;
           i += NORMAL_CHUNK_SIZE) {
        Chunk add = new Chunk(this, chunk.get(NORMAL_CHUNK_SIZE));
        chunks.add(add);
        debug.registerNormal(add);
      }
      return callerChunk;
    }
    @Override
    public void recycle(Chunk chunk) {
      Chunk recycleAs = new Chunk(chunk);
      debug.recycleNormal(chunk, recycleAs);
      chunks.add(recycleAs);
    }
    @Override
    public void recyclePartially(Chunk chunk) {
      debug.recyclePartial(chunk);
      partiallyFreedChunks.add(chunk);
    }
    @Override
    public boolean canRecyclePartially() {
      return recyclePartially;
    }
    @VisibleForTesting
    void unsafeFree() {
      while (!chunks.isEmpty())
        chunks.poll().unsafeFree();
      while (!partiallyFreedChunks.isEmpty())
        partiallyFreedChunks.poll().unsafeFree();
      while (!macroChunks.isEmpty())
        macroChunks.poll().unsafeFree();
    }
    @VisibleForTesting
    boolean isPartiallyFreed(Chunk chunk) {
      return partiallyFreedChunks.contains(chunk);
    }
    @VisibleForTesting
    boolean isFullyFreed(Chunk chunk) {
      return chunks.contains(chunk);
    }
  }
  private static class MicroQueueOfChunks {
    private Chunk chunk0, chunk1, chunk2;
    private int count;
    private Chunk add(Chunk chunk) {
      switch (count) {
      case 0:
        chunk0 = chunk;
        count = 1;
        break;
      case 1:
        chunk1 = chunk;
        count = 2;
        break;
      case 2:
        chunk2 = chunk;
        count = 3;
        break;
      case 3: {
        Chunk release;
        int chunk0Free = chunk0.freeSlotCount();
        int chunk1Free = chunk1.freeSlotCount();
        int chunk2Free = chunk2.freeSlotCount();
        if (chunk0Free < chunk1Free) {
          if (chunk0Free < chunk2Free) {
            release = chunk0;
            chunk0 = chunk;
          } else {
            release = chunk2;
            chunk2 = chunk;
          }
        } else {
          if (chunk1Free < chunk2Free) {
            release = chunk1;
            chunk1 = chunk;
          } else {
            release = chunk2;
            chunk2 = chunk;
          }
        }
        return release;
      }
      default:
        throw new IllegalStateException();
      }
      return null;
    }
    private void remove(Chunk chunk) {
      if (chunk0 == chunk) {
        chunk0 = chunk1;
        chunk1 = chunk2;
      } else if (chunk1 == chunk) {
        chunk1 = chunk2;
      } else if (chunk2 != chunk) {
        return;
      }
      chunk2 = null;
      --count;
    }
    ByteBuffer get(int size, boolean sizeIsLowerBound, ByteBuffer reuse) {
      ByteBuffer buffer;
      if (null != chunk0) {
        if (null != (buffer = chunk0.get(size, sizeIsLowerBound, reuse)))
          return buffer;
        if (null != chunk1) {
          if (null != (buffer = chunk1.get(size, sizeIsLowerBound, reuse)))
            return buffer;
          if (null != chunk2 &&
              null != (buffer = chunk2.get(size, sizeIsLowerBound, reuse)))
            return buffer;
        }
      }
      return null;
    }
    private void forEach(Consumer<Chunk> consumer) {
      forEach(consumer, count, chunk0, chunk1, chunk2);
    }
    private void clearForEach(Consumer<Chunk> consumer) {
      Chunk chunk0 = this.chunk0, chunk1 = this.chunk1, chunk2 = this.chunk2;
      this.chunk0 = this.chunk1 = this.chunk2 = null;
      forEach(consumer, count, chunk0, chunk1, chunk2);
      count = 0;
    }
    private static void forEach(Consumer<Chunk> consumer, int count,
                                Chunk chunk0, Chunk chunk1, Chunk chunk2) {
      switch (count) {
      case 3:
        consumer.accept(chunk2);
      case 2:
        consumer.accept(chunk1);
      case 1:
        consumer.accept(chunk0);
      }
    }
    private <T> void removeIf(BiPredicate<Chunk, T> predicate, T value) {
      Chunk toRelease0 = null, toRelease1 = null, toRelease2 = null;
      try {
        switch (count) {
        case 3:
          if (predicate.test(chunk2, value)) {
            --count;
            toRelease2 = chunk2;
            chunk2 = null;
          }
        case 2:
          if (predicate.test(chunk1, value)) {
            --count;
            toRelease1 = chunk1;
            chunk1 = null;
          }
        case 1:
          if (predicate.test(chunk0, value)) {
            --count;
            toRelease0 = chunk0;
            chunk0 = null;
          }
          break;
        case 0:
          return;
        }
        switch (count) {
        case 2:
          if (chunk0 == null) {
            chunk0 = chunk1;
            chunk1 = chunk2;
            chunk2 = null;
          } else if (chunk1 == null) {
            chunk1 = chunk2;
            chunk2 = null;
          }
          break;
        case 1:
          if (chunk1 != null) {
            chunk0 = chunk1;
            chunk1 = null;
          } else if (chunk2 != null) {
            chunk0 = chunk2;
            chunk2 = null;
          }
          break;
        }
      } finally {
        if (toRelease0 != null)
          toRelease0.release();
        if (toRelease1 != null)
          toRelease1.release();
        if (toRelease2 != null)
          toRelease2.release();
      }
    }
    private void release() { clearForEach(Chunk::release); }
    private void unsafeRecycle() { clearForEach(Chunk::unsafeRecycle); }
  }
  public final class LocalPool implements Recycler {
    private final Queue<ByteBuffer> reuseObjects;
    private final Supplier<Chunk> parent;
    private final LocalPoolRef leakRef;
    private final MicroQueueOfChunks chunks = new MicroQueueOfChunks();
    private LocalPool tinyPool;
    private final int tinyLimit;
    private boolean recycleWhenFree = true;
    public LocalPool() {
      this.parent = globalPool;
      this.tinyLimit = TINY_ALLOCATION_LIMIT;
      this.reuseObjects = new ArrayDeque<>();
      localPoolReferences.add(leakRef =
                                  new LocalPoolRef(this, localPoolRefQueue));
    }
    private LocalPool(LocalPool parent) {
      this.parent = () -> {
        ByteBuffer buffer = parent.tryGetInternal(TINY_CHUNK_SIZE, false);
        return buffer == null ? null : new Chunk(parent, buffer);
      };
      this.tinyLimit = 0;
      this.reuseObjects = parent.reuseObjects;
      localPoolReferences.add(leakRef =
                                  new LocalPoolRef(this, localPoolRefQueue));
    }
    private LocalPool tinyPool() {
      if (tinyPool == null)
        tinyPool = new LocalPool(this).recycleWhenFree(recycleWhenFree);
      return tinyPool;
    }
    public void put(ByteBuffer buffer) {
      Chunk chunk = Chunk.getParentChunk(buffer);
      int size = buffer.capacity();
      if (chunk == null) {
        FileUtils.clean(buffer);
        updateOverflowMemoryUsage(-size);
      } else {
        put(buffer, chunk);
        memoryInUse.add(-size);
      }
    }
    private void put(ByteBuffer buffer, Chunk chunk) {
      LocalPool owner = chunk.owner;
      if (owner != null && owner == tinyPool) {
        tinyPool.put(buffer, chunk);
        return;
      }
      long free = chunk.free(buffer, owner == this && recycleWhenFree);
      if (free == 0L) {
        assert owner == this;
        remove(chunk);
        chunk.recycle();
      } else if (free == -1L && owner != this && chunk.owner == null &&
                 !chunk.recycler.canRecyclePartially()) {
        chunk.tryRecycle();
      } else if (chunk.owner == null && chunk.recycler.canRecyclePartially() &&
                 chunk.setInUse(Chunk.Status.EVICTED)) {
        chunk.partiallyRecycle();
      }
      if (owner == this) {
        MemoryUtil.setAttachment(buffer, null);
        MemoryUtil.setDirectByteBuffer(buffer, 0, 0);
        reuseObjects.add(buffer);
      }
    }
    public void putUnusedPortion(ByteBuffer buffer) {
      Chunk chunk = Chunk.getParentChunk(buffer);
      int size = buffer.capacity() - buffer.limit();
      if (chunk == null) {
        updateOverflowMemoryUsage(-size);
        return;
      }
      chunk.freeUnusedPortion(buffer);
      memoryInUse.add(-size);
    }
    public ByteBuffer get(int size) { return get(size, false); }
    public ByteBuffer getAtLeast(int size) { return get(size, true); }
    private ByteBuffer get(int size, boolean sizeIsLowerBound) {
      ByteBuffer ret = tryGet(size, sizeIsLowerBound);
      if (ret != null) {
        metrics.hits.mark();
        memoryInUse.add(ret.capacity());
        return ret;
      }
      if (size > NORMAL_CHUNK_SIZE) {
        if (logger.isTraceEnabled())
          logger.trace(
              "Requested buffer size {} is bigger than {}; allocating directly",
              prettyPrintMemory(size), prettyPrintMemory(NORMAL_CHUNK_SIZE));
      } else {
        if (logger.isTraceEnabled())
          logger.trace("Requested buffer size {} has been allocated directly " +
                       "due to lack of capacity",
                       prettyPrintMemory(size));
      }
      metrics.misses.mark();
      return allocate(size, BufferType.OFF_HEAP);
    }
    private ByteBuffer tryGet(int size, boolean sizeIsLowerBound) {
      LocalPool pool = this;
      if (size <= tinyLimit) {
        if (size <= 0) {
          if (size == 0)
            return EMPTY_BUFFER;
          throw new IllegalArgumentException("Size must be non-negative (" +
                                             size + ')');
        }
        pool = tinyPool();
      } else if (size > NORMAL_CHUNK_SIZE) {
        return null;
      }
      return pool.tryGetInternal(size, sizeIsLowerBound);
    }
    @Inline
    private ByteBuffer tryGetInternal(int size, boolean sizeIsLowerBound) {
      ByteBuffer reuse = this.reuseObjects.poll();
      ByteBuffer buffer = chunks.get(size, sizeIsLowerBound, reuse);
      if (buffer != null) {
        return buffer;
      }
      Chunk chunk = addChunkFromParent();
      if (chunk != null) {
        ByteBuffer result = chunk.get(size, sizeIsLowerBound, reuse);
        if (result != null)
          return result;
      }
      if (reuse != null)
        this.reuseObjects.add(reuse);
      return null;
    }
    @Override
    public void recycle(Chunk chunk) {
      ByteBuffer buffer = chunk.slab;
      Chunk parentChunk = Chunk.getParentChunk(buffer);
      put(buffer, parentChunk);
    }
    @Override
    public void recyclePartially(Chunk chunk) {
      throw new UnsupportedOperationException(
          "Tiny chunk doesn't support partial recycle.");
    }
    @Override
    public boolean canRecyclePartially() {
      return false;
    }
    private void remove(Chunk chunk) {
      chunks.remove(chunk);
      if (tinyPool != null)
        tinyPool.chunks.removeIf((child, parent)
                                     -> Chunk.getParentChunk(child.slab) ==
                                            parent,
                                 chunk);
    }
    private Chunk addChunkFromParent() {
      Chunk chunk = parent.get();
      if (chunk == null)
        return null;
      addChunk(chunk);
      return chunk;
    }
    private void addChunk(Chunk chunk) {
      chunk.acquire(this);
      Chunk evict = chunks.add(chunk);
      if (evict != null) {
        if (tinyPool != null)
          tinyPool.chunks.removeIf((child, parent)
                                       -> Chunk.getParentChunk(child.slab) ==
                                              parent,
                                   evict);
        evict.release();
        evict.setEvicted(Chunk.Status.IN_USE);
      }
    }
    public void release() {
      chunks.release();
      reuseObjects.clear();
      localPoolReferences.remove(leakRef);
      leakRef.clear();
      if (tinyPool != null)
        tinyPool.release();
    }
    @VisibleForTesting
    void unsafeRecycle() {
      chunks.unsafeRecycle();
    }
    @VisibleForTesting
    public boolean isTinyPool() {
      return !(parent instanceof GlobalPool);
    }
    public LocalPool recycleWhenFree(boolean recycleWhenFree) {
      this.recycleWhenFree = recycleWhenFree;
      if (tinyPool != null)
        tinyPool.recycleWhenFree = recycleWhenFree;
      return this;
    }
    @VisibleForTesting
    void release() {
      chunkCount = 0;
      for (int i = 0; i < chunks.length; i++) {
        if (chunks[i] != null) {
          chunks[i].release();
          chunks[i] = null;
        }
      }
    }
  }
  private static final class LocalPoolRef extends PhantomReference<LocalPool> {
    private final MicroQueueOfChunks chunks;
    public LocalPoolRef(LocalPool localPool,
                        ReferenceQueue<? super LocalPool> q) {
      super(localPool, q);
      chunks = localPool.chunks;
    }
    public void release() { chunks.release(); }
  }
  private void cleanupOneReference() throws InterruptedException {
    Object obj = localPoolRefQueue.remove(100);
    if (obj instanceof LocalPoolRef) {
      ((LocalPoolRef)obj).release();
      localPoolReferences.remove(obj);
    }
  }
  private static ByteBuffer allocateDirectAligned(int capacity) {
    int align = MemoryUtil.pageSize();
    if (Integer.bitCount(align) != 1)
      throw new IllegalArgumentException("Alignment must be a power of 2");
    ByteBuffer buffer = ByteBuffer.allocateDirect(capacity + align);
    long address = MemoryUtil.getAddress(buffer);
    long offset = address & (align - 1);
    if (offset == 0) {
      buffer.limit(capacity);
    } else {
      int pos = (int)(align - offset);
      buffer.position(pos);
      buffer.limit(pos + capacity);
    }
    return buffer.slice();
  }
  final static class Chunk {
    enum Status {
      IN_USE,
      EVICTED;
    }
    private final ByteBuffer slab;
    final long baseAddress;
    private final int shift;
    private volatile long freeSlots;
    private static final AtomicLongFieldUpdater<Chunk> freeSlotsUpdater =
        AtomicLongFieldUpdater.newUpdater(Chunk.class, "freeSlots");
    private volatile LocalPool owner;
    private volatile long lastAcquired;
    private final Recycler recycler;
    private static final AtomicReferenceFieldUpdater<Chunk, Status>
        statusUpdater = AtomicReferenceFieldUpdater.newUpdater(
            Chunk.class, Status.class, "status");
    private volatile Status status = Status.IN_USE;
    @VisibleForTesting Object debugAttachment;
    Chunk(Chunk recycle) {
      assert recycle.freeSlots == 0L;
      this.slab = recycle.slab;
      this.baseAddress = recycle.baseAddress;
      this.shift = recycle.shift;
      this.freeSlots = -1L;
      this.recycler = recycle.recycler;
    }
    Chunk(Recycler recycler, ByteBuffer slab) {
      assert MemoryUtil.isExactlyDirect(slab);
      this.recycler = recycler;
      this.slab = slab;
      this.baseAddress = MemoryUtil.getAddress(slab);
      this.shift = 31 & (Integer.numberOfTrailingZeros(slab.capacity() / 64));
      this.freeSlots = slab.capacity() == 0 ? 0L : -1L;
    }
    void acquire(LocalPool owner) {
      assert this.owner == null;
      this.owner = owner;
    }
    void release() {
      this.owner = null;
      tryRecycle();
    }
    void tryRecycle() {
      assert owner == null;
      if (isFree() && freeSlotsUpdater.compareAndSet(this, -1L, 0L))
        recycle();
    }
    void recycle() {
      assert freeSlots == 0L;
      recycler.recycle(this);
    }
    public void partiallyRecycle() {
      assert owner == null;
      recycler.recyclePartially(this);
    }
    static Chunk getParentChunk(ByteBuffer buffer) {
      Object attachment = MemoryUtil.getAttachment(buffer);
      if (attachment instanceof Chunk)
        return (Chunk)attachment;
      if (attachment instanceof Ref)
        return ((Ref<Chunk>)attachment).get();
      return null;
    }
    void setAttachment(ByteBuffer buffer) {
      if (Ref.DEBUG_ENABLED)
        MemoryUtil.setAttachment(buffer, new Ref<>(this, null));
      else
        MemoryUtil.setAttachment(buffer, this);
    }
    boolean releaseAttachment(ByteBuffer buffer) {
      Object attachment = MemoryUtil.getAttachment(buffer);
      if (attachment == null)
        return false;
      if (Ref.DEBUG_ENABLED)
        ((Ref<Chunk>)attachment).release();
      return true;
    }
    @VisibleForTesting
    void unsafeFree() {
      Chunk parent = getParentChunk(slab);
      if (parent != null)
        parent.free(slab, false);
      else
        FileUtils.clean(slab);
    }
    @VisibleForTesting
    long setFreeSlots(long val) {
      long ret = freeSlots;
      freeSlots = val;
      return ret;
    }
    int capacity() { return 64 << shift; }
    final int unit() { return 1 << shift; }
    final boolean isFree() { return freeSlots == -1L; }
    int free() { return Long.bitCount(freeSlots) * unit(); }
    int freeSlotCount() { return Long.bitCount(freeSlots); }
    ByteBuffer get(int size) { return get(size, false, null); }
    ByteBuffer get(int size, boolean sizeIsLowerBound, ByteBuffer into) {
      int slotCount = (size - 1 + unit()) >>> shift;
      if (sizeIsLowerBound)
        size = slotCount << shift;
      if (slotCount > 64)
        return null;
      long slotBits = -1L >>> (64 - slotCount);
      long searchMask = 0x1111111111111111L;
      searchMask *= 15L >>> ((slotCount - 1) & 3);
      searchMask &= -1L >>> (slotCount - 1);
      while (true) {
        long cur = freeSlots;
        int index = Long.numberOfTrailingZeros(cur & searchMask);
        if (index == 64)
          return null;
        searchMask ^= 1L << index;
        long candidate = slotBits << index;
        if ((candidate & cur) == candidate) {
          while (true) {
            if (freeSlotsUpdater.compareAndSet(this, cur, cur & ~candidate))
              break;
            cur = freeSlots;
            assert ((candidate & cur) == candidate);
          }
          return set(index << shift, size, into);
        }
      }
    }
    private ByteBuffer set(int offset, int size, ByteBuffer into) {
      if (into == null)
        into = MemoryUtil.getHollowDirectByteBuffer(ByteOrder.BIG_ENDIAN);
      MemoryUtil.sliceDirectByteBuffer(slab, into, offset, size);
      setAttachment(into);
      return into;
    }
    int roundUp(int v) { return BufferPool.roundUp(v, unit()); }
    long free(ByteBuffer buffer, boolean tryRelease) {
      if (!releaseAttachment(buffer))
        return 1L;
      int size = roundUp(buffer.capacity());
      long address = MemoryUtil.getAddress(buffer);
      assert (address >= baseAddress) &
          (address + size <= baseAddress + capacity());
      int position = ((int)(address - baseAddress)) >> shift;
      int slotCount = size >> shift;
      long slotBits = 0xffffffffffffffffL >>> (64 - slotCount);
      long shiftedSlotBits = (slotBits << position);
      long next;
      while (true) {
        long cur = freeSlots;
        next = cur | shiftedSlotBits;
        assert next == (cur ^ shiftedSlotBits);
        if (tryRelease && (next == -1L))
          next = 0L;
        if (freeSlotsUpdater.compareAndSet(this, cur, next))
          return next;
      }
    }
    void freeUnusedPortion(ByteBuffer buffer) {
      int size = roundUp(buffer.limit());
      int capacity = roundUp(buffer.capacity());
      if (size == capacity)
        return;
      long address = MemoryUtil.getAddress(buffer);
      assert (address >= baseAddress) &
          (address + size <= baseAddress + capacity());
      int position = ((int)(address + size - baseAddress)) >> shift;
      int slotCount = (capacity - size) >> shift;
      long slotBits = 0xffffffffffffffffL >>> (64 - slotCount);
      long shiftedSlotBits = (slotBits << position);
      long next;
      while (true) {
        long cur = freeSlots;
        next = cur | shiftedSlotBits;
        assert next == (cur ^ shiftedSlotBits);
        if (freeSlotsUpdater.compareAndSet(this, cur, next))
          break;
      }
      MemoryUtil.setByteBufferCapacity(buffer, size);
    }
    @Override
    public String toString() {
      return String.format("[slab %s, slots bitmap %s, capacity %d, free %d]",
                           slab, Long.toBinaryString(freeSlots), capacity(),
                           free());
    }
    @VisibleForTesting
    public LocalPool owner() {
      return this.owner;
    }
    static void unsafeRecycle(Chunk chunk) {
      if (chunk != null) {
        chunk.owner = null;
        chunk.freeSlots = 0L;
        chunk.recycle();
      }
    }
    Status status() { return status; }
    private boolean setStatus(Status current, Status update) {
      return statusUpdater.compareAndSet(this, current, update);
    }
    boolean setInUse(Status prev) { return setStatus(prev, Status.IN_USE); }
    boolean setEvicted(Status prev) { return setStatus(prev, Status.EVICTED); }
  }
  @VisibleForTesting
  public static int roundUp(int size) {
    if (size <= TINY_ALLOCATION_LIMIT)
      return roundUp(size, TINY_ALLOCATION_UNIT);
    return roundUp(size, NORMAL_ALLOCATION_UNIT);
  }
  @VisibleForTesting
  public static int roundUp(int size, int unit) {
    int mask = unit - 1;
    return (size + mask) & ~mask;
  }
  @VisibleForTesting
  public void shutdownLocalCleaner(long timeout, TimeUnit unit)
      throws InterruptedException, TimeoutException {
    shutdownNow(of(localPoolCleaner));
    awaitTermination(timeout, unit, of(localPoolCleaner));
  }
  @VisibleForTesting
  public BufferPoolMetrics metrics() {
    return metrics;
  }
  @VisibleForTesting
  public void unsafeReset() {
    overflowMemoryUsage.reset();
    memoryInUse.reset();
    memoryAllocated.set(0);
    localPool.get().unsafeRecycle();
    globalPool.unsafeFree();
  }
  @VisibleForTesting
  Chunk unsafeCurrentChunk() {
    return localPool.get().chunks.chunk0;
  }
  @VisibleForTesting
  int unsafeNumChunks() {
    LocalPool pool = localPool.get();
    return (pool.chunks.chunk0 != null ? 1 : 0) +
        (pool.chunks.chunk1 != null ? 1 : 0) +
        (pool.chunks.chunk2 != null ? 1 : 0);
  }
}