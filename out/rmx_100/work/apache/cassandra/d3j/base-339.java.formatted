// generated by Diff/AST Java Unparser
package org.apache.cassandra.db.commitlog;
import org.apache.cassandra.concurrent.NamedThreadFactory;
import org.apache.cassandra.config.Config;
import org.apache.cassandra.db.commitlog.CommitLogSegment.Allocation;
import org.apache.cassandra.utils.Clock;
import org.apache.cassandra.utils.NoSpamLogger;
import org.apache.cassandra.utils.concurrent.WaitQueue;
import org.slf4j.*;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
public abstract class AbstractCommitLogService
{
    static final long DEFAULT_MARKER_INTERVAL_MILLIS = 100;
    private volatile Thread thread;
    private volatile boolean shutdown = false;
    protected volatile long lastSyncedAt = System.currentTimeMillis();
    private final AtomicLong written = new AtomicLong(0);
    protected final AtomicLong pending = new AtomicLong(0);
    protected final WaitQueue syncComplete = new WaitQueue();
    protected final Semaphore haveWork = new Semaphore(1);
    final CommitLog commitLog;
    private final String name;
    final long syncIntervalMillis;
    final long markerIntervalMillis;
    private volatile boolean syncRequested;
    private static final Logger logger = LoggerFactory.getLogger(AbstractCommitLogService.class);
    AbstractCommitLogService(final CommitLog commitLog, final String name, long syncIntervalMillis)
    {
        this(commitLog, name, syncIntervalMillis, false);
    }
    AbstractCommitLogService(final CommitLog commitLog, final String name, long syncIntervalMillis,
                             boolean markHeadersFaster)
    {
        this.commitLog = commitLog;
        this.name = name;
        if (markHeadersFaster && syncIntervalMillis > DEFAULT_MARKER_INTERVAL_MILLIS)
        {
            markerIntervalMillis = DEFAULT_MARKER_INTERVAL_MILLIS;
            long modulo = syncIntervalMillis % markerIntervalMillis;
            if (modulo != 0)
            {
                syncIntervalMillis -= modulo;
                if (modulo >= markerIntervalMillis / 2)
                    syncIntervalMillis += markerIntervalMillis;
            }
            logger.debug("Will update the commitlog markers every {}ms and flush every {}ms", markerIntervalMillis,
                         syncIntervalMillis);
        }
        else
        {
            markerIntervalMillis = syncIntervalMillis;
        }
        assert syncIntervalMillis % markerIntervalMillis == 0;
        this.syncIntervalMillis = syncIntervalMillis;
    }
    void start()
    {
        if (syncIntervalMillis < 1)
            throw new IllegalArgumentException(
                String.format("Commit log flush interval must be positive: %dms", syncIntervalMillis));
        shutdown = false;
        Runnable runnable = new SyncRunnable(new Clock());
        thread = new Thread(NamedThreadFactory.threadLocalDeallocator(runnable), name);
        thread.start();
    }
    class SyncRunnable implements Runnable
    {
        final Clock clock;
        long firstLagAt = 0;
        long totalSyncDuration = 0;
        long syncExceededIntervalBy = 0;
        int lagCount = 0;
        int syncCount = 0;
        SyncRunnable(Clock clock)
        {
            this.clock = clock;
        }
        public void run()
        {
            while (true)
            {
                if (!sync())
                    break;
            }
        }
        boolean sync()
        {
            try
            {
                boolean run = !shutdown;
                long pollStarted = clock.currentTimeMillis();
                if (lastSyncedAt + syncIntervalMillis <= pollStarted || shutdown || syncRequested)
                {
                    syncRequested = false;
                    commitLog.sync(shutdown, true);
                    lastSyncedAt = pollStarted;
                    syncComplete.signalAll();
                }
                else
                {
                    commitLog.sync(false, false);
                }
                long now = clock.currentTimeMillis();
                long sleep = pollStarted + markerIntervalMillis - now;
                if (sleep < 0)
                {
                    if (firstLagAt == 0)
                    {
                        firstLagAt = now;
                        totalSyncDuration = syncExceededIntervalBy = syncCount = lagCount = 0;
                    }
                    syncExceededIntervalBy -= sleep;
                    lagCount++;
                }
                syncCount++;
                totalSyncDuration += now - pollStarted;
                if (firstLagAt > 0)
                {
                    boolean logged =
                        NoSpamLogger.log(logger, NoSpamLogger.Level.WARN, 5, TimeUnit.MINUTES,
                                         "Out of {} commit log syncs over the past {}s with average "
                                             + "duration of {}ms, {} have exceeded the configured commit "
                                             + "interval by an average of {}ms",
                                         syncCount, (now - firstLagAt) / 1000,
                                         String.format("%.2f", (double)totalSyncDuration / syncCount), lagCount,
                                         String.format("%.2f", (double)syncExceededIntervalBy / lagCount));
                    if (logged)
                        firstLagAt = 0;
                }
                if (!run)
                    return false;
                if (sleep < 0)
                    return true;
                try
                {
                    haveWork.tryAcquire(sleep, TimeUnit.MILLISECONDS);
                    haveWork.drainPermits();
                }
                catch (InterruptedException e)
                {
                    throw new AssertionError();
                }
            }
            catch (Throwable t)
            {
                if (!CommitLog.handleCommitError("Failed to persist commits to disk", t))
                    return false;
                try
                {
                    haveWork.tryAcquire(markerIntervalMillis, TimeUnit.MILLISECONDS);
                }
                catch (InterruptedException e)
                {
                    throw new AssertionError();
                }
            }
            return true;
        }
    }
    public void finishWriteFor(Allocation alloc)
    {
        maybeWaitForSync(alloc);
        written.incrementAndGet();
    }
    protected abstract void maybeWaitForSync(Allocation alloc);
    public WaitQueue.Signal requestExtraSync()
    {
        WaitQueue.Signal signal = syncComplete.register();
        requestSync();
        return signal;
    }
    protected void requestSync()
    {
        syncRequested = true;
        haveWork.release(1);
    }
    public void shutdown()
    {
        shutdown = true;
        haveWork.release(1);
    }
    public void restartUnsafe()
    {
        while (haveWork.availablePermits() < 1)
            haveWork.release();
        while (haveWork.availablePermits() > 1)
        {
            try
            {
                haveWork.acquire();
            }
            catch (InterruptedException e)
            {
                throw new RuntimeException(e);
            }
        }
        shutdown = false;
        start();
    }
    public void awaitTermination() throws InterruptedException
    {
        thread.join();
    }
    public long getCompletedTasks()
    {
        return written.get();
    }
    public long getPendingTasks()
    {
        return pending.get();
    }
}