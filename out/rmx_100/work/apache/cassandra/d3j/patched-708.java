// generated by Diff/AST Java Unparser
package org.apache.cassandra.cql3.statements;
import java.util.Collections;
import java.util.Map;
import com.google.common.collect.ImmutableMap;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.apache.cassandra.auth.Permission;
import org.apache.cassandra.config.CFMetaData;
import org.apache.cassandra.config.ColumnDefinition;
import org.apache.cassandra.config.IndexType;
import org.apache.cassandra.config.Schema;
import org.apache.cassandra.db.index.SecondaryIndex;
import org.apache.cassandra.db.marshal.MapType;
import org.apache.cassandra.exceptions.*;
import org.apache.cassandra.cql3.*;
import org.apache.cassandra.service.ClientState;
import org.apache.cassandra.service.MigrationManager;
import org.apache.cassandra.thrift.ThriftValidation;
import org.apache.cassandra.transport.Event;
public class CreateIndexStatement extends SchemaAlteringStatement {
  private static final Logger logger =
      LoggerFactory.getLogger(CreateIndexStatement.class);
  private final String indexName;
<<<<<<< /root/work/apache/cassandra/d3j/patched-708-0.java
  private final IndexTarget target;
||||||| /root/work/apache/cassandra/d3j/base-708.java
  private final ColumnIdentifier columnName;
=======
  private final ColumnIdentifier.Raw rawColumnName;
>>>>>>> /root/work/apache/cassandra/d3j/patched-708-1.java
  private final IndexPropDefs properties;
  private final boolean ifNotExists;
<<<<<<< /root/work/apache/cassandra/d3j/patched-708-0.java
  public CreateIndexStatement(CFName name, String indexName, IndexTarget target,
||||||| /root/work/apache/cassandra/d3j/base-708.java
  public CreateIndexStatement(CFName name, String indexName,
                              ColumnIdentifier columnName,
=======
  public CreateIndexStatement(CFName name, String indexName,
                              ColumnIdentifier.Raw rawColumnName,
>>>>>>> /root/work/apache/cassandra/d3j/patched-708-1.java
                              IndexPropDefs properties, boolean ifNotExists) {
    super(name);
    this.indexName = indexName;
<<<<<<< /root/work/apache/cassandra/d3j/patched-708-0.java
    this.target = target;
||||||| /root/work/apache/cassandra/d3j/base-708.java
    this.columnName = columnName;
=======
    this.rawColumnName = rawColumnName;
>>>>>>> /root/work/apache/cassandra/d3j/patched-708-1.java
    this.properties = properties;
    this.ifNotExists = ifNotExists;
  }
  public void checkAccess(ClientState state)
      throws UnauthorizedException, InvalidRequestException {
    state.hasColumnFamilyAccess(keyspace(), columnFamily(), Permission.ALTER);
  }
  public void validate(ClientState state) throws RequestValidationException {
    CFMetaData cfm =
        ThriftValidation.validateColumnFamily(keyspace(), columnFamily());
    if (cfm.isCounter())
      throw new InvalidRequestException(
          "Secondary indexes are not supported on counter tables");
<<<<<<< /root/work/apache/cassandra/d3j/patched-708-0.java
    ColumnIdentifier columnName = rawColumnName.prepare(cfm);
    ColumnDefinition cd = cfm.getColumnDefinition(target.column);
||||||| /root/work/apache/cassandra/d3j/base-708.java
    ColumnDefinition cd = cfm.getColumnDefinition(columnName.key);
=======
    ColumnIdentifier columnName = rawColumnName.prepare(cfm);
    ColumnDefinition cd = cfm.getColumnDefinition(columnName.column);
>>>>>>> /root/work/apache/cassandra/d3j/patched-708-1.java
    if (cd == null)
      throw new InvalidRequestException(
<<<<<<< /root/work/apache/cassandra/d3j/patched-708-0.java
          "No column definition found for column " + target.column);
    boolean isMap = cd.type instanceof MapType;
    if (target.isCollectionKeys && !isMap)
      throw new InvalidRequestException(
          "Cannot create index on keys of column " + target +
          " with non map type");
||||||| /root/work/apache/cassandra/d3j/base-708.java
          "No column definition found for column " + columnName);
=======
          "No column definition found for column " + columnName.column);
    boolean isMap = cd.type instanceof MapType;
    if (target.isCollectionKeys && !isMap)
      throw new InvalidRequestException(
          "Cannot create index on keys of column " + target +
          " with non map type");
>>>>>>> /root/work/apache/cassandra/d3j/patched-708-1.java
    if (cd.getIndexType() != null) {
      boolean previousIsKeys =
          cd.hasIndexOption(SecondaryIndex.INDEX_KEYS_OPTION_NAME);
      if (isMap && target.isCollectionKeys != previousIsKeys) {
        String msg = "Cannot create index on %s %s, an index on %s %s " +
                     "already exists and indexing "
                     + "a map on both keys and values at the same time is " +
                       "not currently supported";
        throw new InvalidRequestException(String.format(
            msg, target.column, target.isCollectionKeys ? "keys" : "values",
            target.column, previousIsKeys ? "keys" : "values"));
      }
      if (ifNotExists)
        return;
      else
        throw new InvalidRequestException("Index already exists");
    }
    properties.validate();
    if (cfm.comparator.isDense() && cd.kind != ColumnDefinition.Kind.REGULAR)
      throw new InvalidRequestException(
          String.format("Secondary index on %s column %s is not yet " +
                        "supported for compact table",
<<<<<<< /root/work/apache/cassandra/d3j/patched-708-0.java
                        cd.kind, target.column));
    if (cd.isStatic())
||||||| /root/work/apache/cassandra/d3j/base-708.java
                        cd.type, columnName));
    if (cd.type == ColumnDefinition.Type.STATIC)
=======
                        cd.kind, columnName.column));
    if (cd.isStatic())
>>>>>>> /root/work/apache/cassandra/d3j/patched-708-1.java
      throw new InvalidRequestException(
          "Secondary indexes are not allowed on static columns");
    if (cd.kind == ColumnDefinition.Kind.PARTITION_KEY &&
        cd.isOnAllComponents())
      throw new InvalidRequestException(String.format(
          "Cannot add secondary index to already primarily indexed column %s",
<<<<<<< /root/work/apache/cassandra/d3j/patched-708-0.java
          target.column));
||||||| /root/work/apache/cassandra/d3j/base-708.java
          columnName));
=======
          columnName.column));
>>>>>>> /root/work/apache/cassandra/d3j/patched-708-1.java
  }
<<<<<<< /root/work/apache/cassandra/d3j/patched-708-0.java
  public boolean announceMigration(boolean isLocalOnly)
      throws RequestValidationException {
    logger.debug("Updating column {} definition for index {}", target.column,
||||||| /root/work/apache/cassandra/d3j/base-708.java
  public boolean announceMigration() throws RequestValidationException {
    logger.debug("Updating column {} definition for index {}", columnName,
=======
  public boolean announceMigration(boolean isLocalOnly)
      throws RequestValidationException {
    CFMetaData cfm =
        Schema.instance.getCFMetaData(keyspace(), columnFamily()).copy();
    ColumnIdentifier columnName = rawColumnName.prepare(cfm);
    logger.debug("Updating column {} definition for index {}", columnName,
>>>>>>> /root/work/apache/cassandra/d3j/patched-708-1.java
                 indexName);
<<<<<<< /root/work/apache/cassandra/d3j/patched-708-0.java
    CFMetaData cfm =
        Schema.instance.getCFMetaData(keyspace(), columnFamily()).copy();
    ColumnIdentifier columnName = rawColumnName.prepare(cfm);
    ColumnDefinition cd = cfm.getColumnDefinition(target.column);
||||||| /root/work/apache/cassandra/d3j/base-708.java
    CFMetaData cfm =
        Schema.instance.getCFMetaData(keyspace(), columnFamily()).clone();
    ColumnDefinition cd = cfm.getColumnDefinition(columnName.key);
=======
    ColumnDefinition cd = cfm.getColumnDefinition(columnName.column);
>>>>>>> /root/work/apache/cassandra/d3j/patched-708-1.java
    if (cd.getIndexType() != null && ifNotExists)
      return false;
    if (properties.isCustom) {
      cd.setIndexType(IndexType.CUSTOM, properties.getOptions());
    } else if (cfm.comparator.isCompound()) {
      Map<String, String> options = Collections.emptyMap();
      if (cd.type.isCollection())
        options = ImmutableMap.of(target.isCollectionKeys
                                      ? SecondaryIndex.INDEX_KEYS_OPTION_NAME
                                      : SecondaryIndex.INDEX_VALUES_OPTION_NAME,
                                  "");
      cd.setIndexType(IndexType.COMPOSITES, options);
    } else {
      cd.setIndexType(IndexType.KEYS, Collections.<String, String>emptyMap());
    }
    cd.setIndexName(indexName);
    cfm.addDefaultIndexNames();
    MigrationManager.announceColumnFamilyUpdate(cfm, false, isLocalOnly);
    return true;
  }
  public Event.SchemaChange changeEvent() {
    return new Event.SchemaChange(Event.SchemaChange.Change.UPDATED,
                                  Event.SchemaChange.Target.TABLE, keyspace(),
                                  columnFamily());
  }
}