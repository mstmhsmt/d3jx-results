// generated by Diff/AST Java Unparser
package org.apache.cassandra.cql3.statements;
import java.nio.ByteBuffer;
import java.util.*;
import org.apache.cassandra.cql3.*;
import org.apache.cassandra.config.CFMetaData;
import org.apache.cassandra.db.*;
import org.apache.cassandra.exceptions.*;
import org.apache.cassandra.utils.ByteBufferUtil;
import org.apache.cassandra.utils.Pair;
public class UpdateStatement extends ModificationStatement
{
    private static final Operation setToEmptyOperation =
        new Constants.Setter(null, new Constants.Value(ByteBufferUtil.EMPTY_BYTE_BUFFER));
    private UpdateStatement(StatementType type, CFMetaData cfm, Attributes attrs)
    {
        super(type, cfm, attrs);
    }
    public boolean requireFullClusteringKey()
    {
        return true;
    }
    public void addUpdateForKey(ColumnFamily cf, ByteBuffer key, ColumnNameBuilder builder, UpdateParameters params)
        throws InvalidRequestException
    {
        CFDefinition cfDef = cfm.getCfDef();
        if (cfDef.isComposite && !cfDef.isCompact && !cfm.isSuper())
        {
            ByteBuffer name = builder.copy().add(ByteBufferUtil.EMPTY_BYTE_BUFFER).build();
            cf.addColumn(params.makeColumn(name, ByteBufferUtil.EMPTY_BYTE_BUFFER));
        }
        List<Operation> updates = getOperations();
        if (cfDef.isCompact)
        {
            if (builder.componentCount() == 0)
                throw new InvalidRequestException(
                    String.format("Missing PRIMARY KEY part %s", cfDef.clusteringColumns().iterator().next()));
            if (cfDef.compactValue() == null)
            {
                assert updates.isEmpty();
                setToEmptyOperation.execute(key, cf, builder.copy(), params);
            }
            else
            {
                if (updates.isEmpty())
                    throw new InvalidRequestException(
                        String.format("Column %s is mandatory for this COMPACT STORAGE table", cfDef.compactValue()));
                for (Operation update : updates)
                    update.execute(key, cf, builder.copy(), params);
            }
        }
        else
        {
            for (Operation update : updates)
                update.execute(key, cf, builder.copy(), params);
        }
    }
    public ColumnFamily updateForKey(ByteBuffer key, ColumnNameBuilder builder, UpdateParameters params)
        throws InvalidRequestException
    {
        ColumnFamily cf = UnsortedColumns.factory.create(cfm);
        addUpdateForKey(cf, key, builder, params);
        return cf;
    }
    public static class ParsedInsert extends ModificationStatement.Parsed
    {
        private final List<ColumnIdentifier> columnNames;
        private final List<Term.Raw> columnValues;
        public ParsedInsert(CFName name, Attributes.Raw attrs, List<ColumnIdentifier> columnNames,
                            List<Term.Raw> columnValues, boolean ifNotExists)
        {
            super(name, attrs, null, ifNotExists);
            this.columnNames = columnNames;
            this.columnValues = columnValues;
        }
        protected ModificationStatement prepareInternal(CFDefinition cfDef, VariableSpecifications boundNames,
                                                        Attributes attrs) throws InvalidRequestException
        {
            UpdateStatement stmt = new UpdateStatement(ModificationStatement.StatementType.INSERT, cfDef.cfm, attrs);
            if (stmt.isCounter())
                throw new InvalidRequestException("INSERT statement are not allowed on counter tables, use UPDATE "
                                                  + "instead");
            if (columnNames.size() != columnValues.size())
                throw new InvalidRequestException("Unmatched column names/values");
            if (columnNames.isEmpty())
                throw new InvalidRequestException("No columns provided to INSERT");
            for (int i = 0; i < columnNames.size(); i++)
            {
                CFDefinition.Name name = cfDef.get(columnNames.get(i));
                if (name == null)
                    throw new InvalidRequestException(String.format("Unknown identifier %s", columnNames.get(i)));
                for (int j = 0; j < i; j++)
                    if (name.name.equals(columnNames.get(j)))
                        throw new InvalidRequestException(
                            String.format("Multiple definitions found for column %s", name));
                Term.Raw value = columnValues.get(i);
                switch (name.kind)
                {
                case KEY_ALIAS:
                case COLUMN_ALIAS:
                    Term t = value.prepare(name);
                    t.collectMarkerSpecification(boundNames);
                    stmt.addKeyValue(name, t);
                    break;
                case VALUE_ALIAS:
                case COLUMN_METADATA:
                case STATIC:
                    Operation operation = new Operation.SetValue(value).prepare(name);
                    operation.collectMarkerSpecification(boundNames);
                    stmt.addOperation(operation);
                    break;
                }
            }
            return stmt;
        }
    }
    public static class ParsedUpdate extends ModificationStatement.Parsed
    {
        private final List<Pair<ColumnIdentifier, Operation.RawUpdate>> updates;
        private final List<Relation> whereClause;
        public ParsedUpdate(CFName name, Attributes.Raw attrs,
                            List<Pair<ColumnIdentifier, Operation.RawUpdate>> updates, List<Relation> whereClause,
                            List<Pair<ColumnIdentifier, ColumnCondition.Raw>> conditions)
        {
            super(name, attrs, conditions, false);
            this.updates = updates;
            this.whereClause = whereClause;
        }
        protected ModificationStatement prepareInternal(CFDefinition cfDef, VariableSpecifications boundNames,
                                                        Attributes attrs) throws InvalidRequestException
        {
            UpdateStatement stmt = new UpdateStatement(ModificationStatement.StatementType.UPDATE, cfDef.cfm, attrs);
            for (Pair<ColumnIdentifier, Operation.RawUpdate> entry : updates)
            {
                CFDefinition.Name name = cfDef.get(entry.left);
                if (name == null)
                    throw new InvalidRequestException(String.format("Unknown identifier %s", entry.left));
                Operation operation = entry.right.prepare(name);
                operation.collectMarkerSpecification(boundNames);
                switch (name.kind)
                {
                case KEY_ALIAS:
                case COLUMN_ALIAS:
                    throw new InvalidRequestException(
                        String.format("PRIMARY KEY part %s found in SET part", entry.left));
                case VALUE_ALIAS:
                case COLUMN_METADATA:
                case STATIC:
                    stmt.addOperation(operation);
                    break;
                }
            }
            stmt.processWhereClause(whereClause, boundNames);
            return stmt;
        }
    }
}