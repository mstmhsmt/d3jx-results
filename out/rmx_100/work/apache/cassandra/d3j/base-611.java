// generated by Diff/AST Java Unparser
package org.apache.cassandra.db.compaction;
import java.io.File;
import java.io.IOException;
import java.lang.management.ManagementFactory;
import java.util.*;
import java.util.concurrent.*;
import javax.management.MBeanServer;
import javax.management.ObjectName;
import javax.management.openmbean.OpenDataException;
import javax.management.openmbean.TabularData;
import com.google.common.base.Throwables;
import com.google.common.collect.*;
import com.google.common.util.concurrent.RateLimiter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.apache.cassandra.cache.AutoSavingCache;
import org.apache.cassandra.concurrent.DebuggableThreadPoolExecutor;
import org.apache.cassandra.concurrent.JMXEnabledThreadPoolExecutor;
import org.apache.cassandra.concurrent.NamedThreadFactory;
import org.apache.cassandra.config.CFMetaData;
import org.apache.cassandra.config.DatabaseDescriptor;
import org.apache.cassandra.config.Schema;
import org.apache.cassandra.db.*;
import org.apache.cassandra.db.compaction.CompactionInfo.Holder;
import org.apache.cassandra.db.index.SecondaryIndexBuilder;
import org.apache.cassandra.dht.Bounds;
import org.apache.cassandra.dht.Range;
import org.apache.cassandra.dht.Token;
import org.apache.cassandra.io.sstable.*;
import org.apache.cassandra.io.util.FileUtils;
import org.apache.cassandra.metrics.CompactionMetrics;
import org.apache.cassandra.repair.Validator;
import org.apache.cassandra.service.StorageService;
import org.apache.cassandra.utils.*;
public class CompactionManager implements CompactionManagerMBean {
  public static final String MBEAN_OBJECT_NAME =
      "org.apache.cassandra.db:type=CompactionManager";
  private static final Logger logger =
      LoggerFactory.getLogger(CompactionManager.class);
  public static final CompactionManager instance;
  public static final int NO_GC = Integer.MIN_VALUE;
  public static final int GC_ALL = Integer.MAX_VALUE;
  public static final ThreadLocal<Boolean> isCompactionManager =
      new ThreadLocal<Boolean>() {
        @Override
        protected Boolean initialValue() {
          return false;
        }
      };
  static {
    instance = new CompactionManager();
    MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
    try {
      mbs.registerMBean(instance, new ObjectName(MBEAN_OBJECT_NAME));
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }
  private final CompactionExecutor executor = new CompactionExecutor();
  private final CompactionExecutor validationExecutor =
      new ValidationExecutor();
  private final static CompactionExecutor cacheCleanupExecutor =
      new CacheCleanupExecutor();
  private final CompactionMetrics metrics =
      new CompactionMetrics(executor, validationExecutor);
  private final Multiset<ColumnFamilyStore> compactingCF =
      ConcurrentHashMultiset.create();
  private final RateLimiter compactionRateLimiter =
      RateLimiter.create(Double.MAX_VALUE);
  public RateLimiter getRateLimiter() {
    double currentThroughput =
        DatabaseDescriptor.getCompactionThroughputMbPerSec() * 1024.0 * 1024.0;
    if (currentThroughput == 0 || StorageService.instance.isBootstrapMode())
      currentThroughput = Double.MAX_VALUE;
    if (compactionRateLimiter.getRate() != currentThroughput)
      compactionRateLimiter.setRate(currentThroughput);
    return compactionRateLimiter;
  }
  public List<Future<?>> submitBackground(final ColumnFamilyStore cfs) {
    return submitBackground(cfs, true);
  }
  public List<Future<?>> submitBackground(final ColumnFamilyStore cfs,
                                          boolean autoFill) {
    if (cfs.isAutoCompactionDisabled()) {
      logger.debug("Autocompaction is disabled");
      return Collections.emptyList();
    }
    int count = compactingCF.count(cfs);
    if (count > 0 &&
        executor.getActiveCount() >= executor.getMaximumPoolSize()) {
      logger.debug("Background compaction is still running for {}.{} ({} " +
                   "remaining). Skipping",
                   cfs.keyspace.getName(), cfs.name, count);
      return Collections.emptyList();
    }
    logger.debug("Scheduling a background task check for {}.{} with {}",
                 cfs.keyspace.getName(), cfs.name,
                 cfs.getCompactionStrategy().getClass().getSimpleName());
    List<Future<?>> futures = new ArrayList<Future<?>>();
    do {
      compactingCF.add(cfs);
      futures.add(executor.submit(new BackgroundCompactionTask(cfs)));
    } while (autoFill && executor.getActiveCount() + futures.size() <
                             executor.getMaximumPoolSize());
    return futures;
  }
  public boolean isCompacting(Iterable<ColumnFamilyStore> cfses) {
    for (ColumnFamilyStore cfs : cfses)
      if (!cfs.getDataTracker().getCompacting().isEmpty())
        return true;
    return false;
  }
  class BackgroundCompactionTask implements Runnable {
    private final ColumnFamilyStore cfs;
    BackgroundCompactionTask(ColumnFamilyStore cfs) { this.cfs = cfs; }
    public void run() {
      try {
        logger.debug("Checking {}.{}", cfs.keyspace.getName(), cfs.name);
        if (!cfs.isValid()) {
          logger.debug("Aborting compaction for dropped CF");
          return;
        }
        AbstractCompactionStrategy strategy = cfs.getCompactionStrategy();
        AbstractCompactionTask task =
            strategy.getNextBackgroundTask(getDefaultGcBefore(cfs));
        if (task == null) {
          logger.debug("No tasks available");
          return;
        }
        task.execute(metrics);
      } finally {
        compactingCF.remove(cfs);
      }
      submitBackground(cfs);
    }
  }
  private static interface AllSSTablesOperation {
    public void perform(ColumnFamilyStore store,
                        Iterable<SSTableReader> sstables) throws IOException;
  }
  private void performAllSSTableOperation(final ColumnFamilyStore cfs,
                                          final AllSSTablesOperation operation)
      throws InterruptedException, ExecutionException {
    final Iterable<SSTableReader> sstables = cfs.markAllCompacting();
    if (sstables == null)
      return;
    Callable<Object> runnable = new Callable<Object>() {
      public Object call() throws IOException {
        try {
          operation.perform(cfs, sstables);
        } finally {
          cfs.getDataTracker().unmarkCompacting(sstables);
        }
        return this;
      }
    };
    executor.submit(runnable).get();
  }
  public void performScrub(ColumnFamilyStore cfStore,
                           final boolean skipCorrupted, final boolean checkData)
      throws InterruptedException, ExecutionException {
    performAllSSTableOperation(cfStore, new AllSSTablesOperation() {
      public void perform(ColumnFamilyStore store,
                          Iterable<SSTableReader> sstables) throws IOException {
        doScrub(store, sstables, skipCorrupted, checkData);
      }
    });
  }
  public void performSSTableRewrite(ColumnFamilyStore cfStore,
                                    final boolean excludeCurrentVersion)
      throws InterruptedException, ExecutionException {
    performAllSSTableOperation(cfStore, new AllSSTablesOperation() {
      public void perform(ColumnFamilyStore cfs,
                          Iterable<SSTableReader> sstables) {
        for (final SSTableReader sstable : sstables) {
          if (excludeCurrentVersion &&
              sstable.descriptor.version.equals(Descriptor.Version.CURRENT))
            continue;
          AbstractCompactionTask task =
              cfs.getCompactionStrategy().getCompactionTask(
                  Collections.singleton(sstable), NO_GC, Long.MAX_VALUE);
          task.setUserDefined(true);
          task.setCompactionType(OperationType.UPGRADE_SSTABLES);
          task.execute(metrics);
        }
      }
    });
  }
  public void performCleanup(ColumnFamilyStore cfStore,
                             final CounterId.OneShotRenewer renewer)
      throws InterruptedException, ExecutionException {
    performAllSSTableOperation(cfStore, new AllSSTablesOperation() {
      public void perform(ColumnFamilyStore store,
                          Iterable<SSTableReader> sstables) throws IOException {
        List<SSTableReader> sortedSSTables = Lists.newArrayList(sstables);
        Collections.sort(sortedSSTables, new SSTableReader.SizeComparator());
        doCleanupCompaction(store, sortedSSTables, renewer);
      }
    });
  }
  public void performMaximal(final ColumnFamilyStore cfStore)
      throws InterruptedException, ExecutionException {
    submitMaximal(cfStore, getDefaultGcBefore(cfStore)).get();
  }
  public Future<?> submitMaximal(final ColumnFamilyStore cfStore,
                                 final int gcBefore) {
    final AbstractCompactionTask task =
        cfStore.getCompactionStrategy().getMaximalTask(gcBefore);
    Runnable runnable = new WrappedRunnable() {
      protected void runMayThrow() throws IOException {
        if (task == null)
          return;
        task.execute(metrics);
      }
    };
    return executor.submit(runnable);
  }
  public void forceUserDefinedCompaction(String dataFiles) {
    String[] filenames = dataFiles.split(",");
    Multimap<Pair<String, String>, Descriptor> descriptors =
        ArrayListMultimap.create();
    for (String filename : filenames) {
      Descriptor desc = Descriptor.fromFilename(filename.trim());
      if (Schema.instance.getCFMetaData(desc) == null) {
        logger.warn("Schema does not exist for file {}. Skipping.", filename);
        continue;
      }
      File directory = new File(desc.ksname + File.separator + desc.cfname);
      Pair<Descriptor, String> p =
          Descriptor.fromFilename(directory, filename.trim());
      Pair<String, String> key = Pair.create(p.left.ksname, p.left.cfname);
      descriptors.put(key, p.left);
    }
    List<Future<?>> futures = new ArrayList<>();
    for (Pair<String, String> key : descriptors.keySet()) {
      ColumnFamilyStore cfs =
          Keyspace.open(key.left).getColumnFamilyStore(key.right);
      futures.add(submitUserDefined(cfs, descriptors.get(key),
                                    getDefaultGcBefore(cfs)));
    }
    FBUtilities.waitOnFutures(futures);
  }
  public Future<?> submitUserDefined(final ColumnFamilyStore cfs,
                                     final Collection<Descriptor> dataFiles,
                                     final int gcBefore) {
    Runnable runnable = new WrappedRunnable() {
      protected void runMayThrow() throws IOException {
        Collection<SSTableReader> sstables =
            new ArrayList<SSTableReader>(dataFiles.size());
        for (Descriptor desc : dataFiles) {
          SSTableReader sstable = lookupSSTable(cfs, desc);
          if (sstable == null) {
            logger.info("Will not compact {}: it is not an active sstable",
                        desc);
          } else {
            sstables.add(sstable);
          }
        }
        if (sstables.isEmpty()) {
          logger.info("No files to compact for user defined compaction");
        } else {
          AbstractCompactionTask task =
              cfs.getCompactionStrategy().getUserDefinedTask(sstables,
                                                             gcBefore);
          if (task != null)
            task.execute(metrics);
        }
      }
    };
    return executor.submit(runnable);
  }
  private SSTableReader lookupSSTable(final ColumnFamilyStore cfs,
                                      Descriptor descriptor) {
    for (SSTableReader sstable : cfs.getSSTables()) {
      if (sstable.descriptor.toString().endsWith(descriptor.toString()))
        return sstable;
    }
    return null;
  }
  public Future<Object> submitValidation(final ColumnFamilyStore cfStore,
                                         final Validator validator) {
    Callable<Object> callable = new Callable<Object>() {
      public Object call() throws IOException {
        try {
          doValidationCompaction(cfStore, validator);
        } catch (Throwable e) {
          validator.fail();
          throw e;
        }
        return this;
      }
    };
    return validationExecutor.submit(callable);
  }
  public void disableAutoCompaction() {
    for (String ksname : Schema.instance.getNonSystemKeyspaces()) {
      for (ColumnFamilyStore cfs :
           Keyspace.open(ksname).getColumnFamilyStores())
        cfs.disableAutoCompaction();
    }
  }
  private void doScrub(ColumnFamilyStore cfs, Iterable<SSTableReader> sstables,
                       boolean skipCorrupted, boolean checkData)
      throws IOException {
    assert !cfs.isIndex();
    for (final SSTableReader sstable : sstables)
      scrubOne(cfs, sstable, skipCorrupted, checkData);
  }
  private void scrubOne(ColumnFamilyStore cfs, SSTableReader sstable,
                        boolean skipCorrupted, boolean checkData)
      throws IOException {
    Scrubber scrubber = new Scrubber(cfs, sstable, skipCorrupted, checkData);
    CompactionInfo.Holder scrubInfo = scrubber.getScrubInfo();
    metrics.beginCompaction(scrubInfo);
    try {
      scrubber.scrub();
    } finally {
      scrubber.close();
      metrics.finishCompaction(scrubInfo);
    }
    if (scrubber.getNewInOrderSSTable() != null)
      cfs.addSSTable(scrubber.getNewInOrderSSTable());
    if (scrubber.getNewSSTable() == null)
      cfs.markObsolete(Collections.singletonList(sstable), OperationType.SCRUB);
    else
      cfs.replaceCompactedSSTables(
          Collections.singletonList(sstable),
          Collections.singletonList(scrubber.getNewSSTable()),
          OperationType.SCRUB);
  }
  static boolean needsCleanup(SSTableReader sstable,
                              Collection<Range<Token>> ownedRanges) {
    assert !ownedRanges.isEmpty();
    List<Range<Token>> sortedRanges = Range.normalize(ownedRanges);
    Range<Token> firstRange = sortedRanges.get(0);
    if (sstable.first.token.compareTo(firstRange.left) <= 0)
      return true;
    for (int i = 0; i < sortedRanges.size(); i++) {
      Range<Token> range = sortedRanges.get(i);
      if (range.right.isMinimum()) {
        return false;
      }
      DecoratedKey firstBeyondRange =
          sstable.firstKeyBeyond(range.right.maxKeyBound());
      if (firstBeyondRange == null) {
        return false;
      }
      if (i == (sortedRanges.size() - 1)) {
        return true;
      }
      Range<Token> nextRange = sortedRanges.get(i + 1);
      if (!nextRange.contains(firstBeyondRange.token)) {
        return true;
      }
    }
    return false;
  }
  private void doCleanupCompaction(final ColumnFamilyStore cfs,
                                   Collection<SSTableReader> sstables,
                                   CounterId.OneShotRenewer renewer)
      throws IOException {
    assert !cfs.isIndex();
    Keyspace keyspace = cfs.keyspace;
    Collection<Range<Token>> ranges =
        StorageService.instance.getLocalRanges(keyspace.getName());
    if (ranges.isEmpty()) {
      logger.info("Cleanup cannot run before a node has joined the ring");
      return;
    }
    boolean hasIndexes = cfs.indexManager.hasIndexes();
    CleanupStrategy cleanupStrategy = CleanupStrategy.get(cfs, ranges, renewer);
    for (SSTableReader sstable : sstables) {
      Set<SSTableReader> sstableAsSet = Collections.singleton(sstable);
      if (!hasIndexes &&
          !new Bounds<Token>(sstable.first.token, sstable.last.token)
               .intersects(ranges)) {
        cfs.replaceCompactedSSTables(sstableAsSet,
                                     Collections.<SSTableReader>emptyList(),
                                     OperationType.CLEANUP);
        continue;
      }
      if (!needsCleanup(sstable, ranges)) {
        logger.debug("Skipping {} for cleanup; all rows should be kept",
                     sstable);
        continue;
      }
      CompactionController controller =
          new CompactionController(cfs, sstableAsSet, getDefaultGcBefore(cfs));
      long start = System.nanoTime();
      long totalkeysWritten = 0;
      int expectedBloomFilterSize =
          Math.max(cfs.metadata.getIndexInterval(),
                   (int)(SSTableReader.getApproximateKeyCount(sstableAsSet,
                                                              cfs.metadata)));
      if (logger.isDebugEnabled())
        logger.debug("Expected bloom filter size : " + expectedBloomFilterSize);
      logger.info("Cleaning up " + sstable);
      File compactionFileLocation = cfs.directories.getWriteableLocationAsFile(
          cfs.getExpectedCompactedFileSize(sstableAsSet,
                                           OperationType.CLEANUP));
      if (compactionFileLocation == null)
        throw new IOException("disk full");
      ICompactionScanner scanner =
          cleanupStrategy.getScanner(sstable, getRateLimiter());
      CleanupInfo ci = new CleanupInfo(sstable, scanner);
      metrics.beginCompaction(ci);
      SSTableWriter writer = createWriter(cfs, compactionFileLocation,
                                          expectedBloomFilterSize, sstable);
      SSTableReader newSstable = null;
      try {
        while (scanner.hasNext()) {
          if (ci.isStopRequested())
            throw new CompactionInterruptedException(ci.getCompactionInfo());
          SSTableIdentityIterator row = (SSTableIdentityIterator)scanner.next();
          row = cleanupStrategy.cleanup(row);
          if (row == null)
            continue;
          AbstractCompactedRow compactedRow = controller.getCompactedRow(row);
          if (writer.append(compactedRow) != null)
            totalkeysWritten++;
        }
        if (totalkeysWritten > 0)
          newSstable = writer.closeAndOpenReader(sstable.maxDataAge);
        else
          writer.abort();
      } catch (Throwable e) {
        writer.abort();
        throw Throwables.propagate(e);
      } finally {
        controller.close();
        scanner.close();
        metrics.finishCompaction(ci);
      }
      List<SSTableReader> results = new ArrayList<SSTableReader>(1);
      if (newSstable != null) {
        results.add(newSstable);
        String format = "Cleaned up to %s.  %,d to %,d (~%d%% of original) " +
                        "bytes for %,d keys.  Time: %,dms.";
        long dTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);
        long startsize = sstable.onDiskLength();
        long endsize = newSstable.onDiskLength();
        double ratio = (double)endsize / (double)startsize;
        logger.info(String.format(format, writer.getFilename(), startsize,
                                  endsize, (int)(ratio * 100), totalkeysWritten,
                                  dTime));
      }
      cfs.indexManager.flushIndexesBlocking();
      cfs.replaceCompactedSSTables(Arrays.asList(sstable), results,
                                   OperationType.CLEANUP);
    }
  }
  private static abstract class CleanupStrategy {
    public static CleanupStrategy get(ColumnFamilyStore cfs,
                                      Collection<Range<Token>> ranges,
                                      CounterId.OneShotRenewer renewer) {
      if (cfs.indexManager.hasIndexes() ||
          cfs.metadata.getDefaultValidator().isCommutative())
        return new Full(cfs, ranges, renewer);
      return new Bounded(cfs, ranges);
    }
    public abstract ICompactionScanner getScanner(SSTableReader sstable,
                                                  RateLimiter limiter);
    public abstract SSTableIdentityIterator
    cleanup(SSTableIdentityIterator row);
    private static final class Bounded extends CleanupStrategy {
      private final Collection<Range<Token>> ranges;
      public Bounded(final ColumnFamilyStore cfs,
                     Collection<Range<Token>> ranges) {
        this.ranges = ranges;
        cacheCleanupExecutor.submit(new Runnable() {
          @Override
          public void run() {
            cfs.cleanupCache();
          }
        });
      }
      @Override
      public ICompactionScanner getScanner(SSTableReader sstable,
                                           RateLimiter limiter) {
        return sstable.getScanner(ranges, limiter);
      }
      @Override
      public SSTableIdentityIterator cleanup(SSTableIdentityIterator row) {
        return row;
      }
    }
    private static final class Full extends CleanupStrategy {
      private final Collection<Range<Token>> ranges;
      private final ColumnFamilyStore cfs;
      private List<Column> indexedColumnsInRow;
      private final CounterId.OneShotRenewer renewer;
      public Full(ColumnFamilyStore cfs, Collection<Range<Token>> ranges,
                  CounterId.OneShotRenewer renewer) {
        this.cfs = cfs;
        this.ranges = ranges;
        this.indexedColumnsInRow = null;
        this.renewer = renewer;
      }
      @Override
      public ICompactionScanner getScanner(SSTableReader sstable,
                                           RateLimiter limiter) {
        return sstable.getScanner(limiter);
      }
      @Override
      public SSTableIdentityIterator cleanup(SSTableIdentityIterator row) {
        if (Range.isInRanges(row.getKey().token, ranges))
          return row;
        cfs.invalidateCachedRow(row.getKey());
        if (indexedColumnsInRow != null)
          indexedColumnsInRow.clear();
        while (row.hasNext()) {
          OnDiskAtom column = row.next();
          if (column instanceof CounterColumn)
            renewer.maybeRenew((CounterColumn)column);
          if (column instanceof Column &&
              cfs.indexManager.indexes((Column)column)) {
            if (indexedColumnsInRow == null)
              indexedColumnsInRow = new ArrayList<>();
            indexedColumnsInRow.add((Column)column);
          }
        }
        if (indexedColumnsInRow != null && !indexedColumnsInRow.isEmpty()) {
          Keyspace.switchLock.readLock().lock();
          try {
            cfs.indexManager.deleteFromIndexes(row.getKey(),
                                               indexedColumnsInRow);
          } finally {
            Keyspace.switchLock.readLock().unlock();
          }
        }
        return null;
      }
    }
  }
  public static SSTableWriter createWriter(ColumnFamilyStore cfs,
                                           File compactionFileLocation,
                                           int expectedBloomFilterSize,
                                           SSTableReader sstable) {
    FileUtils.createDirectory(compactionFileLocation);
    return new SSTableWriter(
        cfs.getTempSSTablePath(compactionFileLocation), expectedBloomFilterSize,
        cfs.metadata, cfs.partitioner,
        SSTableMetadata.createCollector(Collections.singleton(sstable),
                                        cfs.metadata.comparator,
                                        sstable.getSSTableLevel()));
  }
  private void doValidationCompaction(ColumnFamilyStore cfs,
                                      Validator validator) throws IOException {
    if (!cfs.isValid())
      return;
    Collection<SSTableReader> sstables;
    String snapshotName = validator.desc.sessionId.toString();
    int gcBefore;
    boolean isSnapshotValidation = cfs.snapshotExists(snapshotName);
    if (isSnapshotValidation) {
      sstables = cfs.getSnapshotSSTableReader(snapshotName);
      gcBefore = cfs.gcBefore(cfs.getSnapshotCreationTime(snapshotName));
    } else {
      StorageService.instance.forceKeyspaceFlush(cfs.keyspace.getName(),
                                                 cfs.name);
      sstables = cfs.markCurrentSSTablesReferenced();
      if (validator.gcBefore > 0)
        gcBefore = validator.gcBefore;
      else
        gcBefore = getDefaultGcBefore(cfs);
    }
    CompactionIterable ci = new ValidationCompactionIterable(
        cfs, sstables, validator.desc.range, gcBefore);
    CloseableIterator<AbstractCompactedRow> iter = ci.iterator();
    metrics.beginCompaction(ci);
    try {
      validator.prepare(cfs);
      while (iter.hasNext()) {
        if (ci.isStopRequested())
          throw new CompactionInterruptedException(ci.getCompactionInfo());
        AbstractCompactedRow row = iter.next();
        validator.add(row);
      }
      validator.complete();
    } finally {
      iter.close();
      SSTableReader.releaseReferences(sstables);
      if (isSnapshotValidation) {
        cfs.clearSnapshot(snapshotName);
      }
      metrics.finishCompaction(ci);
    }
  }
  public Future<?> submitIndexBuild(final SecondaryIndexBuilder builder) {
    Runnable runnable = new Runnable() {
      public void run() {
        metrics.beginCompaction(builder);
        try {
          builder.build();
        } finally {
          metrics.finishCompaction(builder);
        }
      }
    };
    return executor.submit(runnable);
  }
  public Future<?> submitCacheWrite(final AutoSavingCache.Writer writer) {
    Runnable runnable = new Runnable() {
      public void run() {
        if (!AutoSavingCache.flushInProgress.add(writer.cacheType())) {
          logger.debug("Cache flushing was already in progress: skipping {}",
                       writer.getCompactionInfo());
          return;
        }
        try {
          metrics.beginCompaction(writer);
          try {
            writer.saveCache();
          } finally {
            metrics.finishCompaction(writer);
          }
        } finally {
          AutoSavingCache.flushInProgress.remove(writer.cacheType());
        }
      }
    };
    return executor.submit(runnable);
  }
  static int getDefaultGcBefore(ColumnFamilyStore cfs) {
    return cfs.isIndex() ? (int)(System.currentTimeMillis() / 1000)
                         : cfs.gcBefore(System.currentTimeMillis());
  }
  private static class ValidationCompactionIterable extends CompactionIterable {
    public ValidationCompactionIterable(ColumnFamilyStore cfs,
                                        Collection<SSTableReader> sstables,
                                        Range<Token> range, int gcBefore) {
      super(OperationType.VALIDATION,
            cfs.getCompactionStrategy().getScanners(sstables, range),
            new ValidationCompactionController(cfs, gcBefore));
    }
  }
  private static class ValidationCompactionController
      extends CompactionController {
    public ValidationCompactionController(ColumnFamilyStore cfs, int gcBefore) {
      super(cfs, gcBefore);
    }
    @Override
    public boolean shouldPurge(DecoratedKey key, long delTimestamp) {
      return true;
    }
  }
  public int getActiveCompactions() {
    return CompactionMetrics.getCompactions().size();
  }
  private static class CompactionExecutor extends JMXEnabledThreadPoolExecutor {
    protected CompactionExecutor(int minThreads, int maxThreads, String name,
                                 BlockingQueue<Runnable> queue) {
      super(minThreads, maxThreads, 60, TimeUnit.SECONDS, queue,
            new NamedThreadFactory(name, Thread.MIN_PRIORITY), "internal");
    }
    private CompactionExecutor(int threadCount, String name) {
      this(threadCount, threadCount, name, new LinkedBlockingQueue<Runnable>());
    }
    public CompactionExecutor() {
      this(Math.max(1, DatabaseDescriptor.getConcurrentCompactors()),
           "CompactionExecutor");
    }
    protected void beforeExecute(Thread t, Runnable r) {
      isCompactionManager.set(true);
      super.beforeExecute(t, r);
    }
    @Override
    public void afterExecute(Runnable r, Throwable t) {
      DebuggableThreadPoolExecutor.maybeResetTraceSessionWrapper(r);
      if (t == null)
        t = DebuggableThreadPoolExecutor.extractThrowable(r);
      if (t != null) {
        if (t instanceof CompactionInterruptedException) {
          logger.info(t.getMessage());
          logger.debug("Full interruption stack trace:", t);
        } else {
          DebuggableThreadPoolExecutor.handleOrLog(t);
        }
      }
    }
  }
  private static class ValidationExecutor extends CompactionExecutor {
    public ValidationExecutor() {
      super(1, Integer.MAX_VALUE, "ValidationExecutor",
            new SynchronousQueue<Runnable>());
    }
  }
  private static class CacheCleanupExecutor extends CompactionExecutor {
    public CacheCleanupExecutor() { super(1, "CacheCleanupExecutor"); }
  }
  public interface CompactionExecutorStatsCollector {
    void beginCompaction(CompactionInfo.Holder ci);
    void finishCompaction(CompactionInfo.Holder ci);
  }
  public List<Map<String, String>> getCompactions() {
    List<Holder> compactionHolders = CompactionMetrics.getCompactions();
    List<Map<String, String>> out =
        new ArrayList<Map<String, String>>(compactionHolders.size());
    for (CompactionInfo.Holder ci : compactionHolders)
      out.add(ci.getCompactionInfo().asMap());
    return out;
  }
  public List<String> getCompactionSummary() {
    List<Holder> compactionHolders = CompactionMetrics.getCompactions();
    List<String> out = new ArrayList<String>(compactionHolders.size());
    for (CompactionInfo.Holder ci : compactionHolders)
      out.add(ci.getCompactionInfo().toString());
    return out;
  }
  public TabularData getCompactionHistory() {
    try {
      return SystemKeyspace.getCompactionHistory();
    } catch (OpenDataException e) {
      throw new RuntimeException(e);
    }
  }
  public long getTotalBytesCompacted() {
    return metrics.bytesCompacted.count();
  }
  public long getTotalCompactionsCompleted() {
    return metrics.totalCompactionsCompleted.count();
  }
  public int getPendingTasks() { return metrics.pendingTasks.value(); }
  public long getCompletedTasks() { return metrics.completedTasks.value(); }
  private static class CleanupInfo extends CompactionInfo.Holder {
    private final SSTableReader sstable;
    private final ICompactionScanner scanner;
    public CleanupInfo(SSTableReader sstable, ICompactionScanner scanner) {
      this.sstable = sstable;
      this.scanner = scanner;
    }
    public CompactionInfo getCompactionInfo() {
      try {
        return new CompactionInfo(sstable.metadata, OperationType.CLEANUP,
                                  scanner.getCurrentPosition(),
                                  scanner.getLengthInBytes());
      } catch (Exception e) {
        throw new RuntimeException();
      }
    }
  }
  public void stopCompaction(String type) {
    OperationType operation = OperationType.valueOf(type);
    for (Holder holder : CompactionMetrics.getCompactions()) {
      if (holder.getCompactionInfo().getTaskType() == operation)
        holder.stop();
    }
  }
  public int getCoreCompactorThreads() { return executor.getCorePoolSize(); }
  public void setCoreCompactorThreads(int number) {
    executor.setCorePoolSize(number);
  }
  public int getMaximumCompactorThreads() {
    return executor.getMaximumPoolSize();
  }
  public void setMaximumCompactorThreads(int number) {
    executor.setMaximumPoolSize(number);
  }
  public int getCoreValidationThreads() {
    return validationExecutor.getCorePoolSize();
  }
  public void setCoreValidationThreads(int number) {
    validationExecutor.setCorePoolSize(number);
  }
  public int getMaximumValidatorThreads() {
    return validationExecutor.getMaximumPoolSize();
  }
  public void setMaximumValidatorThreads(int number) {
    validationExecutor.setMaximumPoolSize(number);
  }
  public void interruptCompactionFor(Iterable<CFMetaData> columnFamilies,
                                     boolean interruptValidation) {
    assert columnFamilies != null;
    for (Holder compactionHolder : CompactionMetrics.getCompactions()) {
      CompactionInfo info = compactionHolder.getCompactionInfo();
      if ((info.getTaskType() == OperationType.VALIDATION) &&
          !interruptValidation)
        continue;
      if (Iterables.contains(columnFamilies, info.getCFMetaData()))
        compactionHolder.stop();
    }
  }
}